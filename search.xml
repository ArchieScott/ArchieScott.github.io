<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode 1025. 除数博弈</title>
    <url>/posts/21f84c53/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/divisor-game/" target="_blank" rel="noopener">题目链接</a><br>
爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。<br>
最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：<br>
选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。<br>
用 N - x 替换黑板上的数字 N 。<br>
如果玩家无法执行这些操作，就会输掉游戏。<br>
只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。</p>
<p>示例 1：<br>
输入：2<br>
输出：true<br>
解释：爱丽丝选择 1，鲍勃无法进行操作。</p>
<p>示例 2：<br>
输入：3<br>
输出：false<br>
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</p>
<h3 id="思路一：数学推导">思路一：数学推导</h3>
<p>当 N 为奇数的时候，选出的 x 为了能够让 N 整除，必定要是奇数，而奇数减掉奇数一定得到偶数，因此假如甲拿到了奇数，乙一定拿到一个偶数，此时乙只需要减一，还给甲一个奇数，这样乙可以一直拿到偶数，一直到最后拿到 2，甲输了。<br>
当 N 为偶数的时候，过程与上面正好相反，总之，开始时谁拿到奇数谁就会一直拿到奇数，谁就输了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (N % <span class="number">2</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路二：动态规划">思路二：动态规划</h3>
<p>在来看一种稍微复杂一点的方法，但是属于常规解法，就是动态规划。<br>
我们用 dp[i] 表示 alice 拿到的数为 i 时是否一定能够获胜，而这个 dp[i] 取决于 bob 拿到 1 ~ N - 1 是否能获胜，也就是说，如果 bob 拿到 i 一定会输，那么 alice 只需要拿 N - i 就可以保证一定赢，而 bob 拿到 i 一定会输其实正好对应着 dp[N - i] = true，dp[i] = false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[k] == <span class="literal">false</span> &amp;&amp; (i % (i - k) == <span class="number">0</span>)) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0064. 最小路径和</title>
    <url>/posts/7aef5434/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">题目链接</a><br>
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>
说明：每次只能向下或者向右移动一步。</p>
<p>示例:<br>
输入:<br>
[ [1,3,1], [1,5,1], [4,2,1] ]<br>
输出: 7<br>
解释: 因为路径 1→3→1→1→1 的总和最小。</p>
<h3 id="思路一：动态规划">思路一：动态规划</h3>
<p>看到这种路径问题，首先想到动态规划。<br>
矩阵中的坐标 (i, j) 可以通过 (i - 1, j) 或者 (i, j - 1) 移动而来，我们用 dp[i][j] 表示从左上角到达该坐标的最小路径和，那么可以推出下面的等式：<br>
<code>dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</code><br>
最后得到的 dp[m - 1][n - 1] 即为所求最小路径和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">std</span>::<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LCOF 011. 旋转数组的最小数字</title>
    <url>/posts/5c665bd6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/" target="_blank" rel="noopener">题目链接</a><br>
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为 1。</p>
<p>示例 1：<br>
输入：[3,4,5,1,2]<br>
输出：1</p>
<p>示例 2：<br>
输入：[2,2,2,0,1]<br>
输出：0</p>
<h3 id="思路一：二分查找">思路一：二分查找</h3>
<p>按照题目要求旋转后的数组满足这样的性质：<br>
设该数组的最后一个数为 x，那么我们要找的最小值左边的所有元素都大于这个 x，右边所有元素都小于等于这个 x，那么我们可以使用在 LeetCode 1095 中介绍的二分方法来写这个二分查找。<br>
如果在二分的时候，我们取到的 mid 下标对应的值小于区间最右边的值，说明 mid 右边是递增的顺序，最小值肯定在 mid 的左边；<br>
同理，如果取到的 mid 下标对应的值大于区间最右边的值，说明 mid 左边是递增的顺序，最小值肯定在 mid 的右边；<br>
但是如果相等，我们是无法判断此时最小值在 mid 的左边或者右边，而因为值相等，此时可以缩小右边界消除一个重复值，继续查找；<br>
按照上面的规律不断缩小查找范围，直到找到最小值退出循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary-Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0095. 不同的二叉搜索树 II</title>
    <url>/posts/c0ca1b63/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">题目链接</a><br>
给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p>
<p>示例：<br>
输入：3<br>
输出：<br>
[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ]</p>
<h3 id="思路一：回溯法">思路一：回溯法</h3>
<p>考虑二叉搜索树的性质，当我们以结点 i 为根节点时，则结点 [1, i - 1] 在结点 i 的左子树，结点 [i + 1, n] 在结点 i 的右子树，之后我们可以递归对这两个区间分别进行递归，递归函数 process 用于生成区间 [left, right] 之间的所有可能的搜索二叉树。<br>
需要注意的是，process 函数处理左右子树的时候，得到的也都是不同形状子二叉树的集合，那么对于每种左子树，都要完整地遍历一边右子树可能的形状才能确保不漏掉结果。<br>
最后子区间返回对应子区间中可能的所有二叉树，与根节点连接后即为结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(<span class="number">0</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process</span>(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">process</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; <span class="built_in">end</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="comment">// 对于区间内的每个结点都要遍历, 尝试将其设置为根结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt; leftSubTree = <span class="built_in">process</span>(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt; rightSubTree = <span class="built_in">process</span>(i + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; leftNode : leftSubTree) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; rightNode : rightSubTree) &#123;</span><br><span class="line">                    TreeNode* curNode = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    curNode-&gt;left = leftNode;</span><br><span class="line">                    curNode-&gt;right = rightNode;</span><br><span class="line">                    res.emplace_back(curNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0312. 戳气球</title>
    <url>/posts/6ebf1ac6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">题目链接</a><br>
有 n 个气球，编号为 0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。<br>
现在要求你戳破所有的气球。如果你戳破气球 i，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。<br>
求所能获得硬币的最大数量。</p>
<p>说明:<br>
你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。<br>
0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</p>
<p>示例:<br>
输入: [3,1,5,8]<br>
输出: 167<br>
解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []<br>
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</p>
<h3 id="思路一：记忆化搜索">思路一：记忆化搜索</h3>
<p>这道题如果按照模拟戳气球的方式来求解，会出现区间不连续的情况：<br>
对于 [0, n - 1] 这个区间，我们戳破气球 i，则原区间变为 [0, i - 1] 和 [i + 1, n - 1] 两个区间，而两个气球可能从不相邻变成相邻的状态，后续讨论会复杂很多。<br>
因此这道题可以将顺序反过来看，从戳气球变成添加气球，每一次选择一个开区间 (i, j) 添加气球 k，这个区间内都是空的，那么此时可以得到的得分为 nums[i] * nums[k] * nums[j]，接下来只需要递归计算 (i, k) 与 (k, j) 两个开区间的最大得分是多少即可。<br>
为了降低时间复杂度，我们使用一个二维数组 memo 来记录开区间 (i, j) 之间能够获取到的最高得分。这样已经计算过的区间最大得分就不用重复计算了，时间复杂度可以降低至 O(n^3)。<br>
此外，还有一点需要注意的是在递归的 for 循环中，可能会出现进入迭代时 k 与 i 或者 j 只差 1 的情况，此时作为开区间不能再向中间插入 k 了，因此需要添加限制条件 <code>i &gt;= j - 1</code> 时直接返回 0，否则会返回 memo 数组中的值，得到错误的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numsVec</span><span class="params">(nums.<span class="built_in">size</span>() + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        numsVec[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        numsVec[numsVec.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将 nums 拷贝到 numsVec 中</span></span><br><span class="line">        <span class="built_in">std</span>::copy(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), numsVec.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">memo</span><span class="params">(numsVec.<span class="built_in">size</span>(), <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(numsVec.<span class="built_in">size</span>(), <span class="number">-1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process</span>(numsVec, <span class="number">0</span>, numsVec.<span class="built_in">size</span>() - <span class="number">1</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numsVec, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">            memo[i][j] = <span class="built_in">std</span>::<span class="built_in">max</span>(memo[i][j], \</span><br><span class="line">                                  <span class="built_in">process</span>(numsVec, i, k, memo) + \</span><br><span class="line">                                  numsVec[i] * numsVec[k] * numsVec[j] + \</span><br><span class="line">                                  <span class="built_in">process</span>(numsVec, k, j, memo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路二：动态规划">思路二：动态规划</h3>
<p>既然已经写出了记忆化搜索，动态规划的方法其实很容易改出来。<br>
前面的初始化过程完全相同，然后我们创建一个 dp 数组，数组中的元素 dp[i][j] 表示开区间内 (i, j) 内所有的气球全部戳破能获得的最高得分，因此 dp[0][n + 1] 即为所求。<br>
而整个 dp 数组更新的方向为从对角线向左下和右上两个角不断更新，同时为了保证开区间的性质，下标 i 的取值范围为 [0, j - 1)，下标 j 的取值范围为 [i + 2, n]，又因为是垂直对角线斜着方向更新，i 和 j 必定是一个增大一个减小，需要注意一下方向，此外，计算最大分数的时候使用的数组应该是经过修改的 numsVec 而非原数组 nums。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numsVec</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        numsVec[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        numsVec[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将 nums 拷贝到 numsVec 中</span></span><br><span class="line">        <span class="built_in">std</span>::copy(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), numsVec.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">std</span>::<span class="built_in">max</span>(dp[i][j], dp[i][k] + dp[k][j] + numsVec[i] * numsVec[k] * numsVec[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0097. 交错字符串</title>
    <url>/posts/514d6416/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">题目链接</a><br>
给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<p>示例 1:<br>
输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”<br>
输出: true</p>
<p>示例 2:<br>
输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbbaccc”<br>
输出: false</p>
<h3 id="思路一：动态规划">思路一：动态规划</h3>
<p>这道题一开始想到的是双指针，但是当出现相同字符的时候，其实指针的移动是不确定的，如果用回溯的话，当相同字符很多的时候，时间复杂度太高，最好还是用动态规划来解决。<br>
看到一个 LeetCode 高赞的题解写的很棒，其实这道题可以转换为一个二维数组求路径的问题，将两个字符串分别作为数组的行和列，那么 dp[i][j] 表示的就是 s1 的前 i 个字符和 s2 的前 j 个字符能否拼出 s3 的前 i+j 个字符，当 i+j 等于 s3 的长度时，也就能够得到 s1 和 s2 能否拼出 s3 了。<br>
那么坐标 (i, j) 可以由两个坐标移动得到，(i - 1, j) 通过选择 s1[i - 1] 或者 (i, j - 1) 通过选择 s2[j - 1]，因此递推公式为：<br>
<code>dp[i][j] = (dp[i - 1][j] &amp;&amp; s3[i + j - 1] == s1[i - 1]) || (dp[i][j - 1] &amp;&amp; s3[i + j - 1] == s2[j - 1])</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s1, <span class="built_in">std</span>::<span class="built_in">string</span> s2, <span class="built_in">std</span>::<span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (s3.<span class="built_in">size</span>() != m + n)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (i &lt;= m)&amp;&amp;(s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>]); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (j &lt;= n)&amp;&amp;(s2[j - <span class="number">1</span>] == s3[j - <span class="number">1</span>]); ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                dp[i][j] = (dp[i - <span class="number">1</span>][j] &amp;&amp; s3[i + j - <span class="number">1</span>] == s1[i - <span class="number">1</span>]) || (dp[i][j - <span class="number">1</span>] &amp;&amp; s3[i + j - <span class="number">1</span>] == s2[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0096. 不同的二叉搜索树</title>
    <url>/posts/62ecdc8d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">题目链接</a><br>
给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:<br>
输入: 3<br>
输出: 5<br>
解释:<br>
给定 n = 3, 一共有 5 种不同结构的二叉搜索树。</p>
<h3 id="思路一：动态规划">思路一：动态规划</h3>
<p>题目让我们使用 1 到 n 构造二叉搜索树，那么我们可以遍历所有值，将每个值依次作为根结点，那么比它小的就是它的左子树，比它大的就是它的右子树，并且由于根的不同，能够确保每个搜索二叉树都是唯一的。<br>
我们用一个 dp 数组来保存长度为 n 的序列能构成的不同二叉搜索树的个数，那么 dp[n] 即为所求。<br>
接下来我们看 dp[n] 依赖什么，不难看出，dp[n] 其实是一组乘积的和：<br>
<code>dp[0]*dp[n - 1] + dp[1]*dp[n - 2] + dp[2]*dp[n - 3] + ...</code><br>
注意这里因为少了根节点，所有左右子树的结点和应该是 n - 1，那么其实 dp[n] 就是依赖 dp[0] 到 dp[n - 1]，我们直接从小到大推 dp 矩阵即可。<br>
其实这道题也是数学上的<strong>卡特兰数</strong>，出栈顺序的问题也可以用卡特兰数来解决，公式如下：<br>
<code>H(n) = Cn(2n)/(n + 1)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0120. 三角形最小路径和</title>
    <url>/posts/8844d94a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">题目链接</a><br>
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<br>
相邻的结点在这里指的是下标与上一层结点下标相同或者等于上一层结点下标 + 1 的两个结点。<br>
例如，给定三角形：<br>
[<br>
[2],<br>
[3,4],<br>
[6,5,7],<br>
[4,1,8,3]<br>
]<br>
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<h3 id="思路一：动态规划">思路一：动态规划</h3>
<p>题目要求最小路径和，那么我们可以将每一步路径的和都保存下来存入 dp 数组，dp[i][j] 表示从顶部走到坐标 (i, j) 处的最小路径和，考虑到三角形的特性，如果要走到坐标 (i, j)，它的前一个位置必须是 (i - 1, j) 或 (i - 1, j - 1)，dp[i][j] 中应该保存这两者中的较小值与 triangle[i][j] 的和。<br>
编写代码的时候需要注意，三角形的边不能再向两边移动了，因此 dp[i][0] 和 dp[i][i] 都只能从 dp[i - 1][0] 与 dp[i - 1][i - 1] 转移过来，最后还需要花一个 O(n) 的时间复杂度在 dp[i - 1] 这个数组中找到最小值即为结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">std</span>::<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][i] = dp[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *min_element(dp[n - <span class="number">1</span>].<span class="built_in">begin</span>(), dp[n - <span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>老友记：下班偶遇石头哥</title>
    <url>/posts/e0228b39/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>忙里偷闲，加班累了在深圳湾人才公园跑了五公里步，回公司坐地铁回去。</p>
<p>没想到竟然在地铁上碰到了半年未见的石头哥，世界还是挺小的，合影留念。<br>
<img src= "/img/loading.gif" data-src="https://i.loli.net/2020/07/13/m5XpBb716VrSnat.jpg" alt="DailyLife0001.jpg"></p>
<p>都说遇到老朋友就像邂逅了从前的自己，想到大家上一次一起出去户外已经差不多一年了，心里突然有无限感慨。今天看到了一句很浪漫的话：</p>
<p>The light you see looking at a star is light that has travelled across the universe and never touched a thing till hitting the back of your eyes.<br>
你见到的星光穿越整个宇宙，没有碰到任何物体，直到它照进你的眼睛。</p>
<p>走出地铁站的时候，星光已经隐匿在城市的灯光中，陪伴着我的只有晚风和耳机里罗嘉良的《准我留下》，这么舒适的晚上不适合伤感，还是买半个西瓜吃吧。</p>
]]></content>
      <categories>
        <category>DailyLife</category>
      </categories>
      <tags>
        <tag>DailyLife</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0174. 地下层游戏</title>
    <url>/posts/f7e2068f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">题目链接</a><br>
一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。<br>
骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。<br>
有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。<br>
为了尽快到达公主，骑士决定每次只向右或向下移动一步。<br>
编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。<br>
例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">-2</span> (K)  <span class="number">-3</span>     <span class="number">3</span></span><br><span class="line"><span class="number">-5</span>      <span class="number">-10</span>    <span class="number">1</span></span><br><span class="line"><span class="number">10</span>       <span class="number">30</span>   <span class="number">-5</span> (P)</span><br></pre></td></tr></table></figure>
<p>说明:<br>
骑士的健康点数没有上限。<br>
任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p>
<h3 id="思路一：动态规划">思路一：动态规划</h3>
<p>这道题一个比较关键的点就是动态规划必须要从终点开始向起点推导，原因是从起点向终点推的时候有两个相同重要的因素会影响到后续的走向，一个是使得路径和尽量大，另一个是使得到达当前点的初始值尽可能小（否则骑士就要挂在路上了），这两点使得该问题不再是一个无后效性问题，这样是推不出结果的。<br>
而从终点向起点推导，我们可以假设 dp[i][j] 表示从坐标 (i, j) 到达终点所需的最小初值，这样就无需再关心路径和了，因为只要能到达 (i, j) 并且保证 dp[i][j] 的最小初值，就一定能到达终点。<br>
下面来看代码的几个细节，首先 dp 矩阵的大小为 (m + 1) * (n + 1)，初始值设置为 INT_MAX，表示任何位置开始的结果都为无穷大，终点 dp[m - 1][n - 1] 是通过 dp[m][n - 1] 和 dp[m - 1][n] 推出来的，而到达终点后需要保证剩余健康点数大于 0，那么要保证 dp[m - 1][n] = dp[m][n - 1] = 1。<br>
然后找到 dp[i][j] 能够到达的两个点 dp[i + 1][j] 和 dp[i][j + 1]，取它们俩中的较小值，注意这个较小值才是在最终的路径上的，然后减去 dungeon[i][j]，这表示到达坐标 (i, j) 之前需要达到的值，如果小于 1 就取 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.<span class="built_in">size</span>(), n = dungeon[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, INT_MAX))</span></span>;</span><br><span class="line">        dp[m - <span class="number">1</span>][n] = dp[m][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> minblood = <span class="built_in">std</span>::<span class="built_in">min</span>(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                dp[i][j] = <span class="built_in">std</span>::<span class="built_in">max</span>(minblood - dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0063. 不同路径 II</title>
    <url>/posts/d3ae32e8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">题目链接</a><br>
一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。<br>
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>
网格中的障碍物和空位置分别用 1 和 0 来表示。<br>
说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:<br>
输入:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输出: 2<br>
解释:<br>
3x3 网格的正中间有一个障碍物。<br>
从左上角到右下角一共有 2 条不同的路径：<br>
向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br>
向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</p>
<h3 id="思路一：动态规划">思路一：动态规划</h3>
<p>可以用 dp[i][j] 表示从坐标 (0, 0) 到坐标 (i, j) 的路径数量，用 ob[i][j] 表示是否有障碍物。<br>
由于机器人每次只能向下或者向右移动，可以得出下面的动态规划转移方程：<br>
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]<br>
注意上面的方程只在 ob[i][j] != 0 的时候才成立，否则 dp[i][j] = 0。<br>
看上面的转移方程不难发现，dp 数组中更新的值只依赖它左边和上面的值，那么我们可以用滚动数组对额外空间复杂度进行优化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0209. 长度最小的子数组</title>
    <url>/posts/66a7e67f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">题目链接</a><br>
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p>
<p>示例：<br>
输入：s = 7, nums = [2,3,1,2,4,3]<br>
输出：2<br>
解释：子数组 [4,3] 是该条件下的长度最小的连续子数组。</p>
<h3 id="思路一：双指针滑动窗口">思路一：双指针滑动窗口</h3>
<p>首先双指针 left 和 right 都指向起始位置，向右移动 right 的同时累加 nums[right] 到 sum 中，如果 sum 小于 s，就继续向右移动 right 并累加 sum，当 sum 大于等于 s 的时候，计算此时 left 到 right 的长度并且取其与 res 的较小值，然后在循环中向右移动 left 并且更新 sum，直到 sum 小于 s 了跳出循环继续向右移动 right，当 right 到达数组最右端后就可以结束循环了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX, numsLen = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; numsLen) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                res = <span class="built_in">std</span>::<span class="built_in">min</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Two-Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0041. 缺失的第一个正数</title>
    <url>/posts/7531651f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">题目链接</a><br>
给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<p>示例 1:<br>
输入: [1,2,0]<br>
输出: 3</p>
<p>示例 2:<br>
输入: [3,4,-1,1]<br>
输出: 2</p>
<p>示例 3:<br>
输入: [7,8,9,11,12]<br>
输出: 1</p>
<p>提示：<br>
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。</p>
<h3 id="思路一：利用数组原地哈希">思路一：利用数组原地哈希</h3>
<p>题目中要求的最小正整数的范围应该是 1 ~ ArrayLen + 1，也就是说，如果数组中的所有数字正好从 1 ~ ArrayLen，答案就是 ArrayLen + 1。<br>
本来这道题可以通过额外的哈希表来做到 O(n) - O(n) 的复杂度，但是由于题目要求的是 O(1) 的额外空间复杂度，那么我们可以考虑原地哈希，即将输入的数组作为哈希表。<br>
那么哈希函数可以这么考虑，在下标为 i 的地方保存 i + 1，这样下标 0 应该保存 1，下标 1 应该保存 2，以此类推，当所有的数都哈希完成后重新遍历数组，找到的第一个 nums[i] != i + 1 的数就是答案。<br>
在交换过程中需要注意以下几点：<br>
首先 nums[i] 上的值必须在 1 ~ numsLen 之间，也就是说必须要找到能替换的值才能交换；<br>
如果要交换的那个数 nums[nums[i] - 1] 已经等于当前值 nums[i] 了，此时就没有必要交换了；<br>
最后这种写法是不断将当前 nums[i] 换到合适的位置，直到不能换位置，因此无需加上 nums[i] == i + 1 的判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsLen = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= numsLen &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numsLen + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LCCI 02.01. 移除重复结点</title>
    <url>/posts/6e77f4e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener">题目链接</a><br>
编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:<br>
输入：[1, 2, 3, 3, 2, 1]<br>
输出：[1, 2, 3]</p>
<p>示例2:<br>
输入：[1, 1, 1, 1, 2]<br>
输出：[1, 2]</p>
<h3 id="思路一：使用哈希集合保存遍历过的结点">思路一：使用哈希集合保存遍历过的结点</h3>
<p>这题的思路其实挺简单的，如果要保证 O(n) 时间复杂度，就必须用哈希表将遍历的结点值保存下来，需要注意的点有两个：<br>
一个是 while 中还需要判断 curNode 不为空，但这其实逻辑上有保证，这个只是写给编译器看的；<br>
一个是只有当在 nodeSet 中查找不到对应结点值，插入后才需要将 curNode 向后移动，不然只需要将 curNode-&gt;next 指向 curNode-&gt;next-&gt;next 即可，就可以视为 curNode 向后移动了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeDuplicateNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curNode = head;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nodeSet;</span><br><span class="line">        nodeSet.insert(head-&gt;val);</span><br><span class="line">        <span class="keyword">while</span> (curNode &amp;&amp; curNode-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeSet.<span class="built_in">find</span>(curNode-&gt;next-&gt;val) != nodeSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                curNode-&gt;next = curNode-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nodeSet.insert(curNode-&gt;next-&gt;val);</span><br><span class="line">                curNode = curNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked-List</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0139. 单词拆分</title>
    <url>/posts/6477fb26/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">题目链接</a><br>
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：<br>
拆分时可以重复使用字典中的单词。<br>
你可以假设字典中没有重复的单词。</p>
<p>示例 1：<br>
输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>
输出: true<br>
解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p>
<p>示例 2：<br>
输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>
输出: true<br>
解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>
     注意你可以重复使用字典中的单词。</p>
<p>示例 3：<br>
输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>
输出: false</p>
<h3 id="思路一：动态规划">思路一：动态规划</h3>
<p>我们用一个长度为 s.size() + 1 的 dp 数组来表示字符串的前 i 个字符能否在 wordDict 中查找到，为了便于查找，我们将 wordDict 先放入一个 unordered_set 中。<br>
假设 dp[i] 为 true，说明 s 的前 i 个字符能够在 wordSet 中查找到，那么对于大于 i 的 j 来说，dp[j] 是否为 true 取决于 s.substr(i, j - i) 这个字符串能否在 wordSet 中查找到。<br>
那么答案就显而易见了，我们从左到右更新 dp 数组，先逐个确定字符串的左半部分，然后依次判断右半部分是否在 wordSet 中，最后的 dp[s.size()] 即为答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wordDict.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= s.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !dp[i])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(s.substr(i, j - i)) != wordSet.<span class="built_in">end</span>())</span><br><span class="line">                    dp[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0016. 最接近的三数之和</title>
    <url>/posts/fffdcab5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">题目链接</a><br>
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>示例：<br>
输入：nums = [-1,2,1,-4], target = 1<br>
输出：2<br>
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p>
<h3 id="思路一：双指针">思路一：双指针</h3>
<p>这道题和上一道 0015 做法类似，使用排序 + 双指针解决。<br>
首先对原数组排序，然后从第一个元素开始，依次确定一个数，剩下的两个数分别从首尾向中间夹逼。<br>
我们分别记录三个数的和，当和等于 target 时，说明此时离 target 最近，直接返回 sum；<br>
如果 sum &lt; target，说明此时和小于 target，比较 sum - target 和 diff，如果小于 diff 就更新 diff，然后将 leftIdx++，否则就 rightIdx–，并且更新 diff，当外层 for 循环遍历结束后就找到 diff。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> diff = INT_MAX;</span><br><span class="line">        <span class="comment">// 先排序</span></span><br><span class="line">        <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftIdx = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightIdx = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(leftIdx &lt; rightIdx) &#123;</span><br><span class="line">                <span class="comment">// 确定 i, 然后将 leftIdx 与 rightIdx 夹逼</span></span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[leftIdx] + nums[rightIdx];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 新的偏差小于 diff 时才更新 res, 否则只修改左右指针</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (target - sum &lt; diff) &#123;</span><br><span class="line">                        diff = target - sum;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    leftIdx++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sum - target &lt; diff) &#123;</span><br><span class="line">                        diff = sum - target;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rightIdx--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Two-Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0067. 二进制求和</title>
    <url>/posts/caaaa3d0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">题目链接</a><br>
给你两个二进制字符串，返回它们的和（用二进制表示）。<br>
输入为非空字符串且只包含数字 1 和 0。</p>
<p>示例 1:<br>
输入: a = “11”, b = “1”<br>
输出: “100”</p>
<p>示例 2:<br>
输入: a = “1010”, b = “1011”<br>
输出: “10101”</p>
<p>提示：<br>
每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。<br>
1 &lt;= a.length, b.length &lt;= 10^4<br>
字符串如果不是 “0” ，就都不含前导零。</p>
<h3 id="思路一：模拟二进制加法">思路一：模拟二进制加法</h3>
<p>这道题的加法和之前有一道链表求和的题目有点像，那道题中数据是反过来的，会比较好处理进位，因此本题我们也先将字符串逆序，便于处理进位，在高位补 0 也更加方便。<br>
当长度为 max(a.size(), b.size()) 的字符串相加完成后，如果此时还有进位，需要再向 res 中 push 一个 ‘1’，最后将 res 再逆序即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> a, <span class="built_in">std</span>::<span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">std</span>::reverse(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">std</span>::reverse(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> maxBitNum = <span class="built_in">std</span>::<span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> carryBit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxBitNum; ++i) &#123;</span><br><span class="line">            carryBit += i &lt; a.<span class="built_in">size</span>() ? (a[i] == <span class="string">'1'</span>) : <span class="number">0</span>;</span><br><span class="line">            carryBit += i &lt; b.<span class="built_in">size</span>() ? (b[i] == <span class="string">'1'</span>) : <span class="number">0</span>;</span><br><span class="line">            res += (carryBit % <span class="number">2</span>) ? <span class="string">"1"</span> : <span class="string">"0"</span>;</span><br><span class="line">            carryBit /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carryBit)</span><br><span class="line">            res += <span class="string">"1"</span>;</span><br><span class="line">        <span class="built_in">std</span>::reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LCCI 16.18. 模式匹配</title>
    <url>/posts/f7de8451/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/pattern-matching-lcci/" target="_blank" rel="noopener">题目链接</a><br>
你有两个字符串，即 pattern 和 value。pattern 字符串由字母 “a” 和 “b” 组成，用于描述字符串中的模式。<br>
例如，字符串 “catcatgocatgo” 匹配模式 “aabab”（其中 “cat” 是 “a”，“go” 是 “b”），该字符串也匹配像 “a”、“ab” 和 “b” 这样的模式。但需注意 “a” 和 “b” 不能同时表示相同的字符串。编写一个方法判断 value 字符串是否匹配 pattern 字符串。</p>
<p>示例 1：<br>
输入： pattern = “abba”, value = “dogcatcatdog”<br>
输出： true</p>
<p>示例 2：<br>
输入： pattern = “abba”, value = “dogcatcatfish”<br>
输出： false</p>
<p>示例 3：<br>
输入： pattern = “aaaa”, value = “dogcatcatdog”<br>
输出： false</p>
<p>示例 4：<br>
输入： pattern = “abba”, value = “dogdogdogdog”<br>
输出： true<br>
解释： “a”=“dogdog”, b=&quot;&quot;，反之也符合规则</p>
<p>提示：<br>
0 &lt;= len(pattern) &lt;= 1000<br>
0 &lt;= len(value) &lt;= 1000<br>
你可以假设 pattern 只包含字母 “a” 和 “b”，value 仅包含小写字母。</p>
<h3 id="思路一：枚举">思路一：枚举</h3>
<p>首先求出 a 和 b 能够表示的最大子串长度，即 <code>vLens/aNum</code> 和 <code>vLens/bNum</code><br>
只有当 <code>aNum * subaLens + bNum * subbLens == vLens</code> 的时候才是一组可能解<br>
知道了 a 的长度和 b 的长度后，我们就可以按照模式串来匹配 value，从模式串的第一个字母开始，假设为 a，那么从 value 第一个字符起数 subaLens 个字符即为 a 代表的字符串，每一次提取子串，都需要将其与子串 a 或者 b 比较，只有相同才能继续向后迭代，不相同说明这种情况匹配失败。<br>
如果匹配到最后都没有失败，我们还需要判断 a 和 b 是否相等，只有当 a != b 的时候才是符合要求的匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">patternMatching</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> pattern, <span class="built_in">std</span>::<span class="built_in">string</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pLens = pattern.<span class="built_in">size</span>(), vLens = value.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (pLens == <span class="number">0</span> &amp;&amp; vLens == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pLens == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> aNum = <span class="number">0</span>, bNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 统计子串 a 和子串 b 的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : pattern) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'a'</span>)</span><br><span class="line">                aNum++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                bNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> subaLens = <span class="number">0</span>, subbLens = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 求出子串 a 和子串 b 的最大长度</span></span><br><span class="line">        <span class="keyword">if</span> (aNum)</span><br><span class="line">            subaLens = vLens / aNum;</span><br><span class="line">        <span class="keyword">if</span> (bNum)</span><br><span class="line">            subbLens = vLens / bNum;</span><br><span class="line">        <span class="comment">// 依次枚举, 只有当长度满足要求时才进入判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= subaLens; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= subbLens; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i * aNum + j * bNum == vLens) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">string</span> substra = <span class="string">"#"</span>;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">string</span> substrb = <span class="string">"#"</span>;</span><br><span class="line">                    <span class="keyword">int</span> curIdx = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; pLens; ++k) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (pattern[k] == <span class="string">'a'</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (substra == <span class="string">"#"</span>) &#123;</span><br><span class="line">                                substra = value.substr(curIdx, i);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (substra != value.substr(curIdx, i))</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            curIdx += i;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (substrb == <span class="string">"#"</span>) &#123;</span><br><span class="line">                                substrb = value.substr(curIdx, j);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (substrb != value.substr(curIdx, j))</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            curIdx += j;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (curIdx == vLens &amp;&amp; substra != substrb)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0124. 二叉树中的最大路径和</title>
    <url>/posts/3aca13e1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">题目链接</a><br>
给定一个非空二叉树，返回其最大路径和。<br>
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<h3 id="思路一：深度优先遍历">思路一：深度优先遍历</h3>
<p>这道题思路其实比较简单，既然是二叉树，首先就要想到递归。<br>
题目要求树中两个结点之间路径上结点和的最大值，不难看出，对于任意一个结点来说，经过该结点的路径和等于该结点的值加上他左子树的结点和与右子树的结点和，那么递归的方式就呼之欲出了：<br>
递归计算经过每个结点并且以该结点为 root 的路径和，并在递归过程中找到最大值。在递归处理函数中，首先判断当前结点是否为 nullptr，如果不是，则计算当前结点与左右分支最大值的和并且同步更新最大值，这里需要注意的是递归函数的返回值不是左右结点子树的和，而是该结点的值与左右子树中较大路径和的和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        maxSum(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftNodeSum = <span class="built_in">std</span>::<span class="built_in">max</span>(maxSum(node-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightNodeSum = <span class="built_in">std</span>::<span class="built_in">max</span>(maxSum(node-&gt;right), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> curNodeSum = node-&gt;val + leftNodeSum + rightNodeSum;</span><br><span class="line">        res = <span class="built_in">std</span>::<span class="built_in">max</span>(res, curNodeSum);</span><br><span class="line">        <span class="comment">// 只选取和更大的那个分支</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;val + <span class="built_in">std</span>::<span class="built_in">max</span>(leftNodeSum, rightNodeSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res&#123;INT_MIN&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary-Tree</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0010. 正则表达式匹配</title>
    <url>/posts/1d0f76d0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">题目链接</a><br>
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘<em>’ 的正则表达式匹配。<br>
‘.’ 匹配任意单个字符<br>
'</em>’ 匹配零个或多个前面的那一个元素<br>
所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。<br>
说明:<br>
s 可能为空，且只包含从 a-z 的小写字母。<br>
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p>
<p>示例 1:<br>
输入:<br>
s = “aa”<br>
p = “a”<br>
输出: false<br>
解释: “a” 无法匹配 “aa” 整个字符串。</p>
<p>示例 2:<br>
输入:<br>
s = “aa”<br>
p = “a*”<br>
输出: true<br>
解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>
<p>示例 3:<br>
输入:<br>
s = “ab”<br>
p = “.*”<br>
输出: true<br>
解释: “.*” 表示可匹配零个或多个（’*’）任意字符（’.’）。</p>
<p>示例 4:<br>
输入:<br>
s = “aab”<br>
p = “c*a*b”<br>
输出: true<br>
解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>
<p>示例 5:<br>
输入:<br>
s = “mississippi”<br>
p = “mis*is*p*.”<br>
输出: false</p>
<h3 id="思路一：暴力匹配-回溯">思路一：暴力匹配 + 回溯</h3>
<p>暴力匹配采用的是回溯的思想，我们用 si 和 pj 分别表示字符串和匹配串的匹配位置依次比较。<br>
没有匹配成功的时候，process 什么都不做直接返回 false；<br>
否则，我们先检查 regx[pj] 的下一个字符是否是 ‘*’，如果不是，直接进行下面的对比：<br>
如果 regx 中对应的是相同字符或者 ‘.’ 字符，并且 si 和 pj 都没有到达末尾，说明当前字符匹配成功，regx 和 text 都向后移动一个字符；<br>
如果 regx[pj] 下一个字符是 ‘*’，那么有两种匹配情况：<br>
第一种 ‘*’ 匹配 0 个 regx[pj]，此时 pj 直接跳过 regx[pj] 和 ‘*’，整个过程变为 process(str, si, regx, pj + 2)，这种情况需要注意 pj 的范围，因为要检查 pj + 2 的情况是 pj + 1 为 ‘*’，为了保证 pj 不越界，应该取 pj + 1 &lt; regx.size()，此时是最后一个字符为 ‘*’ 的情况；<br>
第二种 ‘*’ 匹配 1 或多个 regx[pj] 的情况，此时需要 regx[pj] 与 str[si] 相同或者为字符 ‘.’，这种情况下 si 向后移动，pj 不变，因为后面还可能继续匹配到相同的 regx[pj]；<br>
此时也需要注意个一个边界条件，即 si 已经匹配到最后一个字符了，pj 后面还有一个 ‘*’ 未匹配，而匹配成功必须要求 text 和 regx 都到达 end() 才行，因此我们让 si &lt;= str.size()，让它能够取到 text 最后的空字符，此时 regx 通过 pj + 2 也能够取得最后的空字符，成功匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="built_in">std</span>::<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">process</span>(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> si, <span class="built_in">std</span>::<span class="built_in">string</span>&amp; regx, <span class="keyword">int</span> pj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pj == regx.<span class="built_in">size</span>() &amp;&amp; si == str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si &lt;= str.<span class="built_in">size</span>() &amp;&amp; pj + <span class="number">1</span> &lt; regx.<span class="built_in">size</span>() &amp;&amp; regx[pj + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="comment">// '*' 匹配 0 个字符</span></span><br><span class="line">            <span class="built_in">process</span>(str, si, regx, pj + <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// '*' 匹配多个字符</span></span><br><span class="line">            <span class="keyword">if</span> (str[si] == regx[pj] || regx[pj] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="built_in">process</span>(str, si + <span class="number">1</span>, regx, pj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si &lt; str.<span class="built_in">size</span>() &amp;&amp; pj &lt; regx.<span class="built_in">size</span>() &amp;&amp; (str[si] == regx[pj] || regx[pj] == <span class="string">'.'</span>)) &#123;</span><br><span class="line">            <span class="built_in">process</span>(str, si + <span class="number">1</span>, regx, pj + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> res&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路二：动态规划">思路二：动态规划</h3>
<p>使用动态规划将每个位置比较的结果都保存下来，dp[i][j] 表示 text 的前 i 个字符与 regx 的前 j 个字符的匹配结果，也就是说 dp[i][j] 表示的是 s[0 ~ i-1] 和 p[0 ~ j-1] 的匹配结果。<br>
首先我们初始化 base case，dp[0][0] 为 true，即两个字符串都为空能够匹配成功；<br>
dp[i][0] 都为 false，因为无法匹配 regx；<br>
dp[0][j] 只有在类似 “a*b*c*” 这种场合为 true，匹配到空字符串，因此当 p[j - 1] 为 ‘*’ 时，dp[0][j] 与 dp[0][j - 2] 匹配状态相同；<br>
接下来我们从 i = 1，j = 1 开始更新 dp 数组：<br>
当 s[i - 1] == p[j - 1] 或者 p[j - 1] == ‘.’，说明 s 的第 i 个字符与 p 的第 j 个字符匹配成功，此时 dp[i][j] 与 dp[i - 1][j - 1] 匹配状态相同；<br>
如果 p[j - 1] == ‘*’，需要考虑三种情况：<br>
匹配 0 个，比如 ab 和 abc*，没有 c* 也能匹配上，此时有 <code>dp[i][j] = dp[i][j - 2]</code>；<br>
匹配 1 个，比如 ab 和 ab*，没有 * 也能匹配上，此时有 <code>dp[i][j] = dp[i][j - 1]</code>；<br>
匹配多个，比如 aabbb 和 aab*，b* 匹配到了三个 b，此时只需要看 aabb 和 aab* 能否匹配上，<code>dp[i][j] = dp[i - 1][j]</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="built_in">std</span>::<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(p.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][j - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p[j - <span class="number">2</span>] != s[i - <span class="number">1</span>] &amp;&amp; p[j - <span class="number">2</span>] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>] || dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][p.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0125. 验证回文串</title>
    <url>/posts/a2269cdc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">题目链接</a><br>
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br>
说明：本题中，我们将空字符串定义为有效的回文串。</p>
<p>示例 1:<br>
输入: “A man, a plan, a canal: Panama”<br>
输出: true</p>
<p>示例 2:<br>
输入: “race a car”<br>
输出: false</p>
<h3 id="思路一：双指针遍历">思路一：双指针遍历</h3>
<p>这道题思路还是很清晰的，使用两个指针分别从头尾开始遍历，当它们相遇的时候如果还没有发现不同的字符，则返回 true。<br>
需要注意的是我们要忽略字母大小写，空格和其他符号，因此遍历过程中要跳过非字母数字的字符，并且要将所有大写字母通过 tolower 函数转换成小写字母再比较，判断是否是字母或数字使用 isalnum。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">isalnum</span>(s[i]) &amp;&amp; i &lt; j) ++i;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">isalnum</span>(s[j]) &amp;&amp; i &lt; j) --j;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[i]) != <span class="built_in">tolower</span>(s[j]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
        <tag>Two-Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1028. 从先序遍历还原二叉树</title>
    <url>/posts/226d7f4f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/" target="_blank" rel="noopener">题目链接</a><br>
我们从二叉树的根节点 root 开始进行深度优先搜索。<br>
在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。<br>
如果节点只有一个子节点，那么保证该子节点为左子节点。<br>
给出遍历输出 S，还原树并返回其根节点 root。</p>
<p>示例 1：<br>
输入：“1-2–3--4-5–6--7”<br>
输出：[1,2,5,3,4,6,7]</p>
<p>示例 2：<br>
输入：“1-2–3—4-5–6—7”<br>
输出：[1,2,5,3,null,6,null,4,null,7]</p>
<p>示例 3：<br>
输入：“1-401–349—90–88”<br>
输出：[1,401,null,349,88,90]</p>
<h3 id="思路一：使用迭代模拟先序遍历">思路一：使用迭代模拟先序遍历</h3>
<p>二叉树的先序遍历过程是这样的：<br>
先访问根结点，然后不断访问左子树，访问的同时将对应的右子树压栈，直到左子树为空时，从栈中弹出右子树进行回溯；<br>
接下来我们开始迭代，每次都从字符串中读出一个结点的深度信息和该结点的值，同时不断向后移动 pos，之后使用该结点值 new 一个 TreeNode；<br>
那么我们怎么判断结点间的位置呢？一个结点如果是它父结点的左子结点，那么它的先序遍历应该紧挨着它的父结点，深度比父结点多 1，并且题目保证了如果结点只有一个子结点，那么该子结点为左子结点。否则，该结点就是它父结点的右子结点；<br>
所以为了回溯，每次访问一个结点之后，我们都会将它入栈，看下一个结点是否是它的当前结点的深度 + 1，如果是的话，就将栈顶结点的 left 指向当前结点，否则就说明当前子树已经恢复完成了，应该将结点不断弹出直到当前栈的深度和当前结点的深度相同，说明找到了先序遍历中最早入栈的那个右结点，将栈顶结点右指针指向它，然后将该结点压入栈。<br>
当输入字符串遍历完毕，二叉树也恢复完毕，将栈至最后一个结点，返回该结点，即为 root。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; path;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; S.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (S[pos] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                ++level;</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; S.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(S[pos])) &#123;</span><br><span class="line">                value = value * <span class="number">10</span> + (S[pos] - <span class="string">'0'</span>);</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">            <span class="keyword">if</span> (level == path.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!path.empty()) &#123;</span><br><span class="line">                    path.top()-&gt;left = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (level != path.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    path.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                path.top()-&gt;right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            path.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (path.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            path.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary-Tree</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1014. 最佳观光组合</title>
    <url>/posts/91fc620f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/" target="_blank" rel="noopener">题目链接</a><br>
给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。<br>
一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。<br>
返回一对观光景点能取得的最高分。</p>
<p>示例：<br>
输入：[8,1,5,2,6]<br>
输出：11<br>
解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11</p>
<h3 id="思路一：枚举">思路一：枚举</h3>
<p>这道题的关键在于如何将 O(n^2) 的时间复杂度通过数学方法变为 O(n) 的时间复杂度。<br>
两个景点的得分其实可以分成两个部分：A[i] + i 和 A[j] - j<br>
这两个部分是相互独立的，唯一的约束是 i &lt; j，那么原问题可以就变成了对于某个 A[j] - j 来说，要找到小于 j 的所有 i 中的 max(A[i] + i)，更新完 res 后向右移动 j 之前，还要将当前 A[j] + j 与前面的 maxi 比较，找出下一次的最大值 maxi。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, maxi = A[<span class="number">0</span>] + <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; A.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, maxi + A[j] - j);</span><br><span class="line">            maxi = <span class="built_in">max</span>(maxi, A[j] + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0297. 二叉树的序列化与反序列化</title>
    <url>/posts/feb973b3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">题目链接</a><br>
序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br>
请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<h3 id="思路一：按层序列化与反序列化">思路一：按层序列化与反序列化</h3>
<p>按层序列化的过程其实就是 BFS 遍历二叉树的过程。<br>
首先将 root 入队，然后出队时依次将它的左右子结点入队，需要注意 nullptr 也要入队（用 ‘#’ 表示），不然在序列化后的字符串中无法区分左右结点。结点与结点之间需要加符号分隔，这里使用的是 ‘!’，最后返回得到的字符串。<br>
反序列化需要按照序列化的方法来进行，也就是说怎么序列化就怎么反序列化。首先我们使用 left 和 right 两个 index 将每个结点按照 ‘!’ 依次分隔出来，循环开始时先要令 right = left，从 left 处开始分隔，这里需要注意的是可能存在负数，因此最后分出来的 val 还需要乘以 sign。<br>
确认结点值后按照顺序将分隔出来的结点值 new 出 TreeNode 放入 vector 中，不难看出 nodeVec[0] 就是 root，后面的顺序正好是按照二叉树层序遍历的顺序排列的，即：<br>
root - rootleft - rootright - rootleftleft -rootleftright…<br>
依次恢复即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.empty()) &#123;</span><br><span class="line">            TreeNode* curNode = nodeQueue.front();</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">            <span class="keyword">if</span> (curNode) &#123;</span><br><span class="line">                res += <span class="built_in">std</span>::to_string(curNode-&gt;val) + <span class="string">'!'</span>;</span><br><span class="line">                nodeQueue.push(curNode-&gt;left);</span><br><span class="line">                nodeQueue.push(curNode-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += <span class="string">"#!"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt; nodeVec;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            right = left;</span><br><span class="line">            <span class="keyword">while</span> (data[right] != <span class="string">'!'</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data[left] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                nodeVec.push_back(<span class="literal">nullptr</span>);</span><br><span class="line">                left = right + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> curVal = <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; data[left] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                sign = <span class="number">-1</span>;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                curVal = curVal * <span class="number">10</span> + data[left] - <span class="string">'0'</span>;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            curVal *= sign;</span><br><span class="line">            nodeVec.emplace_back(<span class="keyword">new</span> TreeNode(curVal));</span><br><span class="line">            left = right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = nodeVec[<span class="number">0</span>];</span><br><span class="line">        TreeNode* curNode = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt; nodeVec.<span class="built_in">size</span>(), j &lt; nodeVec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!curNode) &#123;</span><br><span class="line">                curNode = nodeVec[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode-&gt;left = nodeVec[j];</span><br><span class="line">            curNode-&gt;right = nodeVec[j + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 连接完更新下一次连接的父结点</span></span><br><span class="line">            curNode = nodeVec[i];</span><br><span class="line">            j += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路二：先序序列化与反序列化">思路二：先序序列化与反序列化</h3>
<p>先序序列化的方法和层序序列化的思想是一样的，仍然是如何序列化就如何反序列化。<br>
先序遍历的代码就不多说了，要点和上面一样。<br>
在反序列化的时候，我们每次都解析出一个结点，并且在递归的时候将 idx 索引不断向后移动，因此在递归函数的同一层中，指向左结点和右结点的 idx 是不同的，这里有点类似迭代，因此我们需要将 idx 的引用传入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> res = <span class="built_in">std</span>::to_string(root-&gt;val) + <span class="string">"!"</span>;</span><br><span class="line">        res += serialize(root-&gt;left);</span><br><span class="line">        res += serialize(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(data, idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; data, <span class="keyword">int</span>&amp; idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= data.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (data[idx] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            idx += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curVal = <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (data[idx] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (data[idx] != <span class="string">'!'</span>) &#123;</span><br><span class="line">            curVal = curVal * <span class="number">10</span> + data[idx] - <span class="string">'0'</span>;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        curVal *= sign;</span><br><span class="line">        idx++;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(curVal);</span><br><span class="line">        node-&gt;left = dfs(data, idx);</span><br><span class="line">        node-&gt;right = dfs(data, idx);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary-Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0014. 最长公共前缀</title>
    <url>/posts/dd58770a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">题目链接</a><br>
编写一个函数来查找字符串数组中的最长公共前缀。<br>
如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:<br>
输入: [“flower”,“flow”,“flight”]<br>
输出: “fl”</p>
<p>示例 2:<br>
输入: [“dog”,“racecar”,“car”]<br>
输出: “”<br>
解释: 输入不存在公共前缀。</p>
<p>说明:<br>
所有输入只包含小写字母 a-z。</p>
<h3 id="思路一：竖直扫描">思路一：竖直扫描</h3>
<p>以第 1 个字符串为 base，将第 2 ~ n 个字符串依次从第 1 个字符开始扫描；<br>
如果发现某一个字符串中的某一个字符不等于第 1 个字符串对应的字符，立即返回 strs[0].substr(0, i)<br>
如果遍历结束了都没有找到不相同的字符，则直接返回 strs[0]，此时 strs[0] 为最短或者并列最短的字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[j][i] != strs[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路二：水平扫描">思路二：水平扫描</h3>
<p>以第 1 个字符串为基准，将其作为 prefix，然后依次扫描第 2 ~ n 个字符串查找 prefix；<br>
如果没有找到 prefix 就截短 prefix 继续查找，将 prefix 截掉最后一个字符再重新查找 <code>strs[n].find(prefix.substr(0, prefix.size() - 1))</code>，注意第 2 个字符串必须要循环至找到 prefix 才能继续查找第 3 个字符串；<br>
有一点需要注意，就是 strs.find 方法的返回值，如果查找成功它返回的是找到子串的首字符位置，没有找到返回 std::string::npos (-1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> prefix = strs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; strs.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">            <span class="keyword">while</span> (strs[k].<span class="built_in">find</span>(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">                prefix = prefix.substr(<span class="number">0</span>, prefix.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (prefix == <span class="string">""</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1095. 山脉数组中查找目标值</title>
    <url>/posts/be6ffd0a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">题目链接</a><br>
给你一个山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小的下标 index 值。如果不存在这样的下标 index，就请返回 -1。</p>
<p>何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：<br>
首先，A.length &gt;= 3<br>
其次，在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：<br>
A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]<br>
A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>
你将不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：</p>
<p>MountainArray.get(k) - 会返回数组中索引为 k 的元素（下标从 0 开始）<br>
MountainArray.length() - 会返回该数组的长度<br>
对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案。</p>
<p>示例 1：<br>
输入：array = [1,2,3,4,5,3,1], target = 3<br>
输出：2<br>
解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</p>
<p>示例 2：<br>
输入：array = [0,1,2,4,2,1], target = 3<br>
输出：-1<br>
解释：3 在数组中没有出现，返回 -1。</p>
<p>提示：<br>
3 &lt;= mountain_arr.length() &lt;= 10000<br>
0 &lt;= target &lt;= 10^9<br>
0 &lt;= mountain_arr.get(index) &lt;= 10^9</p>
<h3 id="思路一：二分查找">思路一：二分查找</h3>
<p>因为题目中给出山脉数组的长度为 10000，而给我们的发起访问的次数为 100，不难看出题目希望我们使用二分来解题。<br>
首先通过二分找到山顶元素 peak，当山脉中某个元素 i 小于 i + 1，说明 i 肯定不是 peak，令 left = i + 1 继续查找，那么退出循环时就有 left == right == peak。这种二分查找的写法不会再循环体中判断元素，只是进行边界修改，退出循环时的区间只有一个元素，这时才进行判断。这种二分写法有两种情况：<br>
1、mid = left + (right - left)/2，此时取到下界，边界更新时有 left = mid + 1，right = mid<br>
2、mid = left + (right - left + 1)/2，此时取到上界，边界更新时有 left = mid，right = mid - 1<br>
找到 peak 后，我们现在 0 ~ peak - 1 区间内二分，如果找不到 target 才继续在 peak ~ mountainArr.length() - 1 中查找，这个二分查找的过程和上面类似，需要注意的是 peak ~ mountainArr.length() - 1 这个区间是单调递减的，因此我们将 target 和数组元素的值都取负号，使其变为单调递增，别忘了最后在判断 sign * mountainArr.get(left) == target 的时候要乘以 sign。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MountainArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 闭区间查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = mountainArr.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mountainArr.<span class="built_in">get</span>(mid) &lt; mountainArr.<span class="built_in">get</span>(mid + <span class="number">1</span>)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left == right</span></span><br><span class="line">        <span class="keyword">int</span> peak = left;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="built_in">process</span>(mountainArr, target, <span class="number">0</span>, peak - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (idx != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> idx;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process</span>(mountainArr, target, peak, mountainArr.length() - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(MountainArray &amp;mountainArr, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> sign)</span> </span>&#123;</span><br><span class="line">        target *= sign;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = mountainArr.<span class="built_in">get</span>(mid) * sign;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * mountainArr.<span class="built_in">get</span>(left) == target ? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary-Search</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1300. 转变数组后最接近目标值的数组和</title>
    <url>/posts/f69a90a8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">题目链接</a><br>
给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。<br>
如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。<br>
请注意，答案不一定是 arr 中的数字。</p>
<p>示例 1：<br>
输入：arr = [4,9,3], target = 10<br>
输出：3<br>
解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。</p>
<p>示例 2：<br>
输入：arr = [2,3,5], target = 10<br>
输出：5</p>
<p>示例 3：<br>
输入：arr = [60864,25176,27249,21296,20204], target = 56803<br>
输出：11361</p>
<h3 id="思路一：二分查找">思路一：二分查找</h3>
<p>这道题的题意是选出一个 value，将数组中大于 value 的值全部换成 value，使数组元素和与 target 最接近。<br>
考虑到随着 value 增大，元素和也是一个单调递增的过程，那么查找 value 是可以通过二分来显著降低复杂度的。<br>
因为需要替换大于 value 的元素，首先我们要将数组排序并且计算前缀和，这样可以把计算数组和的时间复杂度降到 O(1)。然后开始二分，上下界分别为 [0, arr.back()]，我们取到中间的 mid 为 value，将大于 value 的元素全部替换并计算和，如果结果小于等于 target，说明应该增大 left，更新 left 并且将 mid 赋给 res，反之就减小 right，当循环退出的时候正好是 left == right 的时候，left 就是我们要找的中间值。<br>
因为判断条件中写的是 curSum &lt;= target，我们找到的 left 满足的是 target 的下界，我们还需要找到 target 的上界 left + 1，判断哪一个更符合要求。<br>
最后，还需要注意这里二分的写法，在判断 while 的时候直接用严格小于，那么退出循环的时候一定有 left == right，不在循环体中判断等于能够显著减小代码的复杂度，唯一需要注意的是计算 mid 的时候需要写成 <code>(right - left)/2</code>，在最后两个数的判断时能够取到下界，防止一直在 left = mid 语句中死循环。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefixSum</span><span class="params">(arr.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            prefixSum[i] = prefixSum[i - <span class="number">1</span>] + arr[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = arr.back();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// lower_bound 返回指向首个不小于 value 的迭代器</span></span><br><span class="line">            <span class="keyword">auto</span> iter = <span class="built_in">std</span>::lower_bound(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), mid);</span><br><span class="line">            <span class="keyword">int</span> curSum = prefixSum[iter - arr.<span class="built_in">begin</span>()] + (arr.<span class="built_in">end</span>() - iter) * mid;</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">abs</span>(getSum(arr, left - <span class="number">1</span>) - target) &lt;= <span class="built_in">std</span>::<span class="built_in">abs</span>(getSum(arr, left) - target) ? left - <span class="number">1</span>: left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; elem : arr) &#123;</span><br><span class="line">            res += elem &gt;= value ? value : elem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary-Search</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0070. 爬楼梯</title>
    <url>/posts/cb014bbd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">题目链接</a><br>
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>
注意：给定 n 是一个正整数。</p>
<p>示例 1：<br>
输入： 2<br>
输出： 2<br>
解释： 有两种方法可以爬到楼顶。<br>
1 阶 + 1 阶<br>
2 阶</p>
<p>示例 2：<br>
输入： 3<br>
输出： 3<br>
解释： 有三种方法可以爬到楼顶。<br>
1 阶 + 1 阶 + 1 阶<br>
1 阶 + 2 阶<br>
2 阶 + 1 阶</p>
<h3 id="思路一：动态规划-斐波那契数列">思路一：动态规划/斐波那契数列</h3>
<p>经典的青蛙跳台阶问题。<br>
对于某一层台阶的跳法 f(n)，可以在 f(n - 1) 跳一层或者在 f(n - 2) 跳两层，那么有 f(n) = f(n - 1) + f(n - 2)，这就是斐波那契数列，分别用 pre 和 next 表示 f(n - 2) 和 f(n - 1)，不断更新即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>, next = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res = pre + next;</span><br><span class="line">            pre = next;</span><br><span class="line">            next = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0015. 三数之和</title>
    <url>/posts/ff4ea7f5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">题目链接</a><br>
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。<br>
注意：答案中不可以包含重复的三元组。</p>
<p>示例：<br>
给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>
满足要求的三元组集合为：<br>
[ [-1, 0, 1], [-1, -1, 2] ]</p>
<h3 id="思路一：双指针">思路一：双指针</h3>
<p>这道题有不少坑， 我们一个一个来说。<br>
首先确定方法，对于 x 数之和，有一种比较通用的解题方法，即双指针遍历，在确定了其他数的值之后，通过双指针夹逼的方式来确定剩下的两个数。<br>
因此这道题需要有两层循环，外层用于遍历确认第一个数，内层用于双指针遍历确认另外两个数。<br>
首先排除特殊情况，即数组元素个数小于 3 的情况；<br>
将数组排序，此时重复的元素均排在一起，开始遍历数组：<br>
从第 2 个数开始，如果某一个数与前一个数相等，此时如果进行内层循环的遍历一定会出现重复解，应该直接 continue 跳过；<br>
如果遍历到某一个 i 发现 nums[i] &gt; 0，因为数组已经是有序的了，不可能再出现 nums[i] 和后面数之和等于 0，直接 break；<br>
令左指针为 i + 1，右指针为 <code>nums.size() - 1</code>，当 <code>nums[i] + nums[leftIdx] + nums[rightIdx] == 0</code> 时将结果 push 进 res 数组中，<br>
接下来是关键的一步，<code>nums[leftIdx]</code> 与 <code>nums[rightIdx]</code> 也可能出现连续重复的元素，也需要比较跳过，<br>
leftIdx 与 rightIdx 应该一直指向重复字符/已计算字符的下一个字符去寻找新的解，所以在跳过相同字符后还需要 ++leftIdx --rightIdx<br>
如果 3Sum 的结果不等于 0 而是大于 0，说明总和大了需要减小 rightIdx，反之需要增加 leftIdx。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsSize = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (numsSize &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数与前一个数相等, 直接 continue ++i, 去除重复元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不会再有 3sum = 0 的情况, 直接 break</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 找到 res 后还需要跳过相同解</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 上面的步骤执行完 leftIdx 与 rightIdx 分别指向相同元素的最后一个字符</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Two-Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0739. 每日温度</title>
    <url>/posts/f0d754cf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">题目链接</a><br>
请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br>
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。<br>
提示：气温列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<h3 id="思路一：单调栈">思路一：单调栈</h3>
<p>这道题要我们求的是一个数组中每个元素右边第一个比它大的元素和它的距离，这正好是单调栈的功能。<br>
对于一个新入栈的元素，如果它比栈顶元素还要小，就直接压入栈中，不修改 res 数组的值；<br>
如果它比栈顶元素要大，则记录栈顶元素与当前将要入栈元素下标的差值，这个入栈元素对于栈顶元素来说，正好是右边第一个比它大的元素，因此记录 <code>res[stack.top()] = i - stack.top()</code>，只要有元素弹出，就说明找到一个对应的 res。<br>
时间复杂度 O(n)，额外空间复杂度 O(n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Tsize = T.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(Tsize, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; monoStack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Tsize; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!monoStack.empty() &amp;&amp; T[i] &gt; T[monoStack.top()]) &#123;</span><br><span class="line">                res[monoStack.top()] = i - monoStack.top();</span><br><span class="line">                monoStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            monoStack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0009. 回文数</title>
    <url>/posts/1441cd76/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">题目链接</a><br>
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p>示例 1:<br>
输入: 121<br>
输出: true</p>
<p>示例 2:<br>
输入: -121<br>
输出: false<br>
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p>
<p>示例 3:<br>
输入: 10<br>
输出: false<br>
解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>
<h3 id="思路一：翻转一半数字">思路一：翻转一半数字</h3>
<p>根据示例不难看出，负数和十的倍数一定不满足题意，这里直接返回 false 即可。<br>
接下来我们从低位向高位翻转数字，当翻转后的数字不小于原数字时跳出循环，这时候有两种可能，第一种，原数位数为奇数，那么 reverseNum 会比 x 多出最后一位，那么如果 reverseNum/10 == x，该数对称；第二种，原数位数为偶数，那么如果 reverseNum == x，原数对称。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> reverseNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (reverseNum &lt; x) &#123;</span><br><span class="line">            reverseNum = reverseNum * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((reverseNum == x) || (reverseNum/<span class="number">10</span> == x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>LCOF 046. 把数字翻译成字符串</title>
    <url>/posts/2c3483d5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">题目链接</a><br>
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 a，1 翻译成 b，25 翻译成 z。<br>
一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>示例 1:<br>
输入: 12258<br>
输出: 5<br>
解释: 12258有 5 种不同的翻译，分别是 “bccfi”, “bwfi”, “bczi”, “mcfi” 和 “mzi”。</p>
<h3 id="思路一：动态规划">思路一：动态规划</h3>
<p>首先将数字转换成字符串便于分析。<br>
定义一个数组 dp，数组中的元素 dp[i] 表示数字的前 i 位一共有多少种翻译方法，字母对应最大的数字为 25，那么一个数字只有两种翻译情况，一种是自己作为一个字母，一种是和另一个数字合起来作为一个字母。<br>
如果第 i 个数字自己翻译一个字母，那么翻译方法和前 i - 1 个数字的翻译方法个数相同，即 dp[i] = dp[i - 1]，如果这个数字还能够和前面的数字组成一个新的字母，那么 dp[i] 还要加上 dp[i - 2]，分析结束，就是这么朴实无华，且枯燥。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="built_in">std</span>::to_string(num);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(str.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; str.<span class="built_in">size</span>() +　<span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 该数字一定能够自己翻译成一个字母</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (str[i - <span class="number">2</span>] != <span class="string">'1'</span> &amp;&amp; str[i - <span class="number">2</span>] != <span class="string">'2'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i - <span class="number">2</span>] == <span class="string">'2'</span> &amp;&amp; str[i - <span class="number">1</span>] &gt; <span class="string">'5'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[str.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg 结构体分析：AVFormatContext</title>
    <url>/posts/a8931316/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在解封装的时候常常会用到 AVFormatContext 结构体，它主要存储的是视音频封装格式中包含的信息；定义位于 avformat.h 文件中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVFormatContext</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于日志和 avoptions 类引用的类, 通过 avformat_alloc_context 赋值, 导出解封装时的私有选项</span></span><br><span class="line">    <span class="keyword">const</span> AVClass *av_class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入容器格式, 解封装时由 avformat_open_input 设置</span></span><br><span class="line">    ff_const59 <span class="class"><span class="keyword">struct</span> <span class="title">AVInputFormat</span> *<span class="title">iformat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出容器格式, 封装时在 avformat_write_header 之前设置</span></span><br><span class="line">    ff_const59 <span class="class"><span class="keyword">struct</span> <span class="title">AVOutputFormat</span> *<span class="title">oformat</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化私有数据, 只有 AVOptions-enabled 并且输入输出容器的 priv_class 非空时使用</span></span><br><span class="line">    <span class="comment">// 解封装时通过 avformat_open_input 设置</span></span><br><span class="line">    <span class="comment">// 封装时通过 avformat_write_header 设置</span></span><br><span class="line">    <span class="keyword">void</span> *priv_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入数据的缓存, 字节流 IO 上下文结构</span></span><br><span class="line">    <span class="comment">// 解封装时需要用户在调用 avformat_open_input 之前或之时设置, 用户必须手动关闭</span></span><br><span class="line">    <span class="comment">// 封装时在用户调用 avformat_write_header 之前设置, 调用方要负责该结构的释放</span></span><br><span class="line">    AVIOContext *pb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号流特性标志, 以 AVFMTCTX_ 开头</span></span><br><span class="line">    <span class="keyword">int</span> ctx_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 音视频流的个数, 通过 avformat_new_stream 设置, 不能被其他代码修改</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_streams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有视音频流列表, 新的流通过 avformat_new_stream 创建</span></span><br><span class="line">    <span class="comment">// 解封装时通过 libavformat 中的 avformat_open_input 创建</span></span><br><span class="line">    <span class="comment">// 封装时在 avformat_write_header 之前创建</span></span><br><span class="line">    AVStream **streams;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_FORMAT_FILENAME</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * input or output filename</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - demuxing: set by avformat_open_input()</span></span><br><span class="line"><span class="comment">     * - muxing: may be set by the caller before avformat_write_header()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @deprecated Use url instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">1024</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入输出 Url, 与上面的 filename 相比没有长度限制</span></span><br><span class="line">    <span class="comment">// 解封装时通过 avformat_open_input 设置, 如果该函数中的 url 参数为 NULL, 该变量为空字串</span></span><br><span class="line">    <span class="comment">// 封装时在 avformat_write_header/avformat_init_output 之前设置, 如果函数中参数为 NULL, 该变量为空字串</span></span><br><span class="line">    <span class="comment">// avformat_free_context 会释放该变量空间</span></span><br><span class="line">    <span class="keyword">char</span> *url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解封装时使用, libavformat 模块设置</span></span><br><span class="line">    <span class="comment">// 第一帧的开始时间, 单位为 AV_TIME_BASE 微秒, 这个值是通过 AVStream 值推导出来的, 无需直接设置</span></span><br><span class="line">    <span class="keyword">int64_t</span> start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解封装时使用, libavformat 模块设置</span></span><br><span class="line">    <span class="comment">// 数据流时长, AV_TIME_BASE 微秒, 没有设置时通过 AVStream 值推导</span></span><br><span class="line">    <span class="keyword">int64_t</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据流比特率 bit/s, 不可用时为 0</span></span><br><span class="line">    <span class="comment">// 如果文件大小和数据流时长已知, FFmpeg 能够自动计算</span></span><br><span class="line">    <span class="keyword">int64_t</span> bit_rate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">int</span> max_delay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解封装标志, 以 AVFMT_FLAG_ 开头</span></span><br><span class="line">    <span class="comment">// 在 avformat_open_input/avformat_write_header 之前设置</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_GENPTS       0x0001 <span class="comment">///&lt; Generate missing pts even if it requires parsing future frames.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_IGNIDX       0x0002 <span class="comment">///&lt; Ignore index.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_NONBLOCK     0x0004 <span class="comment">///&lt; Do not block when reading packets from input.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_IGNDTS       0x0008 <span class="comment">///&lt; Ignore DTS on frames that contain both DTS &amp; PTS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_NOFILLIN     0x0010 <span class="comment">///&lt; Do not infer any values from other values, just return what is stored in the container</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_NOPARSE      0x0020 <span class="comment">///&lt; Do not use AVParsers, you also must set AVFMT_FLAG_NOFILLIN as the fillin code works on frames and no parsing -&gt; no frames. Also seeking to frames can not work if parsing to find frame boundaries has been disabled</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_NOBUFFER     0x0040 <span class="comment">///&lt; Do not buffer frames when possible</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_CUSTOM_IO    0x0080 <span class="comment">///&lt; The caller has supplied a custom AVIOContext, don't avio_close() it.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_DISCARD_CORRUPT  0x0100 <span class="comment">///&lt; Discard frames marked corrupted</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_FLUSH_PACKETS    0x0200 <span class="comment">///&lt; Flush the AVIOContext every packet.</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* When muxing, try to avoid writing any random/volatile data to the output.</span></span><br><span class="line"><span class="comment">* This includes any random IDs, real-time timestamps/dates, muxer version, etc.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This flag is mainly intended for testing.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_BITEXACT         0x0400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_LAVF_MP4A_LATM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_MP4A_LATM    0x8000 <span class="comment">///&lt; Deprecated, does nothing.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_SORT_DTS    0x10000 <span class="comment">///&lt; try to interleave outputted packets by dts (using this flag can slow demuxing down)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_PRIV_OPT    0x20000 <span class="comment">///&lt; Enable use of private options by delaying codec open (this could be made default once all code is converted)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_LAVF_KEEPSIDE_FLAG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_KEEP_SIDE_DATA 0x40000 <span class="comment">///&lt; Deprecated, does nothing.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_FAST_SEEK   0x80000 <span class="comment">///&lt; Enable fast, but inaccurate seeks for some formats</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_SHORTEST   0x100000 <span class="comment">///&lt; Stop muxing when the shortest stream stops.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_FLAG_AUTO_BSF   0x200000 <span class="comment">///&lt; Add bitstream filters as requested by the muxer</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从指定输入容器格式的输入中读取的最大数据大小</span></span><br><span class="line">    <span class="comment">// 解封装时使用, 在 avformat_open_input 之前设置</span></span><br><span class="line">    <span class="keyword">int64_t</span> probesize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 avformat_find_stream_info 的输入中读取数据的最大时长(以 AV_TIME_BASE 为单位)</span></span><br><span class="line">    <span class="comment">// 解封装时使用, 在 avformat_find_stream_info 之前设置</span></span><br><span class="line">    <span class="keyword">int64_t</span> max_analyze_duration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *key;</span><br><span class="line">    <span class="keyword">int</span> keylen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_programs;</span><br><span class="line">    AVProgram **programs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视频 codec_id, 解封装时用户设置</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID video_codec_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 音频 codec_id, 解封装时用户设置</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID audio_codec_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字幕 codec_id, 解封装时用户设置</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID subtitle_codec_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每路流索引使用的内存最大值, 如果索引超过了这个值, 数据项会被丢弃</span></span><br><span class="line">    <span class="comment">// 这会导致 seeking 变慢并且不准确</span></span><br><span class="line">    <span class="comment">// 解封装时由用户设置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_index_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实时捕捉设备中获取的缓冲帧的最大内存占用</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_picture_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AVChapter 数组中章节信息的数量</span></span><br><span class="line">    <span class="comment">// 封装时, 章节信息通常会写在文件头部, 因此 nb_chapters 需要在 write_header 调用前设置</span></span><br><span class="line">    <span class="comment">// mov/mkv 等混流器会将章节信息写在尾部, 此时 nb_chapters 在调用 write_header 时需要为 0</span></span><br><span class="line">    <span class="comment">// 封装时由用户设置, 解封装时由 libavformat 设置</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_chapters;</span><br><span class="line">    AVChapter **chapters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 适用于整个文件的元数据</span></span><br><span class="line">    <span class="comment">// 解封装时在 avformat_open_input 中设置</span></span><br><span class="line">    <span class="comment">// 封装时在 avformat_write_header 调用之前设置</span></span><br><span class="line">    <span class="comment">// 通过 avformat_free_context 释放</span></span><br><span class="line">    AVDictionary *metadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真实世界中流的起始时间, 单位微秒</span></span><br><span class="line">    <span class="comment">// 封装时在 avformat_write_header 之前由调用者设置, 如果为 0 或 AV_NOPTS_VALUE, 使用的是当前 walltime</span></span><br><span class="line">    <span class="comment">// 解封装时由 libavformat 设置, 获取一定数量的帧后该值可能从未知变为已知</span></span><br><span class="line">    <span class="keyword">int64_t</span> start_time_realtime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于决定 avformat_find_stream_info 中帧率的帧数</span></span><br><span class="line">    <span class="comment">// 仅用于解封装, avformat_find_stream_info 调用前由调用者设置</span></span><br><span class="line">    <span class="keyword">int</span> fps_probe_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误识别, 值越高会检测到越多的错误, 但误检率也会提高</span></span><br><span class="line">    <span class="comment">// 仅用于解封装, avformat_open_input 调用前由用户设置</span></span><br><span class="line">    <span class="keyword">int</span> error_recognition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO 层自定义中断回调函数</span></span><br><span class="line">    <span class="comment">// 解封装时在 avformat_open_input 之前由用户设置</span></span><br><span class="line">    <span class="comment">// 封装时在 avformat_write_header 之前由用户设置</span></span><br><span class="line">    <span class="comment">// 如果该回调函数用于打开文件, 它也会传递给 avio_open2</span></span><br><span class="line">    AVIOInterruptCB interrupt_callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用 debug 标志</span></span><br><span class="line">    <span class="keyword">int</span> debug;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FF_FDEBUG_TS        0x0001</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅封装时使用, 在 avformat_write_header 调用前设置</span></span><br><span class="line">    <span class="comment">// 交织的最大缓冲持续时间</span></span><br><span class="line">    <span class="comment">// 为了确保所有流都正确交织, av_interleaved_write_frame 将等待至每个流至少有一个 packet 时才将 packet 写入输出文件</span></span><br><span class="line">    <span class="comment">// 当某些连续的 packet 之间有较大间隔时, 会导致过多的缓冲</span></span><br><span class="line">    <span class="comment">// 该资源指定混流队列中第一个和最后一个 packet 之间时间戳的最大间隔</span></span><br><span class="line">    <span class="keyword">int64_t</span> max_interleave_delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许非标准和实验性扩展</span></span><br><span class="line">    <span class="keyword">int</span> strict_std_compliance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于检测文件上发生事件的标志, 事件处理后用户需要清除该标志</span></span><br><span class="line">    <span class="keyword">int</span> event_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_EVENT_FLAG_METADATA_UPDATED 0x0001 <span class="comment">///&lt; The call resulted in updated metadata.</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅用于解码, 在等待第一个时间戳时要读取的最大 packet 数量</span></span><br><span class="line">    <span class="keyword">int</span> max_ts_probe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装时由用户设置, 避免封装时的负时间戳</span></span><br><span class="line">    <span class="comment">// 只有使用 av_interleaved_write_frame 时生效</span></span><br><span class="line">    <span class="keyword">int</span> avoid_negative_ts;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_AVOID_NEG_TS_AUTO             -1 <span class="comment">///&lt; Enabled when required by target format</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE 1 <span class="comment">///&lt; Shift timestamps so they are non negative</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVFMT_AVOID_NEG_TS_MAKE_ZERO         2 <span class="comment">///&lt; Shift timestamps so that they start at 0</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传输流 ID, 该变量会被移入分流器的私有选项中</span></span><br><span class="line">    <span class="keyword">int</span> ts_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码时用户设置, 音频预加载, 单位微秒, 并非所有格式都支持该功能</span></span><br><span class="line">    <span class="keyword">int</span> audio_preload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码时用户设置, 最大块时间(单位微秒), 并非所有格式都支持该功能</span></span><br><span class="line">    <span class="keyword">int</span> max_chunk_duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码时用户设置, 最大块大小, 并非所有格式都支持该功能</span></span><br><span class="line">    <span class="keyword">int</span> max_chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码时用户设置, 强制使用 wallclock 时间戳作为 packet 的 pts/dts</span></span><br><span class="line">    <span class="keyword">int</span> use_wallclock_as_timestamps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码时用户设置, avio 标志</span></span><br><span class="line">    <span class="keyword">int</span> avio_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码时用户读取, 用于获得数据流时长的估计方式</span></span><br><span class="line">    <span class="keyword">enum</span> AVDurationEstimationMethod duration_estimation_method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码时用户设置, 打开流时跳过初始字节</span></span><br><span class="line">    <span class="keyword">int64_t</span> skip_initial_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码时用户设置, 单个时间戳溢出</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> correct_ts_overflow;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码时用户设置, 强制查找到任意帧</span></span><br><span class="line">    <span class="keyword">int</span> seek2any;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码时用户调用, 每个 packet 之后刷新 IO 上下文</span></span><br><span class="line">    <span class="keyword">int</span> flush_packets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式探测分数, 最大值为 AVPROBE_SCORE_MAX, 解码时由 avformat 设置, 用户读取</span></span><br><span class="line">    <span class="keyword">int</span> probe_score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码时用户设置, 识别格式时最大限度读取的字节数</span></span><br><span class="line">    <span class="keyword">int</span> format_probesize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码时用户设置, 允许的解码器, 通过 ',' 分割, NULL 表示允许所有解码器</span></span><br><span class="line">    <span class="keyword">char</span> *codec_whitelist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解封装时用户设置, 允许的分流器, 通过 ',' 分割, NULL 表示允许所有分流器</span></span><br><span class="line">    <span class="keyword">char</span> *format_whitelist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// libavformat 内部数据, 禁止访问</span></span><br><span class="line">    AVFormatInternal *internal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO 重定位标志</span></span><br><span class="line">    <span class="comment">// 当 IO 上下文读取指针重定位了(基于字节的查找), 分流器能够通过该标志检测这种变化</span></span><br><span class="line">    <span class="keyword">int</span> io_repositioned;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解封装时用户设置, 强制使用指定的视频解码器, 解释有多个相同的 codec_id</span></span><br><span class="line">    AVCodec *video_codec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解封装时用户设置, 强制使用指定的音频解码器, 解释有多个相同的 codec_id</span></span><br><span class="line">    AVCodec *audio_codec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解封装时用户设置, 强制使用指定的解码器, 解释有多个相同的 codec_id</span></span><br><span class="line">    AVCodec *subtitle_codec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解封装时用户设置, 强制使用指定的解码器, 解释有多个相同的 codec_id</span></span><br><span class="line">    AVCodec *data_codec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元数据头部中填充的字节数</span></span><br><span class="line">    <span class="comment">// 封装时用户通过 av_format_set_metadata_header_padding 设置</span></span><br><span class="line">    <span class="keyword">int</span> metadata_header_padding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户私有数据空间</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设备使用的回调函数, 用于与应用通讯</span></span><br><span class="line">    av_format_control_message control_message_cb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出时间戳偏移量, 单位微秒, 封装时用户设置</span></span><br><span class="line">    <span class="keyword">int64_t</span> output_ts_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转储格式分隔符, ',' 或 '\n'</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *dump_separator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制数据 codec_id, 解封装时用户设置</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID data_codec_id;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_OLD_OPEN_CALLBACKS</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called to open further IO contexts when needed for demuxing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This can be set by the user application to perform security checks on</span></span><br><span class="line"><span class="comment">     * the URLs before opening them.</span></span><br><span class="line"><span class="comment">     * The function should behave like avio_open2(), AVFormatContext is provided</span></span><br><span class="line"><span class="comment">     * as contextual information and to reach AVFormatContext.opaque.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If NULL then some simple checks are used together with avio_open2().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Must not be accessed directly from outside avformat.</span></span><br><span class="line"><span class="comment">     * @See av_format_set_open_cb()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Demuxing: Set by user.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @deprecated Use io_open and io_close.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">int</span> (*open_cb)(struct AVFormatContext *s, AVIOContext **p, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags, <span class="keyword">const</span> AVIOInterruptCB *int_cb, AVDictionary **options);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持协议的列表, 通过 ',' 分割, 解码时用户设置</span></span><br><span class="line">    <span class="keyword">char</span> *protocol_whitelist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开新的 IO 流的回调函数</span></span><br><span class="line">    <span class="comment">// 当混流器/分流器需要打开一个 IO 流时(典型应用是通过调用 avformat_open_input 打开数据流用于分流)</span></span><br><span class="line">    <span class="comment">// 就会调用该函数以获取一个 IO 上下文, 这个新打开的 IO 上下文会保存在 pb 中</span></span><br><span class="line">    <span class="keyword">int</span> (*io_open)(struct AVFormatContext *s, AVIOContext **pb, <span class="keyword">const</span> <span class="keyword">char</span> *url,</span><br><span class="line">                   <span class="keyword">int</span> flags, AVDictionary **options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于关闭 AVFormatContext.io_open 打开的流的回调函数</span></span><br><span class="line">    <span class="keyword">void</span> (*io_close)(struct AVFormatContext *s, AVIOContext *pb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持协议的列表, 通过 ',' 分割, 解码时用户设置</span></span><br><span class="line">    <span class="keyword">char</span> *protocol_blacklist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据流的最大数量, 解码时用户设置</span></span><br><span class="line">    <span class="keyword">int</span> max_streams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码时由用户设置, 根据显示时间戳 pts 估计出的跳跃时长</span></span><br><span class="line">    <span class="keyword">int</span> skip_estimate_duration_from_pts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 能够探测到的最大 packet 的数量, 解封装时用户设置</span></span><br><span class="line">    <span class="keyword">int</span> max_probe_packets;</span><br><span class="line">&#125; AVFormatContext;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Audio/Video</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg 结构体分析：AVStream</title>
    <url>/posts/e1e5fd1d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>AVStream 是存储每一个音视频流信息的结构体，定义位于 avformat.h 文件中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVStream</span> &#123;</span></span><br><span class="line">    <span class="comment">// AVFormatContext 结构体中流的索引号, 用于唯一标识该数据流</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定格式流 ID</span></span><br><span class="line">    <span class="comment">// 解码时由 libavformat 指定</span></span><br><span class="line">    <span class="comment">// 编码时用户指定</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_LAVF_AVCTX</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @deprecated use the codecpar struct instead</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    AVCodecContext *codec;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">void</span> *priv_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间基, PTS 和 DTS 需要通过该值才能转换为真正的时间(PTS * time_base)</span></span><br><span class="line">    <span class="comment">// 解码时由 libavformat 设置</span></span><br><span class="line">    <span class="comment">// 编码时调用者需要在 avformat_write_header 之前设置, 用于向混流器提供所需的时间基</span></span><br><span class="line">    <span class="comment">// 在 avformat_write_header 中, 混流器会使用实际写入文件的时间戳来覆盖该字段</span></span><br><span class="line">    AVRational time_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码时的展示序列流第一帧的 pts</span></span><br><span class="line">    <span class="keyword">int64_t</span> start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码时表示流的持续时间, 如果指定了比特率却没有指定该值, 可以通过比特率和文件大小推算出来</span></span><br><span class="line">    <span class="comment">// 编码时由调用者在 avformat_write_header 之前设置</span></span><br><span class="line">    <span class="keyword">int64_t</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该流中的帧数</span></span><br><span class="line">    <span class="keyword">int64_t</span> nb_frames;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> disposition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择哪些 packet 可以被丢弃, 不需要被分流</span></span><br><span class="line">    <span class="keyword">enum</span> AVDiscard discard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采样率, 编码时用户设置, 解码时 libavformat 设置</span></span><br><span class="line">    AVRational sample_aspect_ratio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元数据</span></span><br><span class="line">    AVDictionary *metadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平均帧率</span></span><br><span class="line">    <span class="comment">// 分流时由 libavformat 在创建新流或在 avformat_find_stream_info 中设置</span></span><br><span class="line">    <span class="comment">// 混流时由调用者在 avformat_write_header 之前设置</span></span><br><span class="line">    AVRational avg_frame_rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 附带的图片, 流需要有 AV_DISPOSITION_ATTACHED_PIC 标志</span></span><br><span class="line">    <span class="comment">// 解码时使用, libavformat 设置</span></span><br><span class="line">    AVPacket attached_pic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An array of side data that applies to the whole stream (i.e. the</span></span><br><span class="line"><span class="comment">     * container does not allow it to change between packets).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * There may be no overlap between the side data in this array and side data</span></span><br><span class="line"><span class="comment">     * in the packets. I.e. a given side data is either exported by the muxer</span></span><br><span class="line"><span class="comment">     * (demuxing) / set by the caller (muxing) in this array, then it never</span></span><br><span class="line"><span class="comment">     * appears in the packets, or the side data is exported / sent through</span></span><br><span class="line"><span class="comment">     * the packets (always in the first packet where the value becomes known or</span></span><br><span class="line"><span class="comment">     * changes), then it does not appear in this array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - demuxing: Set by libavformat when the stream is created.</span></span><br><span class="line"><span class="comment">     * - muxing: May be set by the caller before avformat_write_header().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Freed by libavformat in avformat_free_context().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @see av_format_inject_global_side_data()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVPacketSideData *side_data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of elements in the AVStream.side_data array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>            nb_side_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flags for the user to detect events happening on the stream. Flags must</span></span><br><span class="line"><span class="comment">     * be cleared by the user once the event has been handled.</span></span><br><span class="line"><span class="comment">     * A combination of AVSTREAM_EVENT_FLAG_*.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> event_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVSTREAM_EVENT_FLAG_METADATA_UPDATED 0x0001 <span class="comment">///&lt; The call resulted in updated metadata.</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Real base framerate of the stream.</span></span><br><span class="line"><span class="comment">     * This is the lowest framerate with which all timestamps can be</span></span><br><span class="line"><span class="comment">     * represented accurately (it is the least common multiple of all</span></span><br><span class="line"><span class="comment">     * framerates in the stream). Note, this value is just a guess!</span></span><br><span class="line"><span class="comment">     * For example, if the time base is 1/90000 and all frames have either</span></span><br><span class="line"><span class="comment">     * approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVRational r_frame_rate;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FF_API_LAVF_FFSERVER</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String containing pairs of key and values describing recommended encoder configuration.</span></span><br><span class="line"><span class="comment">     * Pairs are separated by ','.</span></span><br><span class="line"><span class="comment">     * Keys are separated from values by '='.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @deprecated unused</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    attribute_deprecated</span><br><span class="line">    <span class="keyword">char</span> *recommended_encoder_configuration;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Codec parameters associated with this stream. Allocated and freed by</span></span><br><span class="line"><span class="comment">     * libavformat in avformat_new_stream() and avformat_free_context()</span></span><br><span class="line"><span class="comment">     * respectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - demuxing: filled by libavformat on stream creation or in</span></span><br><span class="line"><span class="comment">     *             avformat_find_stream_info()</span></span><br><span class="line"><span class="comment">     * - muxing: filled by the caller before avformat_write_header()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVCodecParameters *codecpar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*****************************************************************</span></span><br><span class="line"><span class="comment">     * All fields below this line are not part of the public API. They</span></span><br><span class="line"><span class="comment">     * may not be used outside of libavformat and can be changed and</span></span><br><span class="line"><span class="comment">     * removed at will.</span></span><br><span class="line"><span class="comment">     * Internal note: be aware that physically removing these fields</span></span><br><span class="line"><span class="comment">     * will break ABI. Replace removed fields with dummy fields, and</span></span><br><span class="line"><span class="comment">     * add new fields to AVStreamInternal.</span></span><br><span class="line"><span class="comment">     *****************************************************************</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_STD_TIMEBASES (30*12+30+3+6)</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stream information used internally by avformat_find_stream_info()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int64_t</span> last_dts;</span><br><span class="line">        <span class="keyword">int64_t</span> duration_gcd;</span><br><span class="line">        <span class="keyword">int</span> duration_count;</span><br><span class="line">        <span class="keyword">int64_t</span> rfps_duration_sum;</span><br><span class="line">        <span class="keyword">double</span> (*duration_error)[<span class="number">2</span>][MAX_STD_TIMEBASES];</span><br><span class="line">        <span class="keyword">int64_t</span> codec_info_duration;</span><br><span class="line">        <span class="keyword">int64_t</span> codec_info_duration_fields;</span><br><span class="line">        <span class="keyword">int</span> frame_delay_evidence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 0  -&gt; decoder has not been searched for yet.</span></span><br><span class="line"><span class="comment">         * &gt;0 -&gt; decoder found</span></span><br><span class="line"><span class="comment">         * &lt;0 -&gt; decoder with codec_id == -found_decoder has not been found</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> found_decoder;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> last_duration;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Those are used for average framerate estimation.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int64_t</span> fps_first_dts;</span><br><span class="line">        <span class="keyword">int</span>     fps_first_dts_idx;</span><br><span class="line">        <span class="keyword">int64_t</span> fps_last_dts;</span><br><span class="line">        <span class="keyword">int</span>     fps_last_dts_idx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; *info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pts_wrap_bits; <span class="comment">/**&lt; number of bits in pts (used for wrapping control) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Timestamp generation support:</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Timestamp corresponding to the last dts sync point.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Initialized when AVCodecParserContext.dts_sync_point &gt;= 0 and</span></span><br><span class="line"><span class="comment">     * a DTS is received from the underlying container. Otherwise set to</span></span><br><span class="line"><span class="comment">     * AV_NOPTS_VALUE by default.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> first_dts;</span><br><span class="line">    <span class="keyword">int64_t</span> cur_dts;</span><br><span class="line">    <span class="keyword">int64_t</span> last_IP_pts;</span><br><span class="line">    <span class="keyword">int</span> last_IP_duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of packets to buffer for codec probing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> probe_packets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of frames that have been demuxed during avformat_find_stream_info()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> codec_info_nb_frames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* av_read_frame() support */</span></span><br><span class="line">    <span class="keyword">enum</span> AVStreamParseType need_parsing;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVCodecParserContext</span> *<span class="title">parser</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * last packet in packet_buffer for this stream when muxing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVPacketList</span> *<span class="title">last_in_packet_buffer</span>;</span></span><br><span class="line">    AVProbeData probe_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_REORDER_DELAY 16</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts_buffer[MAX_REORDER_DELAY+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    AVIndexEntry *index_entries; <span class="comment">/**&lt; Only used if the format does not</span></span><br><span class="line"><span class="comment">                                    support seeking natively. */</span></span><br><span class="line">    <span class="keyword">int</span> nb_index_entries;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index_entries_allocated_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stream Identifier</span></span><br><span class="line"><span class="comment">     * This is the MPEG-TS stream identifier +1</span></span><br><span class="line"><span class="comment">     * 0 means unknown</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> stream_identifier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Details of the MPEG-TS program which created this stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> program_num;</span><br><span class="line">    <span class="keyword">int</span> pmt_version;</span><br><span class="line">    <span class="keyword">int</span> pmt_stream_idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> interleaver_chunk_size;</span><br><span class="line">    <span class="keyword">int64_t</span> interleaver_chunk_duration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * stream probing state</span></span><br><span class="line"><span class="comment">     * -1   -&gt; probing finished</span></span><br><span class="line"><span class="comment">     *  0   -&gt; no probing requested</span></span><br><span class="line"><span class="comment">     * rest -&gt; perform probing with request_probe being the minimum score to accept.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> request_probe;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates that everything up to the next keyframe</span></span><br><span class="line"><span class="comment">     * should be discarded.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> skip_to_keyframe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of samples to skip at the start of the frame decoded from the next packet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> skip_samples;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If not 0, the number of samples that should be skipped from the start of</span></span><br><span class="line"><span class="comment">     * the stream (the samples are removed from packets with pts==0, which also</span></span><br><span class="line"><span class="comment">     * assumes negative timestamps do not happen).</span></span><br><span class="line"><span class="comment">     * Intended for use with formats such as mp3 with ad-hoc gapless audio</span></span><br><span class="line"><span class="comment">     * support.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> start_skip_samples;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If not 0, the first audio sample that should be discarded from the stream.</span></span><br><span class="line"><span class="comment">     * This is broken by design (needs global sample count), but can't be</span></span><br><span class="line"><span class="comment">     * avoided for broken by design formats such as mp3 with ad-hoc gapless</span></span><br><span class="line"><span class="comment">     * audio support.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> first_discard_sample;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The sample after last sample that is intended to be discarded after</span></span><br><span class="line"><span class="comment">     * first_discard_sample. Works on frame boundaries only. Used to prevent</span></span><br><span class="line"><span class="comment">     * early EOF if the gapless info is broken (considered concatenated mp3s).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> last_discard_sample;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Number of internally decoded frames, used internally in libavformat, do not access</span></span><br><span class="line"><span class="comment">     * its lifetime differs from info which is why it is not in that structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> nb_decoded_frames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Timestamp offset added to timestamps before muxing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> mux_ts_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal data to check for wrapping of the time stamp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts_wrap_reference;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Options for behavior, when a wrap is detected.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Defined by AV_PTS_WRAP_ values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If correction is enabled, there are two possibilities:</span></span><br><span class="line"><span class="comment">     * If the first time stamp is near the wrap point, the wrap offset</span></span><br><span class="line"><span class="comment">     * will be subtracted, which will create negative time stamps.</span></span><br><span class="line"><span class="comment">     * Otherwise the offset will be added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> pts_wrap_behavior;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal data to prevent doing update_initial_durations() twice</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> update_initial_durations_done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal data to generate dts from pts</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> pts_reorder_error[MAX_REORDER_DELAY+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> pts_reorder_error_count[MAX_REORDER_DELAY+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal data to analyze DTS and detect faulty mpeg streams</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int64_t</span> last_dts_for_order_check;</span><br><span class="line">    <span class="keyword">uint8_t</span> dts_ordered;</span><br><span class="line">    <span class="keyword">uint8_t</span> dts_misordered;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal data to inject global side data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> inject_global_side_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * display aspect ratio (0 if unknown)</span></span><br><span class="line"><span class="comment">     * - encoding: unused</span></span><br><span class="line"><span class="comment">     * - decoding: Set by libavformat to calculate sample_aspect_ratio internally</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVRational display_aspect_ratio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An opaque field for libavformat internal usage.</span></span><br><span class="line"><span class="comment">     * Must not be accessed in any way by callers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AVStreamInternal *internal;</span><br><span class="line">&#125; AVStream;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Audio/Video</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0990. 等式方程的可满足性</title>
    <url>/posts/bd1b2c1f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">题目链接</a><br>
给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：“a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。<br>
只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</p>
<p>示例 1：<br>
输入：[“a==b”,“b!=a”]<br>
输出：false<br>
解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</p>
<p>示例 2：<br>
输出：[“b==a”,“a==b”]<br>
输入：true<br>
解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。</p>
<p>示例 3：<br>
输入：[“a==b”,“b==c”,“a==c”]<br>
输出：true</p>
<p>示例 4：<br>
输入：[“a==b”,“b!=c”,“c==a”]<br>
输出：false</p>
<p>示例 5：<br>
输入：[“c==c”,“b==d”,“x!=z”]<br>
输出：true</p>
<p>提示：<br>
1 &lt;= equations.length &lt;= 500<br>
equations[i].length == 4<br>
equations[i][0] 和 equations[i][3] 是小写字母<br>
equations[i][1] 要么是 ‘=’，要么是 ‘!’<br>
equations[i][2] 是 ‘=’</p>
<h3 id="思路一：并查集">思路一：并查集</h3>
<p>我们可以将每一个变量看作是一个结点，那么对于小写字母，一共有二十六个结点，接下来我们需要找这些结点之间关系的悖论。<br>
首先，我们检查每个等式的 idx[1]，找出所有该字符为 ‘=’ 的等式，这些等式可以划分出若干个值不同的集合，每个集合中都是相等的变量；<br>
接着处理不等式，如果不等式两端的变量出现在了前面相等的集合中，等式肯定不成立，返回 false。<br>
处理这些相等的变量我们需要引入并查集，一个集合中的元素属性相同，都有同样的父结点，开始的时候所有的变量各自为一个独立的集合，我们用 root[idx] 来表示对应 idx 的父结点是什么，也就是说 idx 属于哪个集合，那么初始化 root[idx] = idx，这里我们用算法库中的 iota 逐个初始化。<br>
并的过程其实就是修改某个结点的 root[idx]，将某个结点所属的一整个集合并到另一个结点所属的集合中；<br>
查的过程其实是递归查找当前结点所属集合的 root 结点，如果 idx == root[idx]，直接返回 idx，否则就说明还没有到达根节点，因此需要递归调用 findRoot，并且将 findRoot 的返回值赋给 root[idx]，也就是说 root[idx] 的父结点也就是 idx 的父结点，以此来压缩路径，最后返回 idx 的父结点 root[idx]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFindSet() &#123;</span><br><span class="line">        root.resize(<span class="number">26</span>);</span><br><span class="line">        <span class="built_in">std</span>::iota(root.<span class="built_in">begin</span>(), root.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span> <span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == root[idx]) &#123;</span><br><span class="line">            <span class="keyword">return</span> idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 压缩路径</span></span><br><span class="line">        root[idx] = findRoot(root[idx]);</span><br><span class="line">        <span class="keyword">return</span> root[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 idx1 所属的整个集合挂到 idx2 下面, 就是将 idx1 的 root 结点挂在 idx2 的 root 结点下</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unitSet</span> <span class="params">(<span class="keyword">int</span> idx1, <span class="keyword">int</span> idx2)</span> </span>&#123;</span><br><span class="line">        root[findRoot(idx1)] = findRoot(idx2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        UnionFindSet ufs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">'='</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx1 = str[<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> idx2 = str[<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line">                ufs.unitSet(idx1, idx2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">1</span>] == <span class="string">'!'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx1 = str[<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> idx2 = str[<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (ufs.findRoot(idx1) == ufs.findRoot(idx2)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Union-Find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0127. 单词接龙</title>
    <url>/posts/50059886/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">题目链接</a><br>
给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：<br>
每次转换只能改变一个字母。<br>
转换过程中的中间单词必须是字典中的单词。</p>
<p>说明:<br>
如果不存在这样的转换序列，返回 0。<br>
所有单词具有相同的长度。<br>
所有单词只由小写字母组成。<br>
字典中不存在重复的单词。<br>
你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</p>
<p>示例 1:<br>
输入:<br>
beginWord = “hit”,<br>
endWord = “cog”,<br>
wordList = [“hot”,“dot”,“dog”,“lot”,“log”,“cog”]<br>
输出: 5<br>
解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”, 返回它的长度 5。</p>
<p>示例 2:<br>
输入:<br>
beginWord = “hit”<br>
endWord = “cog”<br>
wordList = [“hot”,“dot”,“dog”,“lot”,“log”]<br>
输出: 0<br>
解释: endWord “cog” 不在字典中，所以无法进行转换。</p>
<h3 id="思路一：双向-BFS">思路一：双向 BFS</h3>
<p>不难看出，这是一道最短路径的题目，首先要想到 BFS。<br>
在二叉树的 BFS 中常用的是队列，因为每个结点只可能访问一次，而在图中每个结点可能访问多次，为了消除影响，我们采用这样的策略：<br>
将 beginWord 加入 beginSet 中，然后从 wordSet 中删除 beginSet 中的单词，因为后面即使还能够得到这些单词，步数也肯定大于当前的步数。<br>
beginSet 中的每个单词都是 wordList 中我们能够通过修改一个字母依次得到的，我们beginSet 集合中每个单词的每个字母都用字母 a ~ z 遍历一遍，遍历的同时在 wordSet 中查找，如果没有找到就 continue 继续循环，如果找到了我们再看 endSet 能否找到，如果能找到直接返回结果，否则我们将这个修改过的 str 插入一个 tempSet，这个 tempSet 表示的是 beginSet 中的单词修改一个字母就能够到达的 wordSet 中某个单词的集合。<br>
下面是最重要的优化部分，当我们获取到 beginSet 修改一个字母能够到达的 tempSet 集合后，将 tempSet 大小与另一边的 endSet 进行比较，然后选取小的那一边继续遍历，这样相当于剪枝了，每次可以少遍历很多不必要的状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> beginWord, <span class="built_in">std</span>::<span class="built_in">string</span> endWord, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordList.<span class="built_in">begin</span>(), wordList.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(endWord) == wordSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; beginSet&#123;beginWord&#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; endSet&#123;endWord&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!beginSet.empty()) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tempSet;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="keyword">word</span> : beginSet) &#123;</span><br><span class="line">                wordSet.erase(<span class="keyword">word</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> item : beginSet) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; item.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">string</span> str = item;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; ++c) &#123;</span><br><span class="line">                        str[i] = c;</span><br><span class="line">                        <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(str) == wordSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (endSet.<span class="built_in">find</span>(str) != endSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> res;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tempSet.insert(str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tempSet.<span class="built_in">size</span>() &lt; endSet.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                beginSet = tempSet;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                beginSet = endSet;</span><br><span class="line">                endSet = tempSet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0126. 单词接龙 II</title>
    <url>/posts/2aafb794/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">题目链接</a><br>
给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：<br>
每次转换只能改变一个字母。<br>
转换后得到的单词必须是字典中的单词。</p>
<p>说明:<br>
如果不存在这样的转换序列，返回一个空列表。<br>
所有单词具有相同的长度。<br>
所有单词只由小写字母组成。<br>
字典中不存在重复的单词。<br>
你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</p>
<p>示例 1:<br>
输入:<br>
beginWord = “hit”,<br>
endWord = “cog”,<br>
wordList = [“hot”,“dot”,“dog”,“lot”,“log”,“cog”]<br>
输出:<br>
[<br>
[“hit”,“hot”,“dot”,“dog”,“cog”],<br>
  [“hit”,“hot”,“lot”,“log”,“cog”]<br>
]</p>
<p>示例 2:<br>
输入:<br>
beginWord = “hit”<br>
endWord = “cog”<br>
wordList = [“hot”,“dot”,“dog”,“lot”,“log”]<br>
输出: []<br>
解释: endWord “cog” 不在字典中，所以不存在符合要求的转换序列。</p>
<h3 id="思路一：广度优先遍历-深度优先遍历">思路一：广度优先遍历 + 深度优先遍历</h3>
<p>这道题和单词接龙 1 的区别就是需要打印出所有满足条件的单词序列，那么我们需要用一个哈希表来保存 wordList 中每个单词只修改一个字符后能够变成的单词，这些单词与原单词的路径都为 1。<br>
beginSet 中保存的是当前走 n 步后能够到达的单词集合，首先从 wordSet 中剔除 beginSet 中的结点，表示在此之后不会再访问这些结点了，然后对 beginSet 中的每一个单词，我们都将其中的每一个字符分别替换为 a ~ z 的每一个字符，并且在 wordSet 中查找经过修改的 word，一旦能找到就将该 word 加入 tempSet 并且加入 wordTrace 中对应 elem 的集合中。一轮循环后，将 tempSet 赋给 beginSet 用于下一轮遍历。<br>
一旦在上面的循环中遇到了 endWord，说明 BFS 应该停止了，考虑到可能有多条路径到 endWord，这里不能直接 break，而是需要等这一轮遍历完成才行，因此只置起 endFlag 标志，下一轮循环就不会进入了。<br>
如果 beginSet 中没有元素了，说明所有元素都遍历完成了，此时如果 endFlag 仍然为 false，说明无法到达 endWord，返回空；<br>
否则直接 DFS 输出结果，结点之间的关系都保存在 wordTrace 中了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> traceMap = <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">findLadders</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> beginWord, <span class="built_in">std</span>::<span class="built_in">string</span> endWord, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordList.<span class="built_in">begin</span>(), wordList.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(endWord) == wordSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; beginSet&#123;beginWord&#125;;</span><br><span class="line">        traceMap wordTrace;</span><br><span class="line">        <span class="keyword">while</span> (!beginSet.empty() &amp;&amp; !endFlag) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tempSet;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; <span class="keyword">word</span> : beginSet) &#123;</span><br><span class="line">                wordSet.erase(<span class="keyword">word</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : beginSet) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; item.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">string</span> str = item;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; ++c) &#123;</span><br><span class="line">                        str[i] = c;</span><br><span class="line">                        <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(str) == wordSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (str == endWord) &#123;</span><br><span class="line">                            endFlag = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tempSet.insert(str);</span><br><span class="line">                        wordTrace[item].insert(str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            beginSet = tempSet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!endFlag) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        dfs(wordTrace, beginWord, endWord, res, &#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(traceMap&amp; wordTrace, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; curWord, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; endWord,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;&amp; res, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; singleTrace)</span> </span>&#123;</span><br><span class="line">        singleTrace.push_back(curWord);</span><br><span class="line">        <span class="keyword">if</span> (curWord == endWord) &#123;</span><br><span class="line">            res.push_back(singleTrace);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; <span class="keyword">word</span> : wordTrace[curWord]) &#123;</span><br><span class="line">            dfs(wordTrace, <span class="keyword">word</span>, endWord, res, singleTrace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> endFlag&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0128. 最长连续序列</title>
    <url>/posts/190e4ad0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">题目链接</a><br>
给定一个未排序的整数数组，找出最长连续序列的长度。<br>
要求算法的时间复杂度为 O(n)。</p>
<p>示例:<br>
输入: [100, 4, 200, 1, 3, 2]<br>
输出: 4<br>
解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p>
<h3 id="思路一：哈希集合">思路一：哈希集合</h3>
<p>暴力解法的缺陷在于一个被统计过的序列可能还会被统计多次。<br>
首先我们<strong>将 nums 数组中的所有数去重</strong>放入哈希集合中，然后有一个很简单的方法来判断某一个数是否在某个队列中被统计过了：<br>
对于集合中的一个元素 elem 来说，如果 elem - 1 也在集合中，那么 elem 已经被统计过了，直接判断下一个元素；<br>
如果 elem - 1 不在 numSet 中，这个 elem 就是某个序列的起始点，依次增加 elem 并在 numSet 中查找，直到找不到，计算当前的长度；<br>
遍历完 numSet，也就找到了最长的连续序列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numSet</span><span class="params">(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> elem : numSet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!numSet.count(elem - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (numSet.<span class="built_in">find</span>(elem + <span class="number">1</span>) != numSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    elem++;</span><br><span class="line">                    curLen++;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">std</span>::<span class="built_in">max</span>(res, curLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路二：并查集">思路二：并查集</h3>
<p>对于 nums 中的每一个元素 elem，我们都在 ufSet 中初始化对应的 value 为 elem + 1，之所以这么做其实是将并查集的查 root 结点的行为与连续序列中查找下一个元素的行为保持一致。<br>
再遍历一边 nums 数组，只要 elem 的父结点在 nums 中，我们就继续查找它父结点的父结点，这个过程有点像链表的遍历，直到找到 root 结点才退出当前循环，将 elem 的父结点更新为 root 结点并计算连续序列的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ufSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; elem : nums) &#123;</span><br><span class="line">            ufSet[elem] = elem + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; elem : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = ufSet[elem];</span><br><span class="line">            <span class="keyword">while</span> (ufSet.<span class="built_in">find</span>(parent) != ufSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                parent = ufSet[parent];</span><br><span class="line">            &#125;</span><br><span class="line">            ufSet[elem] = parent;</span><br><span class="line">            res = <span class="built_in">std</span>::<span class="built_in">max</span>(res, parent - elem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Union-Find</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0054. 螺旋矩阵</title>
    <url>/posts/fcfca138/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">题目链接</a><br>
给定一个包含 m x n 个元素的矩阵，请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<p>示例 1:<br>
输入:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输出: [1,2,3,6,9,8,7,4,5]</p>
<p>示例 2:<br>
输入:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>输出: [1,2,3,4,8,12,11,10,9,5,6,7]</p>
<h3 id="思路一：从外到内按层打印">思路一：从外到内按层打印</h3>
<p>比较浅显易懂的思路，从外到内一圈一圈处理，每次处理完一圈都将左上角坐标加一，右下角坐标减一，当左上角的坐标大于右下角的坐标时，说明矩阵中的元素已经全部处理完成了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> tR = <span class="number">0</span>, tC = <span class="number">0</span>, dR = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, dC = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC) &#123;</span><br><span class="line">            <span class="built_in">process</span>(matrix, tR++, tC++, dR--, dC--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> tR, <span class="keyword">int</span> tC, <span class="keyword">int</span> dR, <span class="keyword">int</span> dC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tR == dR) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = tC; i &lt;= dC; ++i) &#123;</span><br><span class="line">                res.push_back(matrix[tR][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tC == dC) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = tR; i &lt;= dR; ++i) &#123;</span><br><span class="line">                res.push_back(matrix[i][tC]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> curC = tC, curR = tR;</span><br><span class="line">            <span class="keyword">while</span> (curC != dC) &#123;</span><br><span class="line">                res.push_back(matrix[tR][curC++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR != dR) &#123;</span><br><span class="line">                res.push_back(matrix[curR++][dC]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curC != tC) &#123;</span><br><span class="line">                res.push_back(matrix[dR][curC--]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR != tR) &#123;</span><br><span class="line">                res.push_back(matrix[curR--][tC]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0238. 除自身以外数组的乘积</title>
    <url>/posts/cc86ed49/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">题目链接</a><br>
给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<p>示例:<br>
输入: [1,2,3,4]<br>
输出: [24,12,8,6]<br>
提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。<br>
说明: 请不要使用除法，且在 O(n) 时间复杂度与常数空间复杂度内完成此题。</p>
<h3 id="思路一：前缀后缀积">思路一：前缀后缀积</h3>
<p>数组中除掉某一个数后其他数的乘积其实就相当于该数左边子数组的乘积乘以右边子数组的乘积，那么我们可以维护两个数组，分别保存从左至右和从右至左两次遍历计算的元素乘积，也就是说，对于数组 arr 中的某一个元素 arr[i] 来说，left[i] 等于从 arr[0] 一直乘到 arr[i - 1] 的积，right[i] 等于从 arr[n] 一直乘到 arr[i + 1] 的积，那么 res[i] 其实就等于 left[i] * right[i]。<br>
进一步，因为计算 left 和 right 数组是两个独立的过程，我们可以直接复用 res 数组：<br>
将 left 数组直接放入 res 数组中，那么 res[i] 表示的其实就是 arr 数组中第 i 个元素之前所有元素的乘积，计算完之后，我们再在 res 数组上直接计算结果，假设变量 right = 1，它的含义就是上面说的 right 数组中当前元素的值，那么从 res[n] 开始，依次将 right 的值乘入 res 数组中，最后得到的 res 即为所求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            res[i] = res[i] * right;</span><br><span class="line">            right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 0837. 新 21 点</title>
    <url>/posts/3da3e5d5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/new-21-game/" target="_blank" rel="noopener">题目链接</a><br>
爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：<br>
爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。<br>
当爱丽丝获得不少于 K 分时，她就停止抽取数字。求爱丽丝的分数不超过 N 的概率是多少。</p>
<p>示例 1：<br>
输入：N = 10, K = 1, W = 10<br>
输出：1.00000<br>
说明：爱丽丝得到一张卡，然后停止。</p>
<p>示例 2：<br>
输入：N = 6, K = 1, W = 10<br>
输出：0.60000<br>
说明：爱丽丝得到一张卡，然后停止。在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。</p>
<p>示例 3：<br>
输入：N = 21, K = 17, W = 10<br>
输出：0.73278</p>
<h3 id="思路一：动态规划">思路一：动态规划</h3>
<p>首先，抽卡能获得的最大点数为 K - 1 + W，开始的时候点数为 0，那么我们可以用一个大小为 K + W 的数组来表示整个抽卡过程中所有的可能值。数组下标为点数，里面保存的是对应点数时不超过 N 的概率。<br>
我们假设当前点数为 i，那么 dp[i] 的值其实和下一次抽到的点数有关，也就是说，这个 dp 数组的更新方向应该是从后向前的，我们假设下一次抽到的点数为 j，抽到这个点数的概率为 1/W，那么此时对应的不超过 N 的概率应该为 <code>1/W * dp[i + j]</code>，j 的取值范围为 1 到 W，那么我们可以知道 <code>dp[i] = 1/W * (dp[i + 1] + ... + dp[i + W])</code>。<br>
当前点数大于 K - 1 时，不再抽卡，那么从 dp[K] 一直到 dp[K + W - 1]，如果 K &lt;= N，对应的 dp[K] = 1.0，否则就等于 0，从后面一直递推到 dp[0]，就是不超过 N 的概率。<br>
此外，需要注意一个特殊的初始条件，由上面的分析可以推出，如果达到了最大值 K - 1，再抽一个最大值 W，此时 K + W - 1 仍然严格小于 N，那么可以判断无论怎么抽，分数都不可能超过 N，概率就为 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span> || K + W &lt;= N) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(K + W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = K; i &lt;= N &amp;&amp; i &lt;= K + W; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> pr = <span class="number">1.0</span> / W;</span><br><span class="line">        dp[K - <span class="number">1</span>] = (N - K + <span class="number">1</span>) * pr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = K - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// dp[i] = dp[i + 1] - 1/w * dp[i + 1 + w] + 1/w * dp[i + 1]</span></span><br><span class="line">            dp[i] = dp[i + <span class="number">1</span>] - pr * (dp[i + W + <span class="number">1</span>] - dp[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic-Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LCOF 064. 求 1+2+...+n</title>
    <url>/posts/5559b584/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">题目链接</a><br>
求 1+2+…+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</p>
<p>示例 1：<br>
输入: n = 3<br>
输出: 6</p>
<p>示例 2：<br>
输入: n = 9<br>
输出: 45</p>
<h3 id="思路一：递归-短路判断">思路一：递归 + 短路判断</h3>
<p>这种叠加求和、求积的题目很容易想到用递归来处理，因为不能使用 if 条件判断，那么递归结束可以用 &amp;&amp; 短路来判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += sumNums(n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1431. 拥有最多糖果的孩子</title>
    <url>/posts/d68966ad/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/" target="_blank" rel="noopener">题目链接</a><br>
给你一个数组 candies 和一个整数 extraCandies，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。<br>
对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有最多的糖果。注意，允许有多个孩子同时拥有最多的糖果数目。</p>
<p>示例 1：<br>
输入：candies = [2,3,5,1,3], extraCandies = 3<br>
输出：[true,true,true,false,true]</p>
<p>示例 2：<br>
输入：candies = [4,2,1,1,2], extraCandies = 1<br>
输出：[true,false,false,false,false]</p>
<p>示例 3：<br>
输入：candies = [12,1,12], extraCandies = 10<br>
输出：[true,false,true]</p>
<h3 id="思路一：遍历枚举">思路一：遍历枚举</h3>
<p>遍历数组，找到最多的糖果数量，再遍历一遍就好；<br>
正如 LeetCode 官方说的，一起在做题中找回「简单」的快乐；<br>
大朋友小朋友们，儿童节快乐😉</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candyNum = candies.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> mostCandy = *<span class="built_in">std</span>::max_element(candies.<span class="built_in">begin</span>(), candies.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : candies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item + extraCandies &gt;= mostCandy) &#123;</span><br><span class="line">                res.push_back(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 101. 对称二叉树</title>
    <url>/posts/3c1e41f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="题目">题目</h3>
<p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">题目链接</a><br>
给定一个二叉树，检查它是否是镜像对称的。<br>
例如，二叉树 [1,2,2,3,4,4,3] 是对称的，<br>
而 [1,2,2,null,3,null,3] 则不是镜像对称的。</p>
<h3 id="思路一：深度优先遍历">思路一：深度优先遍历</h3>
<p>如果一个树的左子树与右子树是对称的，那么这个树就是镜像对称的；<br>
也就是说，如果两个子树根节点值相等，并且每个结点左子树与另一个结点右子树对称，两棵树就是镜像对称的，我们让两个指针分别从左右子树的相同结点出发，对称遍历，如果对应结点值相等，再将指针分别向左右对称移动。<br>
时间复杂度：由于需要遍历整棵树，时间复杂度为 O(n)。<br>
空间复杂度：递归需要额外使用空间为 O(n) 的递归栈。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* leftChild, TreeNode* rightChild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!leftChild &amp;&amp; !rightChild) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!leftChild || !rightChild) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftChild-&gt;val == rightChild-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> isMirror(leftChild-&gt;left, rightChild-&gt;right) &amp;&amp; isMirror(leftChild-&gt;right, rightChild-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思路二：广度优先遍历">思路二：广度优先遍历</h3>
<p>思路一中的递归可以改写为迭代的方法，迭代需要使用一个队列 nodeQueue，每次需要出队两个结点进行比较，那么我们在入队的时候就需要将镜像对应的结点依次入队；也就是当前出队结点的 a 的左子节点和 b 的右子节点。<br>
时间复杂度：每个结点都需要遍历一次，为 O(n)。<br>
空间复杂度：需要用队列来维护节点，每个节点最多进队一次，出队一次，空间复杂度为 O(n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        nodeQueue.push(root-&gt;left);</span><br><span class="line">        nodeQueue.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!nodeQueue.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node1 = nodeQueue.front();</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">            <span class="keyword">auto</span> node2 = nodeQueue.front();</span><br><span class="line">            nodeQueue.pop();</span><br><span class="line">            <span class="keyword">if</span> (!node1 &amp;&amp; !node2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!node1 || !node2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;val != node2-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeQueue.push(node1-&gt;left);</span><br><span class="line">            nodeQueue.push(node2-&gt;right);</span><br><span class="line">            nodeQueue.push(node1-&gt;right);</span><br><span class="line">            nodeQueue.push(node2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary-Tree</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析 Linux 内核：connect 与三次握手</title>
    <url>/posts/4bc0bb9f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前一篇文章提到了 socket 的创建与使用，这篇接着上一篇来谈谈 connect 系统调用与内核网络协议栈中的三次握手。<br>
三次握手一般是由客户端调用 connect 发起的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(<span class="built_in">connect</span>, <span class="keyword">int</span>, fd, struct sockaddr __user *, uservaddr, <span class="keyword">int</span>, addrlen) &#123;</span><br><span class="line">    <span class="keyword">return</span> __sys_connect(fd, uservaddr, addrlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __sys_connect(<span class="keyword">int</span> fd, struct sockaddr __user *uservaddr, <span class="keyword">int</span> addrlen) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -EBADF;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 fd 对应的 struct file</span></span><br><span class="line">    f = fdget(fd);</span><br><span class="line">    <span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将地址拷贝到内核空间</span></span><br><span class="line">        ret = move_addr_to_kernel(uservaddr, addrlen, &amp;address);</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            ret = __sys_connect_file(f.file, &amp;address, addrlen, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (f.flags)</span><br><span class="line">            fput(f.file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __sys_connect_file(struct file *file, struct sockaddr_storage *address, <span class="keyword">int</span> addrlen, <span class="keyword">int</span> file_flags) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 struct file 的 private_data 中获取 struct socket</span></span><br><span class="line">    sock = sock_from_file(file, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (!sock)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里直接返回的是 0, 还不知道有什么作用</span></span><br><span class="line">    err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用的是 inet_stream_ops 中的 inet_stream_connect</span></span><br><span class="line">    err = sock-&gt;ops-&gt;<span class="built_in">connect</span>(sock, (struct sockaddr *)address, addrlen, sock-&gt;file-&gt;f_flags | file_flags);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果看了上一篇文章，这里的调用链就很简单了，首先内核会从创建的 socket 的 fd 中获取对应的 struct file，这个 struct file 用于 __sys_connect_file 的参数，接着将地址拷贝到内核态。然后通过前面取出的 struct file 中的 private_data 找到 struct socket，并且调用 sock-&gt;ops-&gt;connect，按照上一篇文章提到的初始化，这里调用的是 inet_stream_ops 中的 inet_stream_connect。我们先总体说一下函数的流程，再依次单独分析。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_stream_connect</span><span class="params">(struct socket *sock, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    lock_sock(sock-&gt;sk);</span><br><span class="line">    err = __inet_stream_connect(sock, uaddr, addr_len, flags, <span class="number">0</span>);</span><br><span class="line">    release_sock(sock-&gt;sk);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(inet_stream_connect);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags, <span class="keyword">int</span> is_sendmsg) &#123;</span><br><span class="line">    <span class="comment">// 获取 struct socket 对应的 struct sock</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">long</span> timeo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uaddr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(uaddr-&gt;sa_family))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议族参数未指定</span></span><br><span class="line">        <span class="keyword">if</span> (uaddr-&gt;sa_family == AF_UNSPEC) &#123;</span><br><span class="line">            err = sk-&gt;sk_prot-&gt;<span class="built_in">disconnect</span>(sk, flags);</span><br><span class="line">            sock-&gt;state = err ? SS_DISCONNECTING : SS_UNCONNECTED;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect 根据 struct socket 中保存的 state 判断下一步的行为</span></span><br><span class="line">    <span class="keyword">switch</span> (sock-&gt;state) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">// 已经连接了, 直接返回</span></span><br><span class="line">    <span class="keyword">case</span> SS_CONNECTED:</span><br><span class="line">        err = -EISCONN;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">case</span> SS_CONNECTING:</span><br><span class="line">        <span class="keyword">if</span> (inet_sk(sk)-&gt;defer_connect)</span><br><span class="line">            err = is_sendmsg ? -EINPROGRESS : -EISCONN;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -EALREADY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 握手刚开始 socket 处于未连接状态</span></span><br><span class="line">    <span class="keyword">case</span> SS_UNCONNECTED:</span><br><span class="line">        err = -EISCONN;</span><br><span class="line">        <span class="comment">// 判断下层 struct sock 状态</span></span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) &#123;</span><br><span class="line">            err = sk-&gt;sk_prot-&gt;pre_connect(sk, uaddr, addr_len);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 tcp_prot 中的 tcp_v4_connect 发送 SYN 包</span></span><br><span class="line">        err = sk-&gt;sk_prot-&gt;<span class="built_in">connect</span>(sk, uaddr, addr_len);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送 SYN 后将 struct socket 状态设置为 SS_CONNECTING</span></span><br><span class="line">        sock-&gt;state = SS_CONNECTING;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!err &amp;&amp; inet_sk(sk)-&gt;defer_connect)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        err = -EINPROGRESS;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接超时时间, 即等待 SYN-ACK 的时间, 如果设置了非阻塞就直接返回</span></span><br><span class="line">    timeo = sock_sndtimeo(sk, flags &amp; O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</span><br><span class="line">        <span class="keyword">int</span> writebias = (sk-&gt;sk_protocol == IPPROTO_TCP) &amp;&amp;</span><br><span class="line">                                tcp_sk(sk)-&gt;fastopen_req &amp;&amp;</span><br><span class="line">                                tcp_sk(sk)-&gt;fastopen_req-&gt;data ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inet_wait_for_connect 等待服务端返回的 ACK</span></span><br><span class="line">        <span class="keyword">if</span> (!timeo || !inet_wait_for_connect(sk, timeo, writebias))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        err = sock_intr_errno(timeo);</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接被 RST/timeout/ICMP error/另一个进程 关闭, 连接失败</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_CLOSE)</span><br><span class="line">        <span class="keyword">goto</span> sock_error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接成功建立</span></span><br><span class="line">    sock-&gt;state = SS_CONNECTED;</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">sock_error:</span><br><span class="line">    err = sock_error(sk) ?: -ECONNABORTED;</span><br><span class="line">    sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_prot-&gt;<span class="built_in">disconnect</span>(sk, flags))</span><br><span class="line">        sock-&gt;state = SS_DISCONNECTING;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__inet_stream_connect);</span><br></pre></td></tr></table></figure>
<p>inet_stream_connect 会调用 __inet_stream_connect，握手开始时 socket 处于 SS_UNCONNECTED 状态，同时下层的 struct sock 处于 TCP_CLOSE 状态，接着会调用 sk-&gt;sk_prot-&gt;connect，也就是 tcp_prot 中的 tcp_v4_connect，之后 socket 的状态被设置为 SS_CONNECTING，发送完 SYN 后，客户端会在 inet_wait_for_connect 等待服务端返回的 ACK 或者 timeo 超时，如果连接成功，还需要修改 struct socket 的状态为 SS_CONNECTED。<br>
下面先看发送 SYN 包的 tcp_v4_connect：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_connect</span><span class="params">(struct sock *sk, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将通用地址结构转换为 struct sockaddr_in IPv4 地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">usin</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *)<span class="title">uaddr</span>;</span></span><br><span class="line">    <span class="comment">// struct sock 的扩展, 包含了地址, 端口号, TTL 等属于网络层的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="comment">// struct tcp_sock 是 struct inet_connection_sock 的扩展</span></span><br><span class="line">    <span class="comment">// 里面包含了接收窗口, 拥塞窗口等 TCP 特有的结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    __be16 orig_sport, orig_dport;</span><br><span class="line">    __be32 daddr, nexthop;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> *<span class="title">fl4</span>;</span></span><br><span class="line">    <span class="comment">// struct rtable 是路由表项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_options_rcu</span> *<span class="title">inet_opt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_timewait_death_row</span> *<span class="title">tcp_death_row</span> = &amp;<span class="title">sock_net</span>(<span class="title">sk</span>)-&gt;<span class="title">ipv4</span>.<span class="title">tcp_death_row</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验地址长度</span></span><br><span class="line">    <span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(struct sockaddr_in))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验地址族是否为 AF_INET</span></span><br><span class="line">    <span class="keyword">if</span> (usin-&gt;sin_family != AF_INET)</span><br><span class="line">        <span class="keyword">return</span> -EAFNOSUPPORT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将下一跳地址和目的地址设置为用户传入的地址</span></span><br><span class="line">    nexthop = daddr = usin-&gt;sin_addr.s_addr;</span><br><span class="line">    inet_opt = rcu_dereference_protected(inet-&gt;inet_opt, lockdep_sock_is_held(sk));</span><br><span class="line">    <span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.srr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!daddr)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        nexthop = inet_opt-&gt;opt.faddr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    orig_sport = inet-&gt;inet_sport;</span><br><span class="line">    orig_dport = usin-&gt;sin_port;</span><br><span class="line">    fl4 = &amp;inet-&gt;cork.fl.u.ip4;</span><br><span class="line">    <span class="comment">// ip_route_connect 进行路由选择并赋给 struct rtable</span></span><br><span class="line">    rt = ip_route_connect(fl4, nexthop, inet-&gt;inet_saddr,</span><br><span class="line">                          RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,</span><br><span class="line">                          IPPROTO_TCP,</span><br><span class="line">                          orig_sport, orig_dport, sk);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(rt)) &#123;</span><br><span class="line">        err = PTR_ERR(rt);</span><br><span class="line">        <span class="keyword">if</span> (err == -ENETUNREACH)</span><br><span class="line">            IP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP 不能使用多播和组播</span></span><br><span class="line">    <span class="keyword">if</span> (rt-&gt;rt_flags &amp; (RTCF_MULTICAST | RTCF_BROADCAST)) &#123;</span><br><span class="line">        ip_rt_put(rt);</span><br><span class="line">        <span class="keyword">return</span> -ENETUNREACH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有启用源路由选项指定发送路由, 就使用路由缓存项中的目的地址</span></span><br><span class="line">    <span class="keyword">if</span> (!inet_opt || !inet_opt-&gt;opt.srr)</span><br><span class="line">        daddr = fl4-&gt;daddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有指定发送源地址, 就使用路由缓存项中的源地址</span></span><br><span class="line">    <span class="comment">// 从哪个网卡出去, 源地址就应该填哪个网卡的 IP 地址</span></span><br><span class="line">    <span class="keyword">if</span> (!inet-&gt;inet_saddr)</span><br><span class="line">        inet-&gt;inet_saddr = fl4-&gt;saddr;</span><br><span class="line">    sk_rcv_saddr_set(sk, inet-&gt;inet_saddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; inet-&gt;inet_daddr != daddr) &#123;</span><br><span class="line">        tp-&gt;rx_opt.ts_recent = <span class="number">0</span>;</span><br><span class="line">        tp-&gt;rx_opt.ts_recent_stamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (likely(!tp-&gt;repair))</span><br><span class="line">            WRITE_ONCE(tp-&gt;write_seq, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置目标端口</span></span><br><span class="line">    inet-&gt;inet_dport = usin-&gt;sin_port;</span><br><span class="line">    sk_daddr_set(sk, daddr);</span><br><span class="line"></span><br><span class="line">    inet_csk(sk)-&gt;icsk_ext_hdr_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (inet_opt)</span><br><span class="line">        inet_csk(sk)-&gt;icsk_ext_hdr_len = inet_opt-&gt;opt.optlen;</span><br><span class="line"></span><br><span class="line">    tp-&gt;rx_opt.mss_clamp = TCP_MSS_DEFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 struct sock 状态为 TCP_SYN_SENT</span></span><br><span class="line">    tcp_set_state(sk, TCP_SYN_SENT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置本地端口</span></span><br><span class="line">    err = inet_hash_connect(tcp_death_row, sk);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> failure;</span><br><span class="line"></span><br><span class="line">    sk_set_txhash(sk);</span><br><span class="line"></span><br><span class="line">    rt = ip_route_newports(fl4, rt, orig_sport, orig_dport, inet-&gt;inet_sport, inet-&gt;inet_dport, sk);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(rt)) &#123;</span><br><span class="line">        err = PTR_ERR(rt);</span><br><span class="line">        rt = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> failure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sk-&gt;sk_gso_type = SKB_GSO_TCPV4;</span><br><span class="line">    sk_setup_caps(sk, &amp;rt-&gt;dst);</span><br><span class="line">    rt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(!tp-&gt;repair)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tp-&gt;write_seq)</span><br><span class="line">            <span class="comment">// 初始化序列号 TCP seq num</span></span><br><span class="line">            WRITE_ONCE(tp-&gt;write_seq,</span><br><span class="line">                       secure_tcp_seq(inet-&gt;inet_saddr,</span><br><span class="line">                                      inet-&gt;inet_daddr,</span><br><span class="line">                                      inet-&gt;inet_sport,</span><br><span class="line">                                      usin-&gt;sin_port));</span><br><span class="line">        tp-&gt;tsoffset = secure_tcp_ts_off(sock_net(sk),</span><br><span class="line">                                         inet-&gt;inet_saddr,</span><br><span class="line">                                         inet-&gt;inet_daddr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inet-&gt;inet_id = prandom_u32();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_fastopen_defer_connect(sk, &amp;err))</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> failure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 SYN 包并发送</span></span><br><span class="line">    err = tcp_connect(sk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> failure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">failure:</span><br><span class="line">    tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">    ip_rt_put(rt);</span><br><span class="line">    sk-&gt;sk_route_caps = <span class="number">0</span>;</span><br><span class="line">    inet-&gt;inet_dport = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_v4_connect);</span><br></pre></td></tr></table></figure>
<p>在 tcp_v4_connect 中有一个新的 struct tcp_sock，这个结构其实是 struct inet_connection_sock 扩展，方法和上一篇文章讲的一样，这个结构维护了更多 TCP 的状态，它也被称为 TCP 的传输控制块。<br>
tcp_v4_connect 函数中，首先通过 ip_route_connect 进行路由选择，得到的结果是一个路由表项 struct rtable，这其实是为我们后面发送 SYN 包做准备，因为要发网络包，就得有源地址和端口、目标地址和端口，路由选择的时候就确定了源地址和目标地址，源端口是客户端在 inet_hash_connect 函数中随机分配的，目标端口在后面通过 struct sockaddr_in 进行了赋值。随后内核修改了网络层 struct sock 的状态为 TCP_SYN_SENT，这个状态和我们常见的三次握手示意图上的状态是对应的。<br>
接下来进入了发送环节，调用 tcp_connect 构造 SYN 包并发送：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_connect</span><span class="params">(struct sock *sk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正式进入了 TCP 传输阶段, 需要转换出 struct tcp_sock</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">buff</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    tcp_call_bpf(sk, BPF_SOCK_OPS_TCP_CONNECT_CB, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inet_csk(sk)-&gt;icsk_af_ops-&gt;rebuild_header(sk))</span><br><span class="line">        <span class="keyword">return</span> -EHOSTUNREACH;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 struct sock 中与连接相关的功能</span></span><br><span class="line">    tcp_connect_init(sk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(tp-&gt;repair))</span><br><span class="line">    &#123;</span><br><span class="line">        tcp_finish_connect(sk, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 SYN 分配空间</span></span><br><span class="line">    buff = sk_stream_alloc_skb(sk, <span class="number">0</span>, sk-&gt;sk_allocation, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!buff))</span><br><span class="line">        <span class="keyword">return</span> -ENOBUFS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化了一个 SYN 包</span></span><br><span class="line">    tcp_init_nondata_skb(buff, tp-&gt;write_seq++, TCPHDR_SYN);</span><br><span class="line">    tcp_mstamp_refresh(tp);</span><br><span class="line">    tp-&gt;retrans_stamp = tcp_time_stamp(tp);</span><br><span class="line">    tcp_connect_queue_skb(sk, buff);</span><br><span class="line">    tcp_ecn_send_syn(sk, buff);</span><br><span class="line">    tcp_rbtree_insert(&amp;sk-&gt;tcp_rtx_queue, buff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在没有使用 fastopen 功能的时候, tcp_transmit_skb 将 SYN 包发送出去</span></span><br><span class="line">    err = tp-&gt;fastopen_req ? tcp_send_syn_data(sk, buff) : tcp_transmit_skb(sk, buff, <span class="number">1</span>, sk-&gt;sk_allocation);</span><br><span class="line">    <span class="keyword">if</span> (err == -ECONNREFUSED)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    WRITE_ONCE(tp-&gt;snd_nxt, tp-&gt;write_seq);</span><br><span class="line">    tp-&gt;pushed_seq = tp-&gt;write_seq;</span><br><span class="line">    buff = tcp_send_head(sk);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(buff)) &#123;</span><br><span class="line">        WRITE_ONCE(tp-&gt;snd_nxt, TCP_SKB_CB(buff)-&gt;seq);</span><br><span class="line">        tp-&gt;pushed_seq = TCP_SKB_CB(buff)-&gt;seq;</span><br><span class="line">    &#125;</span><br><span class="line">    TCP_INC_STATS(sock_net(sk), TCP_MIB_ACTIVEOPENS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置了 timer, 在 SYN 发送失败时会再次发送</span></span><br><span class="line">    inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_connect);</span><br></pre></td></tr></table></figure>
<p>在发送了 SYN 包之后，客户端会在 inet_wait_for_connect 函数中等待，来看一下它的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">inet_wait_for_connect</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeo, <span class="keyword">int</span> writebias)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个 struct_queue_entry, 功能是等待 condition 生效时唤醒</span></span><br><span class="line">    DEFINE_WAIT_FUNC(wait, woken_wake_function);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将上面的 wait 对象加入 sk_sleep 的等待队列</span></span><br><span class="line">    add_wait_queue(sk_sleep(sk), &amp;wait);</span><br><span class="line">    sk-&gt;sk_write_pending += writebias;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</span><br><span class="line">        release_sock(sk);</span><br><span class="line">        <span class="comment">// 定时后通过 schedule_timeout 主动调度 CPU</span></span><br><span class="line">        timeo = wait_woken(&amp;wait, TASK_INTERRUPTIBLE, timeo);</span><br><span class="line">        lock_sock(sk);</span><br><span class="line">        <span class="comment">// 如果收到了信号唤醒就要提前退出并脱链</span></span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current) || !timeo)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    remove_wait_queue(sk_sleep(sk), &amp;wait);</span><br><span class="line">    sk-&gt;sk_write_pending -= writebias;</span><br><span class="line">    <span class="keyword">return</span> timeo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们先将下层的协议栈看作一个黑盒，服务端收到的 IP 包里面的 protocol 应该是 TCP 协议，这表明接收端的上层应该使用 TCP 协议来处理收到的包，在 <code>/include/net/protocol.h</code> 中能够找到 struct net_protocol 的定义，这个结构体用于注册协议。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*early_demux)(struct sk_buff *skb);</span><br><span class="line">    <span class="keyword">int</span> (*early_demux_handler)(struct sk_buff *skb);</span><br><span class="line">    <span class="keyword">int</span> (*handler)(struct sk_buff *skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This returns an error if we weren't able to handle the error. */</span></span><br><span class="line">    <span class="keyword">int</span> (*err_handler)(struct sk_buff *skb, u32 info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> no_policy : <span class="number">1</span>,</span><br><span class="line">        netns_ok : <span class="number">1</span>,</span><br><span class="line">        icmp_strict_tag_validation : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>能看到一个成员函数指针 handler，这个函数就是用来处理收到的网络包。内核初始化的时候，会申请一个 inet_protos 数组，数组元素是 struct net_protocol 类型的指针，然后再 inet_init 中初始化这个数组中的协议处理函数，这里的下标其实就是初始化 socket 时我们指定的协议号，只是现在我们不这么用了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> __<span class="title">rcu</span> *<span class="title">inet_protos</span>[<span class="title">MAX_INET_PROTOS</span>] __<span class="title">read_mostly</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// idx: IPPROTO_TCP</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">tcp_protocol</span> = &#123;</span></span><br><span class="line">    .early_demux = tcp_v4_early_demux,</span><br><span class="line">    .early_demux_handler = tcp_v4_early_demux,</span><br><span class="line">    .handler = tcp_v4_rcv,</span><br><span class="line">    .err_handler = tcp_v4_err,</span><br><span class="line">    .no_policy = <span class="number">1</span>,</span><br><span class="line">    .netns_ok = <span class="number">1</span>,</span><br><span class="line">    .icmp_strict_tag_validation = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idx: IPPROTO_UDP</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">udp_protocol</span> = &#123;</span></span><br><span class="line">    .early_demux = udp_v4_early_demux,</span><br><span class="line">    .early_demux_handler = udp_v4_early_demux,</span><br><span class="line">    .handler = udp_rcv,</span><br><span class="line">    .err_handler = udp_err,</span><br><span class="line">    .no_policy = <span class="number">1</span>,</span><br><span class="line">    .netns_ok = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idx: IPPROTO_IGMP</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">icmp_protocol</span> = &#123;</span></span><br><span class="line">    .handler = icmp_rcv,</span><br><span class="line">    .err_handler = icmp_err,</span><br><span class="line">    .no_policy = <span class="number">1</span>,</span><br><span class="line">    .netns_ok = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回到服务端收包的时候，接收端会调用 tcp_v4_rcv 来接收客户端发来的 SYN 包。<br>
这个函数有点长，先看参数，网络包的数据都是通过 struct sk_buff 这个结构保存的，这个结构我打算放在下一篇发送数据的文章介绍。<br>
服务端在第一次收到 SYN 包之前是处于 TCP_LISTEN 状态，因此会调用 tcp_v4_do_rcv。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_rcv</span><span class="params">(struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">dev_net</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb_to_free</span>;</span></span><br><span class="line">    <span class="keyword">int</span> sdif = inet_sdif(skb);</span><br><span class="line">    <span class="keyword">int</span> dif = inet_iif(skb);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> refcounted;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;pkt_type != PACKET_HOST)</span><br><span class="line">        <span class="keyword">goto</span> discard_it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Count it even if it's bad */</span></span><br><span class="line">    __TCP_INC_STATS(net, TCP_MIB_INSEGS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pskb_may_pull(skb, <span class="keyword">sizeof</span>(struct tcphdr)))</span><br><span class="line">        <span class="keyword">goto</span> discard_it;</span><br><span class="line"></span><br><span class="line">    th = (<span class="keyword">const</span> struct tcphdr *)skb-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(th-&gt;doff &lt; <span class="keyword">sizeof</span>(struct tcphdr) / <span class="number">4</span>))</span><br><span class="line">        <span class="keyword">goto</span> bad_packet;</span><br><span class="line">    <span class="keyword">if</span> (!pskb_may_pull(skb, th-&gt;doff * <span class="number">4</span>))</span><br><span class="line">        <span class="keyword">goto</span> discard_it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))</span><br><span class="line">        <span class="keyword">goto</span> csum_error;</span><br><span class="line"></span><br><span class="line">    th = (<span class="keyword">const</span> struct tcphdr *)skb-&gt;data;</span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line">lookup:</span><br><span class="line">    sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, __tcp_hdrlen(th), th-&gt;source,</span><br><span class="line">                           th-&gt;dest, sdif, &amp;refcounted);</span><br><span class="line">    <span class="keyword">if</span> (!sk)</span><br><span class="line">        <span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line"></span><br><span class="line"><span class="built_in">process</span>:</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_TIME_WAIT)</span><br><span class="line">        <span class="keyword">goto</span> do_time_wait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_NEW_SYN_RECV) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span> = <span class="title">inet_reqsk</span>(<span class="title">sk</span>);</span></span><br><span class="line">        <span class="keyword">bool</span> req_stolen = <span class="literal">false</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nsk</span>;</span></span><br><span class="line"></span><br><span class="line">        sk = req-&gt;rsk_listener;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(tcp_v4_inbound_md5_hash(sk, skb, dif, sdif))) &#123;</span><br><span class="line">            sk_drops_add(sk, skb);</span><br><span class="line">            reqsk_put(req);</span><br><span class="line">            <span class="keyword">goto</span> discard_it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tcp_checksum_complete(skb)) &#123;</span><br><span class="line">            reqsk_put(req);</span><br><span class="line">            <span class="keyword">goto</span> csum_error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(sk-&gt;sk_state != TCP_LISTEN)) &#123;</span><br><span class="line">            inet_csk_reqsk_queue_drop_and_put(sk, req);</span><br><span class="line">            <span class="keyword">goto</span> lookup;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sock_hold(sk);</span><br><span class="line">        refcounted = <span class="literal">true</span>;</span><br><span class="line">        nsk = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!tcp_filter(sk, skb)) &#123;</span><br><span class="line">            th = (<span class="keyword">const</span> struct tcphdr *)skb-&gt;data;</span><br><span class="line">            iph = ip_hdr(skb);</span><br><span class="line">            tcp_v4_fill_cb(skb, iph, th);</span><br><span class="line">            nsk = tcp_check_req(sk, skb, req, <span class="literal">false</span>, &amp;req_stolen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!nsk) &#123;</span><br><span class="line">            reqsk_put(req);</span><br><span class="line">            <span class="keyword">if</span> (req_stolen) &#123;</span><br><span class="line"></span><br><span class="line">                tcp_v4_restore_cb(skb);</span><br><span class="line">                sock_put(sk);</span><br><span class="line">                <span class="keyword">goto</span> lookup;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> discard_and_relse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nsk == sk) &#123;</span><br><span class="line">            reqsk_put(req);</span><br><span class="line">            tcp_v4_restore_cb(skb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tcp_child_process(sk, nsk, skb)) &#123;</span><br><span class="line">            tcp_v4_send_reset(nsk, skb);</span><br><span class="line">            <span class="keyword">goto</span> discard_and_relse;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sock_put(sk);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(iph-&gt;ttl &lt; inet_sk(sk)-&gt;min_ttl)) &#123;</span><br><span class="line">        __NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);</span><br><span class="line">        <span class="keyword">goto</span> discard_and_relse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))</span><br><span class="line">        <span class="keyword">goto</span> discard_and_relse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_v4_inbound_md5_hash(sk, skb, dif, sdif))</span><br><span class="line">        <span class="keyword">goto</span> discard_and_relse;</span><br><span class="line"></span><br><span class="line">    nf_reset_ct(skb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_filter(sk, skb))</span><br><span class="line">        <span class="keyword">goto</span> discard_and_relse;</span><br><span class="line">    th = (<span class="keyword">const</span> struct tcphdr *)skb-&gt;data;</span><br><span class="line">    iph = ip_hdr(skb);</span><br><span class="line">    tcp_v4_fill_cb(skb, iph, th);</span><br><span class="line"></span><br><span class="line">    skb-&gt;dev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次收到 SYN 包的时候, 服务端处在 TCP_LISTEN 状态</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN) &#123;</span><br><span class="line">        ret = tcp_v4_do_rcv(sk, skb);</span><br><span class="line">        <span class="keyword">goto</span> put_and_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sk_incoming_cpu_update(sk);</span><br><span class="line"></span><br><span class="line">    bh_lock_sock_nested(sk);</span><br><span class="line">    tcp_segs_in(tcp_sk(sk), skb);</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!sock_owned_by_user(sk)) &#123;</span><br><span class="line">        skb_to_free = sk-&gt;sk_rx_skb_cache;</span><br><span class="line">        sk-&gt;sk_rx_skb_cache = <span class="literal">NULL</span>;</span><br><span class="line">        ret = tcp_v4_do_rcv(sk, skb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcp_add_backlog(sk, skb))</span><br><span class="line">            <span class="keyword">goto</span> discard_and_relse;</span><br><span class="line">        skb_to_free = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bh_unlock_sock(sk);</span><br><span class="line">    <span class="keyword">if</span> (skb_to_free)</span><br><span class="line">        __kfree_skb(skb_to_free);</span><br><span class="line"></span><br><span class="line">put_and_return:</span><br><span class="line">    <span class="keyword">if</span> (refcounted)</span><br><span class="line">        sock_put(sk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">no_tcp_socket:</span><br><span class="line">    <span class="keyword">if</span> (!xfrm4_policy_check(<span class="literal">NULL</span>, XFRM_POLICY_IN, skb))</span><br><span class="line">        <span class="keyword">goto</span> discard_it;</span><br><span class="line"></span><br><span class="line">    tcp_v4_fill_cb(skb, iph, th);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_checksum_complete(skb)) &#123;</span><br><span class="line">    csum_error:</span><br><span class="line">        __TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);</span><br><span class="line">    bad_packet:</span><br><span class="line">        __TCP_INC_STATS(net, TCP_MIB_INERRS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tcp_v4_send_reset(<span class="literal">NULL</span>, skb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">discard_it:</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">discard_and_relse:</span><br><span class="line">    sk_drops_add(sk, skb);</span><br><span class="line">    <span class="keyword">if</span> (refcounted)</span><br><span class="line">        sock_put(sk);</span><br><span class="line">    <span class="keyword">goto</span> discard_it;</span><br><span class="line"></span><br><span class="line">do_time_wait:</span><br><span class="line">    <span class="keyword">if</span> (!xfrm4_policy_check(<span class="literal">NULL</span>, XFRM_POLICY_IN, skb)) &#123;</span><br><span class="line">        inet_twsk_put(inet_twsk(sk));</span><br><span class="line">        <span class="keyword">goto</span> discard_it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tcp_v4_fill_cb(skb, iph, th);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_checksum_complete(skb)) &#123;</span><br><span class="line">        inet_twsk_put(inet_twsk(sk));</span><br><span class="line">        <span class="keyword">goto</span> csum_error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (tcp_timewait_state_process(inet_twsk(sk), skb, th)) &#123;</span><br><span class="line">    <span class="keyword">case</span> TCP_TW_SYN:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk2</span> = <span class="title">inet_lookup_listener</span>(<span class="title">dev_net</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>),</span></span><br><span class="line"><span class="class">                                                &amp;<span class="title">tcp_hashinfo</span>, <span class="title">skb</span>,</span></span><br><span class="line"><span class="class">                                                __<span class="title">tcp_hdrlen</span>(<span class="title">th</span>),</span></span><br><span class="line"><span class="class">                                                <span class="title">iph</span>-&gt;<span class="title">saddr</span>, <span class="title">th</span>-&gt;<span class="title">source</span>,</span></span><br><span class="line"><span class="class">                                                <span class="title">iph</span>-&gt;<span class="title">daddr</span>, <span class="title">th</span>-&gt;<span class="title">dest</span>,</span></span><br><span class="line"><span class="class">                                                <span class="title">inet_iif</span>(<span class="title">skb</span>),</span></span><br><span class="line"><span class="class">                                                <span class="title">sdif</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (sk2) &#123;</span><br><span class="line">            inet_twsk_deschedule_put(inet_twsk(sk));</span><br><span class="line">            sk = sk2;</span><br><span class="line">            tcp_v4_restore_cb(skb);</span><br><span class="line">            refcounted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">process</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/* to ACK */</span></span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> TCP_TW_ACK:</span><br><span class="line">        tcp_v4_timewait_ack(sk, skb);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TCP_TW_RST:</span><br><span class="line">        tcp_v4_send_reset(sk, skb);</span><br><span class="line">        inet_twsk_deschedule_put(inet_twsk(sk));</span><br><span class="line">        <span class="keyword">goto</span> discard_it;</span><br><span class="line">    <span class="keyword">case</span> TCP_TW_SUCCESS:;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> discard_it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcp_v4_do_rcv 按照 struct sock 保存的状态 TCP_LISTEN，会继续调用 tcp_rcv_state_process：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 除了 TCP_LISTEN socket, 其他状态的 socket 进入该函数时必须拿到锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_do_rcv</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">rsk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_ESTABLISHED) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *<span class="title">dst</span> = <span class="title">sk</span>-&gt;<span class="title">sk_rx_dst</span>;</span></span><br><span class="line"></span><br><span class="line">        sock_rps_save_rxhash(sk, skb);</span><br><span class="line">        sk_mark_napi_id(sk, skb);</span><br><span class="line">        <span class="keyword">if</span> (dst) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inet_sk(sk)-&gt;rx_dst_ifindex != skb-&gt;skb_iif ||</span><br><span class="line">                !dst-&gt;ops-&gt;check(dst, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                dst_release(dst);</span><br><span class="line">                sk-&gt;sk_rx_dst = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tcp_rcv_established(sk, skb);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_checksum_complete(skb))</span><br><span class="line">        <span class="keyword">goto</span> csum_err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">nsk</span> = <span class="title">tcp_v4_cookie_check</span>(<span class="title">sk</span>, <span class="title">skb</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!nsk)</span><br><span class="line">            <span class="keyword">goto</span> discard;</span><br><span class="line">        <span class="keyword">if</span> (nsk != sk) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tcp_child_process(sk, nsk, skb))</span><br><span class="line">            &#123;</span><br><span class="line">                rsk = nsk;</span><br><span class="line">                <span class="keyword">goto</span> reset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sock_rps_save_rxhash(sk, skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收网络包后修改状态</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_rcv_state_process(sk, skb)) &#123;</span><br><span class="line">        rsk = sk;</span><br><span class="line">        <span class="keyword">goto</span> reset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">    tcp_v4_send_reset(rsk, skb);</span><br><span class="line">discard:</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">csum_err:</span><br><span class="line">    TCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);</span><br><span class="line">    TCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);</span><br><span class="line">    <span class="keyword">goto</span> discard;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_v4_do_rcv);</span><br></pre></td></tr></table></figure>
<p>来到 tcp_rcv_state_process，根据 struct sock 的状态找到 TCP_LISTEN 的执行流程，从 struct sk_buff 中取出这个网络包的类型 syn，执行到 icsk-&gt;icsk_af_ops-&gt;conn_request，icsk 就是维护有连接的状态结构体 struct inet_connection_sock，它里面的 icsk_af_ops 是一个 struct inet_connection_sock_af_ops 类型的指针，这个指针所指对象在 <code>/net/ipv4/tcp_ipv4.c</code> 中初始化，不难看出，conn_request 对应的函数是 tcp_v4_conn_request。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock_af_ops</span> <span class="title">ipv4_specific</span> = &#123;</span></span><br><span class="line">    .queue_xmit = ip_queue_xmit,</span><br><span class="line">    .send_check = tcp_v4_send_check,</span><br><span class="line">    .rebuild_header = inet_sk_rebuild_header,</span><br><span class="line">    .sk_rx_dst_set = inet_sk_rx_dst_set,</span><br><span class="line">    .conn_request = tcp_v4_conn_request,</span><br><span class="line">    .syn_recv_sock = tcp_v4_syn_recv_sock,</span><br><span class="line">    .net_header_len = <span class="keyword">sizeof</span>(struct iphdr),</span><br><span class="line">    .setsockopt = ip_setsockopt,</span><br><span class="line">    .getsockopt = ip_getsockopt,</span><br><span class="line">    .addr2sockaddr = inet_csk_addr2sockaddr,</span><br><span class="line">    .sockaddr_len = <span class="keyword">sizeof</span>(struct sockaddr_in),</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    .compat_setsockopt = compat_ip_setsockopt,</span><br><span class="line">    .compat_getsockopt = compat_ip_getsockopt,</span><br><span class="line">#endif</span><br><span class="line">    .mtu_reduced = tcp_v4_mtu_reduced,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(ipv4_specific);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数用于执行 ESTABLISHED 和 TIME_WAIT 以外的接收网络包的流程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">th</span> = <span class="title">tcp_hdr</span>(<span class="title">skb</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>;</span></span><br><span class="line">    <span class="keyword">int</span> queued = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> acceptable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> TCP_CLOSE:</span><br><span class="line">        <span class="keyword">goto</span> discard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TCP_LISTEN:</span><br><span class="line">        <span class="keyword">if</span> (th-&gt;ack)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (th-&gt;rst)</span><br><span class="line">            <span class="keyword">goto</span> discard;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (th-&gt;fin)</span><br><span class="line">                <span class="keyword">goto</span> discard;</span><br><span class="line">            <span class="comment">// 因为我们很有可能从 backlog 中取 SYN 包处理, 这里必须关闭 BH 和 RCU</span></span><br><span class="line">            rcu_read_lock();</span><br><span class="line">            local_bh_disable();</span><br><span class="line">            <span class="comment">// 在 inet_connection_sock_af_ops 中查找对应操作</span></span><br><span class="line">            acceptable = icsk-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &gt;= <span class="number">0</span>;</span><br><span class="line">            local_bh_enable();</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!acceptable)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            consume_skb(skb);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> discard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TCP_SYN_SENT:</span><br><span class="line">        tp-&gt;rx_opt.saw_tstamp = <span class="number">0</span>;</span><br><span class="line">        tcp_mstamp_refresh(tp);</span><br><span class="line">        queued = tcp_rcv_synsent_state_process(sk, skb, th);</span><br><span class="line">        <span class="keyword">if</span> (queued &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> queued;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Do step6 onward by hand. */</span></span><br><span class="line">        tcp_urg(sk, skb, th);</span><br><span class="line">        __kfree_skb(skb);</span><br><span class="line">        tcp_data_snd_check(sk);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tcp_mstamp_refresh(tp);</span><br><span class="line">    tp-&gt;rx_opt.saw_tstamp = <span class="number">0</span>;</span><br><span class="line">    req = rcu_dereference_protected(tp-&gt;fastopen_rsk, lockdep_sock_is_held(sk));</span><br><span class="line">    <span class="keyword">if</span> (req) &#123;</span><br><span class="line">        <span class="keyword">bool</span> req_stolen;</span><br><span class="line"></span><br><span class="line">        WARN_ON_ONCE(sk-&gt;sk_state != TCP_SYN_RECV &amp;&amp; sk-&gt;sk_state != TCP_FIN_WAIT1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!tcp_check_req(sk, skb, req, <span class="literal">true</span>, &amp;req_stolen))</span><br><span class="line">            <span class="keyword">goto</span> discard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!th-&gt;ack &amp;&amp; !th-&gt;rst &amp;&amp; !th-&gt;syn)</span><br><span class="line">        <span class="keyword">goto</span> discard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tcp_validate_incoming(sk, skb, th, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* step 5: check the ACK field */</span></span><br><span class="line">    acceptable = tcp_ack(sk, skb, FLAG_SLOWPATH | FLAG_UPDATE_TS_RECENT | FLAG_NO_CHALLENGE_ACK) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!acceptable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_state == TCP_SYN_RECV)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* send one RST */</span></span><br><span class="line">        tcp_send_challenge_ack(sk, skb);</span><br><span class="line">        <span class="keyword">goto</span> discard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (sk-&gt;sk_state)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line">        tp-&gt;delivered++; <span class="comment">/* SYN-ACK delivery isn't tracked in tcp_ack */</span></span><br><span class="line">        <span class="keyword">if</span> (!tp-&gt;srtt_us)</span><br><span class="line">            tcp_synack_rtt_meas(sk, req);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req) &#123;</span><br><span class="line">            tcp_rcv_synrecv_state_fastopen(sk);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tcp_try_undo_spurious_syn(sk);</span><br><span class="line">            tp-&gt;retrans_stamp = <span class="number">0</span>;</span><br><span class="line">            tcp_init_transfer(sk, BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB);</span><br><span class="line">            WRITE_ONCE(tp-&gt;copied_seq, tp-&gt;rcv_nxt);</span><br><span class="line">        &#125;</span><br><span class="line">        smp_mb();</span><br><span class="line">        tcp_set_state(sk, TCP_ESTABLISHED);</span><br><span class="line">        sk-&gt;sk_state_change(sk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_socket)</span><br><span class="line">            sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);</span><br><span class="line"></span><br><span class="line">        tp-&gt;snd_una = TCP_SKB_CB(skb)-&gt;ack_seq;</span><br><span class="line">        tp-&gt;snd_wnd = ntohs(th-&gt;window) &lt;&lt; tp-&gt;rx_opt.snd_wscale;</span><br><span class="line">        tcp_init_wl(tp, TCP_SKB_CB(skb)-&gt;seq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;rx_opt.tstamp_ok)</span><br><span class="line">            tp-&gt;advmss -= TCPOLEN_TSTAMP_ALIGNED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!inet_csk(sk)-&gt;icsk_ca_ops-&gt;cong_control)</span><br><span class="line">            tcp_update_pacing_rate(sk);</span><br><span class="line"></span><br><span class="line">        tp-&gt;lsndtime = tcp_jiffies32;</span><br><span class="line"></span><br><span class="line">        tcp_initialize_rcv_mss(sk);</span><br><span class="line">        tcp_fast_path_on(tp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TCP_FIN_WAIT1:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req)</span><br><span class="line">            tcp_rcv_synrecv_state_fastopen(sk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;snd_una != tp-&gt;write_seq)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        tcp_set_state(sk, TCP_FIN_WAIT2);</span><br><span class="line">        sk-&gt;sk_shutdown |= SEND_SHUTDOWN;</span><br><span class="line"></span><br><span class="line">        sk_dst_confirm(sk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sock_flag(sk, SOCK_DEAD))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Wake up lingering close() */</span></span><br><span class="line">            sk-&gt;sk_state_change(sk);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;linger2 &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tcp_done(sk);</span><br><span class="line">            NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;end_seq != TCP_SKB_CB(skb)-&gt;seq &amp;&amp;</span><br><span class="line">            after(TCP_SKB_CB(skb)-&gt;end_seq - th-&gt;fin, tp-&gt;rcv_nxt))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Receive out of order FIN after close() */</span></span><br><span class="line">            <span class="keyword">if</span> (tp-&gt;syn_fastopen &amp;&amp; th-&gt;fin)</span><br><span class="line">                tcp_fastopen_active_disable(sk);</span><br><span class="line">            tcp_done(sk);</span><br><span class="line">            NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tmo = tcp_fin_time(sk);</span><br><span class="line">        <span class="keyword">if</span> (tmo &gt; TCP_TIMEWAIT_LEN)</span><br><span class="line">        &#123;</span><br><span class="line">            inet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (th-&gt;fin || sock_owned_by_user(sk))</span><br><span class="line">        &#123;</span><br><span class="line">            inet_csk_reset_keepalive_timer(sk, tmo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);</span><br><span class="line">            <span class="keyword">goto</span> discard;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TCP_CLOSING:</span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;snd_una == tp-&gt;write_seq)</span><br><span class="line">        &#123;</span><br><span class="line">            tcp_time_wait(sk, TCP_TIME_WAIT, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">goto</span> discard;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> TCP_LAST_ACK:</span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;snd_una == tp-&gt;write_seq)</span><br><span class="line">        &#123;</span><br><span class="line">            tcp_update_metrics(sk);</span><br><span class="line">            tcp_done(sk);</span><br><span class="line">            <span class="keyword">goto</span> discard;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* step 6: check the URG bit */</span></span><br><span class="line">    tcp_urg(sk, skb, th);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* step 7: process the segment text */</span></span><br><span class="line">    <span class="keyword">switch</span> (sk-&gt;sk_state)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> TCP_CLOSE_WAIT:</span><br><span class="line">    <span class="keyword">case</span> TCP_CLOSING:</span><br><span class="line">    <span class="keyword">case</span> TCP_LAST_ACK:</span><br><span class="line">        <span class="keyword">if</span> (!before(TCP_SKB_CB(skb)-&gt;seq, tp-&gt;rcv_nxt))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sk_is_mptcp(sk))</span><br><span class="line">                mptcp_incoming_options(sk, skb, &amp;tp-&gt;rx_opt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">    <span class="keyword">case</span> TCP_FIN_WAIT1:</span><br><span class="line">    <span class="keyword">case</span> TCP_FIN_WAIT2:</span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;end_seq != TCP_SKB_CB(skb)-&gt;seq &amp;&amp;</span><br><span class="line">                after(TCP_SKB_CB(skb)-&gt;end_seq - th-&gt;fin, tp-&gt;rcv_nxt))</span><br><span class="line">            &#123;</span><br><span class="line">                NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">                tcp_reset(sk);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Fall through */</span></span><br><span class="line">    <span class="keyword">case</span> TCP_ESTABLISHED:</span><br><span class="line">        tcp_data_queue(sk, skb);</span><br><span class="line">        queued = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* tcp_data could move socket to TIME-WAIT */</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE)</span><br><span class="line">    &#123;</span><br><span class="line">        tcp_data_snd_check(sk);</span><br><span class="line">        tcp_ack_snd_check(sk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queued)</span><br><span class="line">    &#123;</span><br><span class="line">    discard:</span><br><span class="line">        tcp_drop(sk, skb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_rcv_state_process);</span><br></pre></td></tr></table></figure>
<p>我们继续点进 tcp_v4_conn_request 看看，它首先会检查是否需要回复一个广播或者多播，如果都不需要，就调用 tcp_conn_request。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_conn_request</span><span class="params">(struct sock *sk, struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Never answer to SYNs send to broadcast or multicast */</span></span><br><span class="line">    <span class="keyword">if</span> (skb_rtable(skb)-&gt;rt_flags &amp; (RTCF_BROADCAST | RTCF_MULTICAST))</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tcp_conn_request(&amp;tcp_request_sock_ops, &amp;tcp_request_sock_ipv4_ops, sk, skb);</span><br><span class="line"></span><br><span class="line">drop:</span><br><span class="line">    tcp_listendrop(sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_v4_conn_request);</span><br></pre></td></tr></table></figure>
<p>然后进入 tcp_conn_request，我们先看参数，从传入的参数我们能找到它们对应的操作到底是什么：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tcp_request_sock_ops - rsk_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_sock_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> family;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> obj_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *slab_name;</span><br><span class="line">    <span class="keyword">int</span> (*rtx_syn_ack)(<span class="keyword">const</span> struct sock *sk,</span><br><span class="line">                       struct request_sock *req);</span><br><span class="line">    <span class="keyword">void</span> (*send_ack)(<span class="keyword">const</span> struct sock *sk, struct sk_buff *skb,</span><br><span class="line">                     struct request_sock *req);</span><br><span class="line">    <span class="keyword">void</span> (*send_reset)(<span class="keyword">const</span> struct sock *sk,</span><br><span class="line">                       struct sk_buff *skb);</span><br><span class="line">    <span class="keyword">void</span> (*destructor)(struct request_sock *req);</span><br><span class="line">    <span class="keyword">void</span> (*syn_ack_timeout)(<span class="keyword">const</span> struct request_sock *req);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request_sock_ops</span> <span class="title">tcp_request_sock_ops</span> __<span class="title">read_mostly</span> = &#123;</span></span><br><span class="line">    .family = PF_INET,</span><br><span class="line">    .obj_size = <span class="keyword">sizeof</span>(struct tcp_request_sock),</span><br><span class="line">    .rtx_syn_ack = tcp_rtx_synack,</span><br><span class="line">    .send_ack = tcp_v4_reqsk_send_ack,</span><br><span class="line">    .destructor = tcp_v4_reqsk_destructor,</span><br><span class="line">    .send_reset = tcp_v4_send_reset,</span><br><span class="line">    .syn_ack_timeout = tcp_syn_ack_timeout,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tcp_request_sock_ipv4_ops - af_ops</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_request_sock_ops</span> &#123;</span></span><br><span class="line">    u16 mss_clamp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TCP_MD5SIG</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_md5sig_key</span> *(*<span class="title">req_md5_lookup</span>)(<span class="title">const</span> <span class="title">struct</span> <span class="title">sock</span> *<span class="title">sk</span>,</span></span><br><span class="line"><span class="class">                                             <span class="title">const</span> <span class="title">struct</span> <span class="title">sock</span> *<span class="title">addr_sk</span>);</span></span><br><span class="line">    <span class="keyword">int</span> (*calc_md5_hash)(<span class="keyword">char</span> *location,</span><br><span class="line">                         <span class="keyword">const</span> struct tcp_md5sig_key *md5,</span><br><span class="line">                         <span class="keyword">const</span> struct sock *sk,</span><br><span class="line">                         <span class="keyword">const</span> struct sk_buff *skb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">void</span> (*init_req)(struct request_sock *req,</span><br><span class="line">                     <span class="keyword">const</span> struct sock *sk_listener,</span><br><span class="line">                     struct sk_buff *skb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYN_COOKIES</span></span><br><span class="line">    __u32 (*cookie_init_seq)(<span class="keyword">const</span> struct sk_buff *skb, __u16 *mss);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *(*<span class="title">route_req</span>)(<span class="title">const</span> <span class="title">struct</span> <span class="title">sock</span> *<span class="title">sk</span>, <span class="title">struct</span> <span class="title">flowi</span> *<span class="title">fl</span>,</span></span><br><span class="line"><span class="class">                                   <span class="title">const</span> <span class="title">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>);</span></span><br><span class="line">    u32 (*init_seq)(<span class="keyword">const</span> struct sk_buff *skb);</span><br><span class="line">    u32 (*init_ts_off)(<span class="keyword">const</span> struct net *net, <span class="keyword">const</span> struct sk_buff *skb);</span><br><span class="line">    <span class="keyword">int</span> (*send_synack)(<span class="keyword">const</span> struct sock *sk, struct dst_entry *dst,</span><br><span class="line">                       struct flowi *fl, struct request_sock *req,</span><br><span class="line">                       struct tcp_fastopen_cookie *foc,</span><br><span class="line">                       <span class="keyword">enum</span> tcp_synack_type synack_type);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_request_sock_ops</span> <span class="title">tcp_request_sock_ipv4_ops</span> = &#123;</span></span><br><span class="line">    .mss_clamp = TCP_MSS_DEFAULT,</span><br><span class="line">#ifdef CONFIG_TCP_MD5SIG</span><br><span class="line">    .req_md5_lookup = tcp_v4_md5_lookup,</span><br><span class="line">    .calc_md5_hash = tcp_v4_md5_hash_skb,</span><br><span class="line">#endif</span><br><span class="line">    .init_req = tcp_v4_init_req,</span><br><span class="line">#ifdef CONFIG_SYN_COOKIES</span><br><span class="line">    .cookie_init_seq = cookie_v4_init_sequence,</span><br><span class="line">#endif</span><br><span class="line">    .route_req = tcp_v4_route_req,</span><br><span class="line">    .init_seq = tcp_v4_init_seq,</span><br><span class="line">    .init_ts_off = tcp_v4_init_ts_off,</span><br><span class="line">    .send_synack = tcp_v4_send_synack,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回到 tcp_conn_request，在里面对 SYN-ACK 包进行了初始化、路由、最后调用 tcp_v4_send_synack 发送，需要注意，服务端回复了 SYN-ACK 之后就处于 TCP_SYN_RECV 状态了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_conn_request</span><span class="params">(struct request_sock_ops *rsk_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> struct tcp_request_sock_ops *af_ops,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct sock *sk, struct sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_fastopen_cookie</span> <span class="title">foc</span> = &#123;</span>.len = <span class="number">-1</span>&#125;;</span><br><span class="line">    __u32 isn = TCP_SKB_CB(skb)-&gt;tcp_tw_isn;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_options_received</span> <span class="title">tmp_opt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">fastopen_sk</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// struct request_sock 用于表示一个连接请求的 sock 结构, 可以理解为 tcp_request_sock 的父类</span></span><br><span class="line">    <span class="comment">// 具体的嵌套为 request_sock - inet_request_sock - tcp_request_sock</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> want_cookie = <span class="literal">false</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *<span class="title">dst</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flowi</span> <span class="title">fl</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((net-&gt;ipv4.sysctl_tcp_syncookies == <span class="number">2</span> || inet_csk_reqsk_queue_is_full(sk)) &amp;&amp; !isn) &#123;</span><br><span class="line">        want_cookie = tcp_syn_flood_action(sk, rsk_ops-&gt;slab_name);</span><br><span class="line">        <span class="keyword">if</span> (!want_cookie)</span><br><span class="line">            <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk_acceptq_is_full(sk)) &#123;</span><br><span class="line">        NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为一个 struct request_sock 分配空间</span></span><br><span class="line">    req = inet_reqsk_alloc(rsk_ops, sk, !want_cookie);</span><br><span class="line">    <span class="keyword">if</span> (!req)</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 struct tcp_request_sock 对应的操作为 tcp_request_sock_ops</span></span><br><span class="line">    tcp_rsk(req)-&gt;af_specific = af_ops;</span><br><span class="line">    tcp_rsk(req)-&gt;ts_off = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_MPTCP)</span></span><br><span class="line">    tcp_rsk(req)-&gt;is_mptcp = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    tcp_clear_options(&amp;tmp_opt);</span><br><span class="line">    tmp_opt.mss_clamp = af_ops-&gt;mss_clamp;</span><br><span class="line">    tmp_opt.user_mss = tp-&gt;rx_opt.user_mss;</span><br><span class="line">    tcp_parse_options(sock_net(sk), skb, &amp;tmp_opt, <span class="number">0</span>, want_cookie ? <span class="literal">NULL</span> : &amp;foc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (want_cookie &amp;&amp; !tmp_opt.saw_tstamp)</span><br><span class="line">        tcp_clear_options(&amp;tmp_opt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ENABLED(CONFIG_SMC) &amp;&amp; want_cookie)</span><br><span class="line">        tmp_opt.smc_ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    tmp_opt.tstamp_ok = tmp_opt.saw_tstamp;</span><br><span class="line">    tcp_openreq_init(req, &amp;tmp_opt, skb, sk);</span><br><span class="line">    inet_rsk(req)-&gt;no_srccheck = inet_sk(sk)-&gt;transparent;</span><br><span class="line"></span><br><span class="line">    inet_rsk(req)-&gt;ir_iif = inet_request_bound_dev_if(sk, skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 tcp_v4_init_req 初始化 SYN-ACK 的响应包</span></span><br><span class="line">    af_ops-&gt;init_req(req, sk, skb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ENABLED(CONFIG_MPTCP) &amp;&amp; want_cookie)</span><br><span class="line">        tcp_rsk(req)-&gt;is_mptcp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security_inet_conn_request(sk, skb, req))</span><br><span class="line">        <span class="keyword">goto</span> drop_and_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tmp_opt.tstamp_ok)</span><br><span class="line">        tcp_rsk(req)-&gt;ts_off = af_ops-&gt;init_ts_off(net, skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 tcp_v4_route_req 进行路由</span></span><br><span class="line">    dst = af_ops-&gt;route_req(sk, &amp;fl, req);</span><br><span class="line">    <span class="keyword">if</span> (!dst)</span><br><span class="line">        <span class="keyword">goto</span> drop_and_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!want_cookie &amp;&amp; !isn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!net-&gt;ipv4.sysctl_tcp_syncookies &amp;&amp;</span><br><span class="line">            (net-&gt;ipv4.sysctl_max_syn_backlog - inet_csk_reqsk_queue_len(sk) &lt;</span><br><span class="line">             (net-&gt;ipv4.sysctl_max_syn_backlog &gt;&gt; <span class="number">2</span>)) &amp;&amp;</span><br><span class="line">            !tcp_peer_is_proven(req, dst)) &#123;</span><br><span class="line">            pr_drop_req(req, ntohs(tcp_hdr(skb)-&gt;source), rsk_ops-&gt;family);</span><br><span class="line">            <span class="keyword">goto</span> drop_and_release;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isn = af_ops-&gt;init_seq(skb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tcp_ecn_create_request(req, skb, sk, dst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (want_cookie) &#123;</span><br><span class="line">        isn = cookie_init_sequence(af_ops, sk, skb, &amp;req-&gt;mss);</span><br><span class="line">        req-&gt;cookie_ts = tmp_opt.tstamp_ok;</span><br><span class="line">        <span class="keyword">if</span> (!tmp_opt.tstamp_ok)</span><br><span class="line">            inet_rsk(req)-&gt;ecn_ok = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tcp_rsk(req)-&gt;snt_isn = isn;</span><br><span class="line">    tcp_rsk(req)-&gt;txhash = net_tx_rndhash();</span><br><span class="line">    tcp_openreq_init_rwin(req, sk, dst);</span><br><span class="line">    sk_rx_queue_set(req_to_sk(req), skb);</span><br><span class="line">    <span class="keyword">if</span> (!want_cookie) &#123;</span><br><span class="line">        tcp_reqsk_record_syn(sk, req, skb);</span><br><span class="line">        fastopen_sk = tcp_try_fastopen(sk, skb, req, &amp;foc, dst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fastopen_sk) &#123;</span><br><span class="line">        af_ops-&gt;send_synack(fastopen_sk, dst, &amp;fl, req,</span><br><span class="line">                            &amp;foc, TCP_SYNACK_FASTOPEN);</span><br><span class="line">        <span class="comment">/* Add the child socket directly into the accept queue */</span></span><br><span class="line">        <span class="keyword">if</span> (!inet_csk_reqsk_queue_add(sk, req, fastopen_sk)) &#123;</span><br><span class="line">            reqsk_fastopen_remove(fastopen_sk, req, <span class="literal">false</span>);</span><br><span class="line">            bh_unlock_sock(fastopen_sk);</span><br><span class="line">            sock_put(fastopen_sk);</span><br><span class="line">            <span class="keyword">goto</span> drop_and_free;</span><br><span class="line">        &#125;</span><br><span class="line">        sk-&gt;sk_data_ready(sk);</span><br><span class="line">        bh_unlock_sock(fastopen_sk);</span><br><span class="line">        sock_put(fastopen_sk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tcp_rsk(req)-&gt;tfo_listener = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!want_cookie)</span><br><span class="line">            inet_csk_reqsk_queue_hash_add(sk, req, tcp_timeout_init((struct sock *)req));</span><br><span class="line">        <span class="comment">// 调用 tcp_v4_send_synack 发送 synack</span></span><br><span class="line">        af_ops-&gt;send_synack(sk, dst, &amp;fl, req, &amp;foc,</span><br><span class="line">                            !want_cookie ? TCP_SYNACK_NORMAL : TCP_SYNACK_COOKIE);</span><br><span class="line">        <span class="keyword">if</span> (want_cookie) &#123;</span><br><span class="line">            reqsk_free(req);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reqsk_put(req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">drop_and_release:</span><br><span class="line">    dst_release(dst);</span><br><span class="line">drop_and_free:</span><br><span class="line">    __reqsk_free(req);</span><br><span class="line">drop:</span><br><span class="line">    tcp_listendrop(sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_conn_request);</span><br></pre></td></tr></table></figure>
<p>这里我们仍然忽略网络包发送的底层过程，假设这个 SYN-ACK 成功发送了，那么现在又回到了客户端收包的状态，还记得前面服务端收包的时候调用的 tcp_rcv_state_process 吗，客户端这里依然会调用这个函数，只是客户端走的是 TCP_SYN_SENT 这个流程了，会进入 tcp_rcv_synsent_state_process 函数，该函数中会调用 tcp_send_ack，最后调用 tcp_transmit_skb 发出这个 ACK-ACK，发送之后的客户端进入了 TCP_ESTABLISHED 状态。<br>
服务端收到网络包后仍然会进入 tcp_rcv_state_process 函数，因为服务端此时处于 TCP_SYN_RECV 状态，它走对应的分支最后也会处于 TCP_ESTABLISHED 状态，三次握手结束。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux-Kernel</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析 Linux 内核：链表的实现</title>
    <url>/posts/e0e3a2af/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>相信阅读过 Linux 源码的朋友都发现了一个内核中奇怪的写法，普通的链表是在数据结构中嵌入该结构的指针，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而 Linux 内核中是将链表结点切嵌入数据结构中，该结构定义在 <code>/include/linux/types.h</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个需要用链表连接的结构里面都会包含这样一个成员对象，这些结构的相连其实就是 <code>struct list_head</code> 的相连，那么通过链表结点找到所属的结构就需要通过下面的转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_entry 宏用于获取链表项对应的结构</span></span><br><span class="line"><span class="comment"> * @ptr: struct list_head 类型的指针</span></span><br><span class="line"><span class="comment"> * @type: struct list_head 所嵌入的结构的类型</span></span><br><span class="line"><span class="comment"> * @member: 该结构中 struct list_head 的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line">    container_of(ptr, type, member)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * container_of 宏能够通过一个成员变量转换出包含它的结构体</span></span><br><span class="line"><span class="comment"> * @ptr: 结构体成员的指针</span></span><br><span class="line"><span class="comment"> * @type: 结构体成员所嵌入的结构的类型</span></span><br><span class="line"><span class="comment"> * @member: 该结构中对应结构体成员的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;  \</span></span><br><span class="line">    <span class="keyword">void</span> *__mptr = (<span class="keyword">void</span> *)(ptr);           \</span><br><span class="line">    BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)<span class="number">0</span>)-&gt;member) &amp;&amp; \</span><br><span class="line">        !__same_type(*(ptr), <span class="keyword">void</span>), <span class="string">"pointer type mismatch in container_of()"</span>); \</span><br><span class="line">    ((type *)(__mptr - offsetof(type, member))); &#125;)</span><br></pre></td></tr></table></figure>
<p>不难看出，使用 <code>container_of</code> 宏能够取出链表指针的父结构，我们逐个来分析。<br>
这里我们就假设 <code>container_of</code> 中的 ptr 就是 struct list_head 类型的指针，首先该 ptr 会被强制转换为 void 类型的指针并赋值给 __mptr。<br>
<code>BUILD_BUG_ON_MSG</code> 这个宏会在参数 condition 为 true 的时候报错并停止编译同时输出错误信息，这里可以看出该宏检查的是我们作为参数传入指针类型与我们想要取出的结构中对应的类型是否匹配。<br>
ANSI C 标准允许常量 0 值被强制转换为任何一种类型的指针，<code>((type *)0)</code> 就是一个类型为 type 的 NULL 指针，如果用这个指针来取 type 中的成员变量 member 是非法操作，但是我们打开 <code>__same_type</code> 的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))</span></span><br></pre></td></tr></table></figure>
<p>可以看出它其实只是取该结构中对应 member 的类型 <code>typeof(((type *)0)-&gt;member)</code>，<strong>typeof 中的参数部分是不会生成代码也不会执行的</strong>。<br>
再看 <code>offsetof</code>，它也是使用了同样的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER)    ((size_t)&amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<p><code>&amp;((TYPE *)0)-&gt;MEMBER)</code> 能够取出数据成员的偏移地址，然后用 __mptr 减去这个偏移地址，就能得到这个链表所在结构的首地址，最后将其强制转换为 type 类型的指针，就得到了 struct list_head 所嵌入的结构体指针。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linked-List</tag>
        <tag>Linux</tag>
        <tag>Linux-Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析 Linux 内核：Socket 的创建与相关系统调用的实现</title>
    <url>/posts/89581d24/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>五一在家花了两天时间将 Linux 网络系统中的源码看了个大概，在此总结，以免遗忘。相比于 UDP，TCP 的三次握手是在内核中完成的，代码会比 UDP 更加复杂，在这里我们就只分析 TCP，UDP 的如果后面有时间再更新。<br>
那么就按照最基础的网络编程的过程来一步步分析，分别是 “创建 socket”、“绑定端口 bind”、“监听端口 listen”、“客户端连接 connect”、“服务端取出连接 accept” 五个部分。<br>
客户端连接 connect 涉及了三次握手的过程，为了减少篇幅，单独将这个部分提出来放在下一篇讲述。<br>
内核代码用的是 Linux v5.6.10，<a href="https://elixir.bootlin.com/linux/latest/source" target="_blank" rel="noopener">代码在线地址</a></p>
<h2 id="创建-socket">创建 socket</h2>
<p>socket 系统调用的代码位于 <code>/net/socket.c</code> 中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(socket, <span class="keyword">int</span>, family, <span class="keyword">int</span>, type, <span class="keyword">int</span>, protocol) &#123;</span><br><span class="line">    <span class="keyword">return</span> __sys_socket(family, type, protocol);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码其实只是调用了 <code>__sys_socket</code>，之所以要这样包装一下，是为了解决在 64 位系统中，原先的 32 位参数存放在 64 位寄存器中会出现符号扩展出错的情况，导致系统漏洞，现在的做法其实就是将系统调用的参数统一使用 long 类型接收，再强制转换为 int，Linux 内核中还有很多这种类似的修修补补，以后有机会我们都能看到。<br>
下面我们来看在 <code>__sys_socket</code> 中做了些什么：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @family: 协议族, AF_INET/AF_UNIX</span></span><br><span class="line"><span class="comment"> * @type: 通信类型, SOCK_STREAM/SOCK_DGRAM/SOCK_RAW</span></span><br><span class="line"><span class="comment"> * @protocol: 通信协议, 现在基本已经废弃, 因为协议已经通过上面两个参数指定了, 一般写为 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> __sys_socket(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol) &#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BUILD_BUG_ON 在后面参数为 true 的时候编译错误, 是一种静态检查机制</span></span><br><span class="line">    BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);</span><br><span class="line">    BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);</span><br><span class="line">    BUILD_BUG_ON(SOCK_CLOEXEC &amp; SOCK_TYPE_MASK);</span><br><span class="line">    BUILD_BUG_ON(SOCK_NONBLOCK &amp; SOCK_TYPE_MASK);</span><br><span class="line"></span><br><span class="line">    flags = type &amp; ~SOCK_TYPE_MASK;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    type &amp;= SOCK_TYPE_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))</span><br><span class="line">        flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    retval = sock_create(family, type, protocol, &amp;sock);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之所以 sock_create 参数需要使用 struct socket** res</span></span><br><span class="line">    <span class="comment">// 因为 sock_map_fd 需要使用修改后的 struct socket 指针</span></span><br><span class="line">    <span class="keyword">return</span> sock_map_fd(sock, flags &amp; (O_CLOEXEC | O_NONBLOCK));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数中首先创建了一个 <code>struct socket</code>，然后经过一系列的参数检查，最终到达两个重要的函数：<br>
第一个 <code>sock_create</code>，它会创造一个 <code>struct socket</code> 结构放在前面构造的 <code>sock</code> 变量中；<br>
第二个 <code>sock_map_fd</code>，它会将文件描述符和这个 <code>struct socket</code> 对应起来，然后返回 socket 对应的文件描述符。<br>
点进 <code>sock_create</code>，发现它又是一个 wrapper，注意这个参数 res 是一个二重指针，因为我们在外层是用指针来接这个新建的 socket，要修改并保存指针的值，就要使用指针的地址才行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_create</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, struct socket **res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __sock_create(current-&gt;nsproxy-&gt;net_ns, family, type, protocol, res, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(sock_create);</span><br></pre></td></tr></table></figure>
<p>进入 <code>__sock_create</code>，这个函数用于真正创建一个新的 socket，并且将它赋值给参数 res：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @net: net namespace</span></span><br><span class="line"><span class="comment"> * @family: protocol family (AF_INET, ...)</span></span><br><span class="line"><span class="comment"> * @type: communication type (SOCK_STREAM, ...)</span></span><br><span class="line"><span class="comment"> * @protocol: protocol (0, ...)</span></span><br><span class="line"><span class="comment"> * @res: new socket</span></span><br><span class="line"><span class="comment"> * @kern: boolean for kernel space sockets</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> __sock_create(struct net *net, <span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, struct socket **res, <span class="keyword">int</span> kern) &#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="comment">// 用于保存从 net_families 数组中取出的指定协议的协议族</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> *<span class="title">pf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 family 和 type 参数是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (family &lt; <span class="number">0</span> || family &gt;= NPROTO)</span><br><span class="line">        <span class="keyword">return</span> -EAFNOSUPPORT;</span><br><span class="line">    <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt;= SOCK_MAX)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (family == PF_INET &amp;&amp; type == SOCK_PACKET) &#123;</span><br><span class="line">        pr_info_once(<span class="string">"%s uses obsolete (PF_INET,SOCK_PACKET)\n"</span>, current-&gt;comm);</span><br><span class="line">        family = PF_PACKET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = security_socket_create(family, type, protocol, kern);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配了一个新的 inode 结点与 socket 对象给 sock</span></span><br><span class="line">    sock = sock_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!sock) &#123;</span><br><span class="line">        net_warn_ratelimited(<span class="string">"socket: no more sockets\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENFILE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock-&gt;type = type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">    <span class="keyword">if</span> (rcu_access_pointer(net_families[family]) == <span class="literal">NULL</span>)</span><br><span class="line">        request_module(<span class="string">"net-pf-%d"</span>, family);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="comment">// 从 net_families[family] 中取出 family 对应的 struct net_proto_family 保存在 pf 中</span></span><br><span class="line">    <span class="comment">// 后面我们需要调用 pf-&gt;create 来创建 socket</span></span><br><span class="line">    pf = rcu_dereference(net_families[family]);</span><br><span class="line">    err = -EAFNOSUPPORT;</span><br><span class="line">    <span class="keyword">if</span> (!pf)</span><br><span class="line">        <span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们需要调用 -&gt;create 函数, 它位于一个可加载模块中, 因此必须先更改可加载模块的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (!try_module_get(pf-&gt;owner))</span><br><span class="line">        <span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 中调用的其实是 inet_create</span></span><br><span class="line">    err = pf-&gt;create(net, sock, protocol, kern);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_module_put;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!try_module_get(sock-&gt;ops-&gt;owner))</span><br><span class="line">        <span class="keyword">goto</span> out_module_busy;</span><br><span class="line"></span><br><span class="line">    module_put(pf-&gt;owner);</span><br><span class="line">    err = security_socket_post_create(sock, family, type, protocol, kern);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out_sock_release;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改传入的 res 地址中的值为 sock</span></span><br><span class="line">    *res = sock;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_module_busy:</span><br><span class="line">    err = -EAFNOSUPPORT;</span><br><span class="line">out_module_put:</span><br><span class="line">    sock-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">    module_put(pf-&gt;owner);</span><br><span class="line">out_sock_release:</span><br><span class="line">    sock_release(sock);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">out_release:</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">goto</span> out_sock_release;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__sock_create);</span><br></pre></td></tr></table></figure>
<p>首先我们看 struct socket 的定义，这个 ops 需要我们找到 family、type、protocol 三者都符合的协议操作进行更新。每个 struct socket 向下也都会对应一个 struct sock，它用于处理底层的网络协议栈，<strong>这个 struct sock，我们称之为传输控制块，它是协议无关的</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  struct socket - general BSD socket</span></span><br><span class="line"><span class="comment"> *  @state: socket 所处状态 SS_CONNECTED 等</span></span><br><span class="line"><span class="comment"> *  @type: socket 类型 SOCK_STREAM 等</span></span><br><span class="line"><span class="comment"> *  @flags: socket 标志位 SOCK_NOSPACE 等</span></span><br><span class="line"><span class="comment"> *  @ops: 协议指定的 socket 操作</span></span><br><span class="line"><span class="comment"> *  @file: 文件返回指针</span></span><br><span class="line"><span class="comment"> *  @sk: 内部网络协议的 socket 表示</span></span><br><span class="line"><span class="comment"> *  @wq: 等待队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">    socket_state state;</span><br><span class="line">    short type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span> <span class="title">wq</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们看 <code>net_families</code> 数组的定义，它位于 <code>/net/socket.c</code> 的起始位置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> family;</span><br><span class="line">    <span class="keyword">int</span> (*create)(struct net *net, struct socket *sock, <span class="keyword">int</span> protocol, <span class="keyword">int</span> kern);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> __<span class="title">rcu</span> *<span class="title">net_families</span>[<span class="title">NPROTO</span>] __<span class="title">read_mostly</span>;</span></span><br></pre></td></tr></table></figure>
<p>不难看出，它其实就是一个 <code>struct net_proto_family *</code> 类型的数组，数组的下标就是 family 协议族参数，也就是说，每一种协议其实都正好对应了一个 <code>struct net_proto_family</code>，以 <code>/net/ipv4/af_inet.c</code> 中的 <code>inet_family_ops</code> 为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> = &#123;</span></span><br><span class="line">    .family = PF_INET,</span><br><span class="line">    <span class="comment">// 这里将 IPv4 协议族中创建 socket 的函数设置为 inet_create</span></span><br><span class="line">    .create = inet_create,</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来看 <code>inet_create</code> 的实现，它位于 <code>/net/ipv4/af_inet.c</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @net: net namespace</span></span><br><span class="line"><span class="comment"> * @sock: 这个 sock 是新建的 struct socket 类型指针</span></span><br><span class="line"><span class="comment"> * @protocol: protocol (0, ...)</span></span><br><span class="line"><span class="comment"> * @kern: boolean for kernel space sockets</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_create</span><span class="params">(struct net *net, struct socket *sock, <span class="keyword">int</span> protocol, <span class="keyword">int</span> kern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意这个 struct sock 需要和 struct socket 区分</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line">    <span class="comment">// 这个 answer 指向的就是 family type protocol 都符合的 struct inet_protosw</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span>;</span></span><br><span class="line">    <span class="comment">// 这个 answer_prot 用于保存内核网络协议栈的 socket 操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">answer_prot</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> answer_flags;</span><br><span class="line">    <span class="keyword">int</span> try_loading_module = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocol &lt; <span class="number">0</span> || protocol &gt;= IPPROTO_MAX)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 socket 的状态应该是 SS_UNCONNECTED</span></span><br><span class="line">    sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找所需的类型/协议对</span></span><br><span class="line">lookup_protocol:</span><br><span class="line">    err = -ESOCKTNOSUPPORT;</span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="comment">// inetsw 数组下标为 type</span></span><br><span class="line">    list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line">        err = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line">            <span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">                protocol = answer-&gt;protocol;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        err = -EPROTONOSUPPORT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (try_loading_module &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (++try_loading_module == <span class="number">1</span>)</span><br><span class="line">                request_module(<span class="string">"net-pf-%d-proto-%d-type-%d"</span>, PF_INET, protocol, sock-&gt;type);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                request_module(<span class="string">"net-pf-%d-proto-%d"</span>, PF_INET, protocol);</span><br><span class="line">            <span class="keyword">goto</span> lookup_protocol;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">goto</span> out_rcu_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (sock-&gt;type == SOCK_RAW &amp;&amp; !kern &amp;&amp; !ns_capable(net-&gt;user_ns, CAP_NET_RAW))</span><br><span class="line">        <span class="keyword">goto</span> out_rcu_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改新建的 struct socket 的 ops 为 answer-&gt;ops</span></span><br><span class="line">    sock-&gt;ops = answer-&gt;ops;</span><br><span class="line">    <span class="comment">// 取出 answer 的协议块与 flags</span></span><br><span class="line">    answer_prot = answer-&gt;prot;</span><br><span class="line">    answer_flags = answer-&gt;flags;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    WARN_ON(!answer_prot-&gt;slab);</span><br><span class="line"></span><br><span class="line">    err = -ENOBUFS;</span><br><span class="line">    <span class="comment">// 分配一个 struct sock, 新建 struct sock 的时候需要指定使用的协议族与协议块</span></span><br><span class="line">    <span class="comment">// sk-&gt;sk_family = family(PF_INET)</span></span><br><span class="line">    <span class="comment">// sk-&gt;sk_prot = prot(answer_prot)</span></span><br><span class="line">    sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern);</span><br><span class="line">    <span class="keyword">if</span> (!sk)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (INET_PROTOSW_REUSE &amp; answer_flags)</span><br><span class="line">        sk-&gt;sk_reuse = SK_CAN_REUSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 struct sk* 强制转换为 struct inet_sock*</span></span><br><span class="line">    <span class="comment">// 后面的代码都是填充这个 TCP 协议对应的 struct inet_sock, 不再分析</span></span><br><span class="line">    inet = inet_sk(sk);</span><br><span class="line">    inet-&gt;is_icsk = (INET_PROTOSW_ICSK &amp; answer_flags) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    inet-&gt;nodefrag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SOCK_RAW == sock-&gt;type) &#123;</span><br><span class="line">        inet-&gt;inet_num = protocol;</span><br><span class="line">        <span class="keyword">if</span> (IPPROTO_RAW == protocol)</span><br><span class="line">            inet-&gt;hdrincl = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (net-&gt;ipv4.sysctl_ip_no_pmtu_disc)</span><br><span class="line">        inet-&gt;pmtudisc = IP_PMTUDISC_DONT;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        inet-&gt;pmtudisc = IP_PMTUDISC_WANT;</span><br><span class="line"></span><br><span class="line">    inet-&gt;inet_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sock_init_data(sock, sk);</span><br><span class="line"></span><br><span class="line">    sk-&gt;sk_destruct = inet_sock_destruct;</span><br><span class="line">    sk-&gt;sk_protocol = protocol;</span><br><span class="line">    sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv;</span><br><span class="line"></span><br><span class="line">    inet-&gt;uc_ttl = <span class="number">-1</span>;</span><br><span class="line">    inet-&gt;mc_loop = <span class="number">1</span>;</span><br><span class="line">    inet-&gt;mc_ttl = <span class="number">1</span>;</span><br><span class="line">    inet-&gt;mc_all = <span class="number">1</span>;</span><br><span class="line">    inet-&gt;mc_index = <span class="number">0</span>;</span><br><span class="line">    inet-&gt;mc_list = <span class="literal">NULL</span>;</span><br><span class="line">    inet-&gt;rcv_tos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sk_refcnt_debug_inc(sk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inet-&gt;inet_num) &#123;</span><br><span class="line">        inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line">        err = sk-&gt;sk_prot-&gt;hash(sk);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            sk_common_release(sk);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_prot-&gt;init) &#123;</span><br><span class="line">        err = sk-&gt;sk_prot-&gt;init(sk);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            sk_common_release(sk);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kern) &#123;</span><br><span class="line">        err = BPF_CGROUP_RUN_PROG_INET_SOCK(sk);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            sk_common_release(sk);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">out_rcu_unlock:</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inet_create</code> 中首先创建了一个 <code>struct sock</code>，这个结构体非常复杂，它是 socket 的网络层表示，主要负责向下对接内核网络协议栈，而 <code>struct socket</code> 是传输层的结构，主要负责向上为用户服务。<br>
接着创建了一个 <code>struct inet_protosw</code> 类型的指针 answer，这个结构体用于注册 IP 协议的套接字接口，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个成员变量构成了查找用的 key</span></span><br><span class="line">    <span class="comment">// type 是 socket 的第二个参数</span></span><br><span class="line">    <span class="keyword">unsigned</span> short type;</span><br><span class="line">    <span class="keyword">unsigned</span> short protocol;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proto</span> *<span class="title">prot</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们看 <code>list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], list)</code> 这个循环。<br>
首先要弄明白 <code>inetsw[]</code> 这个数组是什么，从下面 <code>inet_init</code> 函数中的操作能够看出，inetsw 数组一开始是一个 <code>struct list_head</code> 类型的数组，这里用到了链表，是因为一个 type 可能对应多个 procotol。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">inetsw</span>[<span class="title">SOCK_MAX</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 inetsw 数组中的每一个元素都初始化为链表头节点</span></span><br><span class="line"><span class="keyword">for</span> (r = &amp;inetsw[<span class="number">0</span>]; r &lt; &amp;inetsw[SOCK_MAX]; ++r)</span><br><span class="line">    INIT_LIST_HEAD(r);</span><br></pre></td></tr></table></figure>
<p>接着在 <code>inet_init</code> 函数中将数组 <code>inetsw_array</code> 注册到数组 <code>inetsw</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inetsw_array 数组的每一项都对应不同 type/protocol 的 struct inet_protosw</span></span><br><span class="line"><span class="comment">// 启动时我们将 inetsw_array[] 中的所有元素插入到链表 inetsw[] 中</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .type = SOCK_STREAM,</span><br><span class="line">        .protocol = IPPROTO_TCP,</span><br><span class="line">        .prot = &amp;tcp_prot,</span><br><span class="line">        .ops = &amp;inet_stream_ops,</span><br><span class="line">        .flags = INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .type = SOCK_DGRAM,</span><br><span class="line">        .protocol = IPPROTO_UDP,</span><br><span class="line">        .prot = &amp;udp_prot,</span><br><span class="line">        .ops = &amp;inet_dgram_ops,</span><br><span class="line">        .flags = INET_PROTOSW_PERMANENT,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .type = SOCK_DGRAM,</span><br><span class="line">        .protocol = IPPROTO_ICMP,</span><br><span class="line">        .prot = &amp;ping_prot,</span><br><span class="line">        .ops = &amp;inet_sockraw_ops,</span><br><span class="line">        .flags = INET_PROTOSW_REUSE,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .type = SOCK_RAW,</span><br><span class="line">        .protocol = IPPROTO_IP,</span><br><span class="line">        .prot = &amp;raw_prot,</span><br><span class="line">        .ops = &amp;inet_sockraw_ops,</span><br><span class="line">        .flags = INET_PROTOSW_REUSE,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</span><br><span class="line">    inet_register_protosw(q);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inet_register_protosw</span><span class="params">(struct inet_protosw *p)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">lh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">answer</span>;</span></span><br><span class="line">    <span class="comment">// 取出当前 struct inet_protosw 的 protocol</span></span><br><span class="line">    <span class="keyword">int</span> protocol = p-&gt;protocol;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">last_perm</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock_bh(&amp;inetsw_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下标越界 error</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;type &gt;= SOCK_MAX)</span><br><span class="line">        <span class="keyword">goto</span> out_illegal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 p-&gt;type 找到与 struct inet_protosw 下标对应的 inetsw[]</span></span><br><span class="line">    last_perm = &amp;inetsw[p-&gt;type];</span><br><span class="line">    <span class="comment">// #define list_for_each(pos, head) \</span></span><br><span class="line">    <span class="comment">// for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br><span class="line">    <span class="comment">// 一直循环找到最后一项, 然后将 &amp;p-&gt;list 挂上</span></span><br><span class="line">    list_for_each(lh, &amp;inetsw[p-&gt;type]) &#123;</span><br><span class="line">        <span class="comment">// list_entry 用于获取该链表项的结构</span></span><br><span class="line">        answer = list_entry(lh, struct inet_protosw, <span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">if</span> ((INET_PROTOSW_PERMANENT &amp; answer-&gt;flags) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (protocol == answer-&gt;protocol)</span><br><span class="line">            <span class="keyword">goto</span> out_permanent;</span><br><span class="line">        last_perm = lh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// last_perm-&gt;next = &amp;p-&gt;list</span></span><br><span class="line">    list_add_rcu(&amp;p-&gt;<span class="built_in">list</span>, last_perm);</span><br><span class="line">out:</span><br><span class="line">    spin_unlock_bh(&amp;inetsw_lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">out_permanent:</span><br><span class="line">    pr_err(<span class="string">"Attempt to override permanent protocol %d\n"</span>, protocol);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">out_illegal:</span><br><span class="line">    pr_err(<span class="string">"Ignoring attempt to register invalid socket type %d\n"</span>, p-&gt;type);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(inet_register_protosw);</span><br></pre></td></tr></table></figure>
<p>回到 <code>list_for_each_entry_rcu</code> 循环，这时候就很容易理解了，它其实是根据我们指定的类型 sock-&gt;type，在 inetsw 数组（每个元素都是一个链表）对应的 <code>inetsw[sock-&gt;type]</code> 链表中查找每一个 <code>struct inet_protosw</code> 中的 protocol 是否是用户指定的 protocol，如果是的话，我们就找到了与用户指定 protocol。<br>
到了这里，首先我们使用的 create 函数 <code>inet_create</code> 是与 family 对应的，然后选择的 struct inet_protosw 是与 type 对应的，最后在与 type 对应的链表中找到与 protocol 对应的那个 <code>struct inet_protosw *answer</code>。<br>
接下来，我们需要根据选出的 answer 来更新新建的 socket 的操作，从上面 struct inet_protosw 就能够看出，以 TCP 为例，answer 对应的 ops 为 inet_stream_ops，后面针对这个 socket 的所有操作使用的都是 inet_stream_ops。</p>
<p>inet_stream_ops 定义在 <code>/net/ipv4/af_inet.c</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_stream_ops</span> = &#123;</span></span><br><span class="line">    .family = PF_INET,</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .<span class="built_in">release</span> = inet_release,</span><br><span class="line">    .bind = inet_bind,</span><br><span class="line">    .<span class="built_in">connect</span> = inet_stream_connect,</span><br><span class="line">    .socketpair = sock_no_socketpair,</span><br><span class="line">    .accept = inet_accept,</span><br><span class="line">    .getname = inet_getname,</span><br><span class="line">    .poll = tcp_poll,</span><br><span class="line">    .ioctl = inet_ioctl,</span><br><span class="line">    .gettstamp = sock_gettstamp,</span><br><span class="line">    .<span class="built_in">listen</span> = inet_listen,</span><br><span class="line">    .<span class="built_in">shutdown</span> = inet_shutdown,</span><br><span class="line">    .setsockopt = sock_common_setsockopt,</span><br><span class="line">    .getsockopt = sock_common_getsockopt,</span><br><span class="line">    .sendmsg = inet_sendmsg,</span><br><span class="line">    .recvmsg = inet_recvmsg,</span><br><span class="line">#ifdef CONFIG_MMU</span><br><span class="line">    .mmap = tcp_mmap,</span><br><span class="line">#endif</span><br><span class="line">    .sendpage = inet_sendpage,</span><br><span class="line">    .splice_read = tcp_splice_read,</span><br><span class="line">    .read_sock = tcp_read_sock,</span><br><span class="line">    .sendmsg_locked = tcp_sendmsg_locked,</span><br><span class="line">    .sendpage_locked = tcp_sendpage_locked,</span><br><span class="line">    .peek_len = tcp_peek_len,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    .compat_setsockopt = compat_sock_common_setsockopt,</span><br><span class="line">    .compat_getsockopt = compat_sock_common_getsockopt,</span><br><span class="line">    .compat_ioctl = inet_compat_ioctl,</span><br><span class="line">#endif</span><br><span class="line">    .set_rcvlowat = tcp_set_rcvlowat,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(inet_stream_ops);</span><br></pre></td></tr></table></figure>
<p>接着又出现了一个新的结构 <code>struct proto</code>，它定义在 <code>/include/net/sock.h</code> 中，是附加在 socket 中的网络层协议块，是 socket 层到传输层的接口，从下面的定义可以看出，这个结构体中定义的都是 <code>struct sock</code> 的相关操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">close</span>)(struct sock *sk, <span class="keyword">long</span> timeout);</span><br><span class="line">    <span class="keyword">int</span> (*pre_connect)(struct sock *sk, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">connect</span>)(struct sock *sk, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">disconnect</span>)(struct sock *sk, <span class="keyword">int</span> flags);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *(*<span class="title">accept</span>)(<span class="title">struct</span> <span class="title">sock</span> *<span class="title">sk</span>, <span class="title">int</span> <span class="title">flags</span>, <span class="title">int</span> *<span class="title">err</span>, <span class="title">bool</span> <span class="title">kern</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*ioctl)(struct sock *sk, <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">int</span> (*init)(struct sock *sk);</span><br><span class="line">    <span class="keyword">void</span> (*destroy)(struct sock *sk);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">shutdown</span>)(struct sock *sk, <span class="keyword">int</span> how);</span><br><span class="line">    <span class="keyword">int</span> (*setsockopt)(struct sock *sk, <span class="keyword">int</span> level,</span><br><span class="line">                      <span class="keyword">int</span> optname, <span class="keyword">char</span> __user *optval,</span><br><span class="line">                      <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen);</span><br><span class="line">    <span class="keyword">int</span> (*getsockopt)(struct sock *sk, <span class="keyword">int</span> level,</span><br><span class="line">                      <span class="keyword">int</span> optname, <span class="keyword">char</span> __user *optval,</span><br><span class="line">                      <span class="keyword">int</span> __user *option);</span><br><span class="line">    <span class="keyword">void</span> (*keepalive)(struct sock *sk, <span class="keyword">int</span> valbool);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">    <span class="keyword">int</span> (*compat_setsockopt)(struct sock *sk,</span><br><span class="line">                             <span class="keyword">int</span> level,</span><br><span class="line">                             <span class="keyword">int</span> optname, <span class="keyword">char</span> __user *optval,</span><br><span class="line">                             <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen);</span><br><span class="line">    <span class="keyword">int</span> (*compat_getsockopt)(struct sock *sk,</span><br><span class="line">                             <span class="keyword">int</span> level,</span><br><span class="line">                             <span class="keyword">int</span> optname, <span class="keyword">char</span> __user *optval,</span><br><span class="line">                             <span class="keyword">int</span> __user *option);</span><br><span class="line">    <span class="keyword">int</span> (*compat_ioctl)(struct sock *sk,</span><br><span class="line">                        <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> (*sendmsg)(struct sock *sk, struct msghdr *msg,</span><br><span class="line">                   <span class="keyword">size_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*recvmsg)(struct sock *sk, struct msghdr *msg,</span><br><span class="line">                   <span class="keyword">size_t</span> len, <span class="keyword">int</span> noblock, <span class="keyword">int</span> flags,</span><br><span class="line">                   <span class="keyword">int</span> *addr_len);</span><br><span class="line">    <span class="keyword">int</span> (*sendpage)(struct sock *sk, struct page *page,</span><br><span class="line">                    <span class="keyword">int</span> offset, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> flags);</span><br><span class="line">    <span class="keyword">int</span> (*bind)(struct sock *sk,</span><br><span class="line">                struct sockaddr *uaddr, <span class="keyword">int</span> addr_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*backlog_rcv)(struct sock *sk,</span><br><span class="line">                       struct sk_buff *skb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*release_cb)(struct sock *sk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*hash)(struct sock *sk);</span><br><span class="line">    <span class="keyword">void</span> (*unhash)(struct sock *sk);</span><br><span class="line">    <span class="keyword">void</span> (*rehash)(struct sock *sk);</span><br><span class="line">    <span class="keyword">int</span> (*get_port)(struct sock *sk, <span class="keyword">unsigned</span> short snum);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inuse_idx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> (*stream_memory_free)(<span class="keyword">const</span> struct sock *sk, <span class="keyword">int</span> wake);</span><br><span class="line">    <span class="keyword">bool</span> (*stream_memory_read)(<span class="keyword">const</span> struct sock *sk);</span><br><span class="line">    <span class="keyword">void</span> (*enter_memory_pressure)(struct sock *sk);</span><br><span class="line">    <span class="keyword">void</span> (*leave_memory_pressure)(struct sock *sk);</span><br><span class="line">    <span class="keyword">atomic_long_t</span> *memory_allocated;          <span class="comment">/* Current allocated memory. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">percpu_counter</span> *<span class="title">sockets_allocated</span>;</span> <span class="comment">/* Current number of sockets. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *memory_pressure;</span><br><span class="line">    <span class="keyword">long</span> *sysctl_mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *sysctl_wmem;</span><br><span class="line">    <span class="keyword">int</span> *sysctl_rmem;</span><br><span class="line">    u32 sysctl_wmem_offset;</span><br><span class="line">    u32 sysctl_rmem_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_header;</span><br><span class="line">    <span class="keyword">bool</span> no_autobind;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> obj_size;</span><br><span class="line">    <span class="keyword">slab_flags_t</span> slab_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> useroffset; <span class="comment">/* Usercopy region offset */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> usersize;   <span class="comment">/* Usercopy region size */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">percpu_counter</span> *<span class="title">orphan_count</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_sock_ops</span> *<span class="title">rsk_prot</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timewait_sock_ops</span> *<span class="title">twsk_prot</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hashinfo</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">udp_table</span> *<span class="title">udp_table</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_hashinfo</span> *<span class="title">raw_hash</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">smc_hashinfo</span> *<span class="title">smc_hash</span>;</span></span><br><span class="line">    &#125; h;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SOCK_REFCNT_DEBUG</span></span><br><span class="line">    <span class="keyword">atomic_t</span> socks;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> (*diag_destroy)(struct sock *sk, <span class="keyword">int</span> err);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>这也就是说，对上的 socket 操作都定义在 ops 中，而对下的 sock 操作都定义在 prot 中，从我们选定的 answer 一样能够获取到对应 TCP 的 struct proto，即 tcp_prot，我们用 tcp_prot 初始化 struct sock，这个 tcp_prot 定义在 <code>/net/ipv4/tcp_ipv4.c</code> 中，里面的行为对应的就是 TCP 协议下内核网络协议栈的所有操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> = &#123;</span></span><br><span class="line">    .name = <span class="string">"TCP"</span>,</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .<span class="built_in">close</span> = tcp_close,</span><br><span class="line">    .pre_connect = tcp_v4_pre_connect,</span><br><span class="line">    .<span class="built_in">connect</span> = tcp_v4_connect,</span><br><span class="line">    .<span class="built_in">disconnect</span> = tcp_disconnect,</span><br><span class="line">    .accept = inet_csk_accept,</span><br><span class="line">    .ioctl = tcp_ioctl,</span><br><span class="line">    .init = tcp_v4_init_sock,</span><br><span class="line">    .destroy = tcp_v4_destroy_sock,</span><br><span class="line">    .<span class="built_in">shutdown</span> = tcp_shutdown,</span><br><span class="line">    .setsockopt = tcp_setsockopt,</span><br><span class="line">    .getsockopt = tcp_getsockopt,</span><br><span class="line">    .keepalive = tcp_set_keepalive,</span><br><span class="line">    .recvmsg = tcp_recvmsg,</span><br><span class="line">    .sendmsg = tcp_sendmsg,</span><br><span class="line">    .sendpage = tcp_sendpage,</span><br><span class="line">    .backlog_rcv = tcp_v4_do_rcv,</span><br><span class="line">    .release_cb = tcp_release_cb,</span><br><span class="line">    .hash = inet_hash,</span><br><span class="line">    .unhash = inet_unhash,</span><br><span class="line">    .get_port = inet_csk_get_port,</span><br><span class="line">    .enter_memory_pressure = tcp_enter_memory_pressure,</span><br><span class="line">    .leave_memory_pressure = tcp_leave_memory_pressure,</span><br><span class="line">    .stream_memory_free = tcp_stream_memory_free,</span><br><span class="line">    .sockets_allocated = &amp;tcp_sockets_allocated,</span><br><span class="line">    .orphan_count = &amp;tcp_orphan_count,</span><br><span class="line">    .memory_allocated = &amp;tcp_memory_allocated,</span><br><span class="line">    .memory_pressure = &amp;tcp_memory_pressure,</span><br><span class="line">    .sysctl_mem = sysctl_tcp_mem,</span><br><span class="line">    .sysctl_wmem_offset = offsetof(struct net, ipv4.sysctl_tcp_wmem),</span><br><span class="line">    .sysctl_rmem_offset = offsetof(struct net, ipv4.sysctl_tcp_rmem),</span><br><span class="line">    .max_header = MAX_TCP_HEADER,</span><br><span class="line">    .obj_size = <span class="keyword">sizeof</span>(struct tcp_sock),</span><br><span class="line">    .slab_flags = SLAB_TYPESAFE_BY_RCU,</span><br><span class="line">    .twsk_prot = &amp;tcp_timewait_sock_ops,</span><br><span class="line">    .rsk_prot = &amp;tcp_request_sock_ops,</span><br><span class="line">    .h.hashinfo = &amp;tcp_hashinfo,</span><br><span class="line">    .no_autobind = <span class="literal">true</span>,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    .compat_setsockopt = compat_tcp_setsockopt,</span><br><span class="line">    .compat_getsockopt = compat_tcp_getsockopt,</span><br><span class="line">#endif</span><br><span class="line">    .diag_destroy = tcp_abort,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(tcp_prot);</span><br></pre></td></tr></table></figure>
<p>inet_create 函数中我们还差 struct inet_sock 结构没有分析，打开这个结构能够发现很有意思的一幕，struct inet_sock 其实就是 struct sock 的扩展，在 struct sock 的基础上增加了一些东西，具体可以看下面的注释，也就是说，inet_sk 函数其实是进行了一次强制转换，将 <code>struct sock*</code> 转换成了 <code>struct inet_sock</code>，内核中经常能见到这样的操作，将一个结构放在另一个结构的开始位置，然后对这个新的结构进行扩展，当需要访问的时候，通过对原结构指针的强制转换就能够访问新的结构体成员，这在某种意义上来说就是 C++ 中的继承和多态，果然编程的原理都是相通的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @sk - 祖先类</span></span><br><span class="line"><span class="comment"> * @pinet6 - IPv6 控制块的指针</span></span><br><span class="line"><span class="comment"> * @inet_daddr - 目标 IPv4 地址</span></span><br><span class="line"><span class="comment"> * @inet_rcv_saddr - 绑定本地 IPv4 地址</span></span><br><span class="line"><span class="comment"> * @inet_dport - 目标端口</span></span><br><span class="line"><span class="comment"> * @inet_num - 本地端口, 主机序</span></span><br><span class="line"><span class="comment"> * @inet_saddr - 发送源地址</span></span><br><span class="line"><span class="comment"> * @uc_ttl - 单播 TTL</span></span><br><span class="line"><span class="comment"> * @inet_sport - 源端口, 网络序</span></span><br><span class="line"><span class="comment"> * @inet_id - ID counter for DF pkts</span></span><br><span class="line"><span class="comment"> * @tos - TOS</span></span><br><span class="line"><span class="comment"> * @mc_ttl - 多播 TTL</span></span><br><span class="line"><span class="comment"> * @is_icsk - 是否是 TCP 状态维护结构 inet_connection_sock</span></span><br><span class="line"><span class="comment"> * @uc_index - 单播发出设备索引</span></span><br><span class="line"><span class="comment"> * @mc_index - 多播设备索引</span></span><br><span class="line"><span class="comment"> * @mc_list - Group array</span></span><br><span class="line"><span class="comment"> * @cork - info to build ip hdr on each ip frag while socket is corked</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// sk 和 pinet6 必须放在结构体的起始位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> <span class="title">sk</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_IPV6)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipv6_pinfo</span> *<span class="title">pinet6</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inet_daddr sk.__sk_common.skc_daddr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inet_rcv_saddr sk.__sk_common.skc_rcv_saddr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inet_dport sk.__sk_common.skc_dport</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inet_num sk.__sk_common.skc_num</span></span><br><span class="line"></span><br><span class="line">    __be32 inet_saddr;</span><br><span class="line">    __s16 uc_ttl;</span><br><span class="line">    __u16 cmsg_flags;</span><br><span class="line">    __be16 inet_sport;</span><br><span class="line">    __u16 inet_id;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_options_rcu</span> __<span class="title">rcu</span> *<span class="title">inet_opt</span>;</span></span><br><span class="line">    <span class="keyword">int</span> rx_dst_ifindex;</span><br><span class="line">    __u8 tos;</span><br><span class="line">    __u8 min_ttl;</span><br><span class="line">    __u8 mc_ttl;</span><br><span class="line">    __u8 pmtudisc;</span><br><span class="line">    __u8 recverr : <span class="number">1</span>,</span><br><span class="line">        is_icsk : <span class="number">1</span>,</span><br><span class="line">        freebind : <span class="number">1</span>,</span><br><span class="line">        hdrincl : <span class="number">1</span>,</span><br><span class="line">        mc_loop : <span class="number">1</span>,</span><br><span class="line">        transparent : <span class="number">1</span>,</span><br><span class="line">        mc_all : <span class="number">1</span>,</span><br><span class="line">        nodefrag : <span class="number">1</span>;</span><br><span class="line">    __u8 bind_address_no_port : <span class="number">1</span>,</span><br><span class="line">        defer_connect : <span class="number">1</span>;</span><br><span class="line">    __u8 rcv_tos;</span><br><span class="line">    __u8 convert_csum;</span><br><span class="line">    <span class="keyword">int</span> uc_index;</span><br><span class="line">    <span class="keyword">int</span> mc_index;</span><br><span class="line">    __be32 mc_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mc_socklist</span> __<span class="title">rcu</span> *<span class="title">mc_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_cork_full</span> <span class="title">cork</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行完 inet_create 后，socket 的创建已经完成了，之后回到 __sys_socket，调用 sock_map_fd 将这个新建的 struct socket 和 fd 绑定并将 fd 返回，socket 调用完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sock_map_fd</span><span class="params">(struct socket *sock, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line">    <span class="comment">// 选取一个未被使用的 fd</span></span><br><span class="line">    <span class="keyword">int</span> fd = get_unused_fd_flags(flags);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(fd &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        sock_release(sock);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// struct socket 与一个 struct file 对应</span></span><br><span class="line">    <span class="comment">// sock-&gt;file = file</span></span><br><span class="line">    <span class="comment">// file-&gt;private_data = sock</span></span><br><span class="line">    <span class="comment">// 将 struct socket 指针放在 file 的 private_data 字段中</span></span><br><span class="line">    newfile = sock_alloc_file(sock, flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(newfile)) &#123;</span><br><span class="line">        <span class="comment">// 将 struct file 与 fd 关联起来, 相当于 socket 与 fd 关联起来了</span></span><br><span class="line">        fd_install(fd, newfile);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    put_unused_fd(fd);</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(newfile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绑定端口-bind">绑定端口 bind</h2>
<p>创建了 socket，我们需要将这个 socket 绑定到一个地址才能使用，这就类似于去电信登记自己的手机号。bind 的系统调用位于 <code>/net/socket.c</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bind, <span class="keyword">int</span>, fd, struct sockaddr __user *, umyaddr, <span class="keyword">int</span>, addrlen) &#123;</span><br><span class="line">    <span class="keyword">return</span> __sys_bind(fd, umyaddr, addrlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __sys_bind(<span class="keyword">int</span> fd, struct sockaddr __user *umyaddr, <span class="keyword">int</span> addrlen) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err, fput_needed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 fd 找到对应的 struct socket</span></span><br><span class="line">    <span class="comment">// sockfd_lookup_light 会调用 sock_from_file</span></span><br><span class="line">    <span class="comment">// 从 struct file 的 private_data 中取出 struct socket 指针</span></span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">    <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">        <span class="comment">// 将 sockaddr 从用户态 umyaddr 拷贝到内核态 address, address 是内核空间的地址</span></span><br><span class="line">        err = move_addr_to_kernel(umyaddr, addrlen, &amp;address);</span><br><span class="line">        <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">            err = security_socket_bind(sock, (struct sockaddr *)&amp;address, addrlen);</span><br><span class="line">            <span class="keyword">if</span> (!err)</span><br><span class="line">                <span class="comment">// 调用的是 inet_stream_ops 中的 bind 函数, 也就是 inet_bind</span></span><br><span class="line">                err = sock-&gt;ops-&gt;bind(sock, (struct sockaddr *)&amp;address, addrlen);</span><br><span class="line">        &#125;</span><br><span class="line">        fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先先看参数 <code>struct sockaddr __user *umyaddr</code>，这是一个通用地址结构，固定长度为 16 字节。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 地址族 AF_XX, sa_family_t 其实是一个 unsigned short</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="comment">// 14 Bytes 的协议地址</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后看 address 变量，这是一个 sockaddr_storage 结构，定义如下，这是一个 128 字节的地址结构，之所以会出现第二个通用地址结构，是因为 struct sockaddr 这个结构装不下 28 位的 IPv6 的地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sockaddr_storage __kernel_sockaddr_storage</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">kernel_sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">__kernel_sa_family_t</span> ss_family;</span><br><span class="line">            <span class="comment">// #define _K_SS_MAXSIZE    128</span></span><br><span class="line">            <span class="keyword">char</span> __data[_K_SS_MAXSIZE - <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> short)];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">void</span> *__align;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后调用的就是 sock-&gt;ops-&gt;bind，还记得上一节中 TCP 协议对应的 ops 吗？没错，TCP 协议对应的 ops 为 inet_stream_ops，那么对应的 bind 函数就是 inet_bind，这里需要注意以下函数的参数，传入的地址指针是经过强制类型转换成 struct sockaddr 这个较小的通用地址，此外还有一个 addr_len 表示地址的长度，内核中其实正是用 addr_len 参数来区分地址的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_bind</span><span class="params">(struct socket *sock, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 struct socket 中取出对应的 struct sock</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 sk_port 中有 bind 函数, 就直接调用, 比如 SOCK_RAW</span></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_prot-&gt;bind) &#123;</span><br><span class="line">        <span class="keyword">return</span> sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(struct sockaddr_in))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    err = BPF_CGROUP_RUN_PROG_INET4_BIND(sk, uaddr);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __inet_bind(sk, uaddr, addr_len, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(inet_bind);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP 最后还是会调用到 __inet_bind</span></span><br><span class="line"><span class="keyword">int</span> __inet_bind(struct sock *sk, struct sockaddr *uaddr, <span class="keyword">int</span> addr_len,</span><br><span class="line">                <span class="keyword">bool</span> force_bind_address_no_port, <span class="keyword">bool</span> with_lock) &#123;</span><br><span class="line">    <span class="comment">// struct sockaddr_in 是 IPv4 16 Byte 的地址结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *)<span class="title">uaddr</span>;</span></span><br><span class="line">    <span class="comment">// 获取 struct sk 的 TCP 扩展 struct inet_sock</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="keyword">unsigned</span> short snum;</span><br><span class="line">    <span class="keyword">int</span> chk_addr_ret;</span><br><span class="line">    u32 tb_id = RT_TABLE_LOCAL;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr-&gt;sin_family != AF_INET) &#123;</span><br><span class="line">        err = -EAFNOSUPPORT;</span><br><span class="line">        <span class="keyword">if</span> (addr-&gt;sin_family != AF_UNSPEC ||</span><br><span class="line">            addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tb_id = l3mdev_fib_table_by_index(net, sk-&gt;sk_bound_dev_if) ?: tb_id;</span><br><span class="line">    chk_addr_ret = inet_addr_type_table(net, addr-&gt;sin_addr.s_addr, tb_id);</span><br><span class="line"></span><br><span class="line">    err = -EADDRNOTAVAIL;</span><br><span class="line">    <span class="keyword">if</span> (!inet_can_nonlocal_bind(net, inet) &amp;&amp;</span><br><span class="line">        addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY) &amp;&amp;</span><br><span class="line">        chk_addr_ret != RTN_LOCAL &amp;&amp;</span><br><span class="line">        chk_addr_ret != RTN_MULTICAST &amp;&amp;</span><br><span class="line">        chk_addr_ret != RTN_BROADCAST)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    snum = ntohs(addr-&gt;sin_port);</span><br><span class="line">    err = -EACCES;</span><br><span class="line">    <span class="keyword">if</span> (snum &amp;&amp; inet_port_requires_bind_service(net, snum) &amp;&amp;</span><br><span class="line">        !ns_capable(net-&gt;user_ns, CAP_NET_BIND_SERVICE))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (with_lock)</span><br><span class="line">        lock_sock(sk);</span><br><span class="line"></span><br><span class="line">    err = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;inet_num)</span><br><span class="line">        <span class="keyword">goto</span> out_release_sock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inet_rcv_saddr 是本地的 IPv4 地址, 用 addr 地址对其初始化</span></span><br><span class="line">    inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;</span><br><span class="line">    <span class="keyword">if</span> (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)</span><br><span class="line">        inet-&gt;inet_saddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (snum || !(inet-&gt;bind_address_no_port || force_bind_address_no_port)) &#123;</span><br><span class="line">        <span class="comment">// 调用 tcp_prot 中的 inet_csk_get_port 判断端口是否被占用</span></span><br><span class="line">        <span class="comment">// 如果被占用, 将上面修改的地址清零</span></span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">            inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="number">0</span>;</span><br><span class="line">            err = -EADDRINUSE;</span><br><span class="line">            <span class="keyword">goto</span> out_release_sock;</span><br><span class="line">        &#125;</span><br><span class="line">        err = BPF_CGROUP_RUN_PROG_INET4_POST_BIND(sk);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">goto</span> out_release_sock;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inet-&gt;inet_rcv_saddr)</span><br><span class="line">        sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK;</span><br><span class="line">    <span class="keyword">if</span> (snum)</span><br><span class="line">        sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK;</span><br><span class="line">    <span class="comment">// 设置本地端口</span></span><br><span class="line">    inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line">    <span class="comment">// 对端地址和端口都设置为 0</span></span><br><span class="line">    inet-&gt;inet_daddr = <span class="number">0</span>;</span><br><span class="line">    inet-&gt;inet_dport = <span class="number">0</span>;</span><br><span class="line">    sk_dst_reset(sk);</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">out_release_sock:</span><br><span class="line">    <span class="keyword">if</span> (with_lock)</span><br><span class="line">        release_sock(sk);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="监听端口-listen">监听端口 listen</h2>
<p>将 socket 与地址绑定后，接下来就需要 listen 监听这个 socket，同样我们继续看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE2(<span class="built_in">listen</span>, <span class="keyword">int</span>, fd, <span class="keyword">int</span>, backlog) &#123;</span><br><span class="line">    <span class="keyword">return</span> __sys_listen(fd, backlog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backlog 定义了所能接受 SYN 的最大客户端数量, 即半连接上限</span></span><br><span class="line"><span class="keyword">int</span> __sys_listen(<span class="keyword">int</span> fd, <span class="keyword">int</span> backlog) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err, fput_needed;</span><br><span class="line">    <span class="keyword">int</span> somaxconn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 fd 获取 struct socket</span></span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">    <span class="keyword">if</span> (sock) &#123;</span><br><span class="line">        <span class="comment">// somaxconn 定义了服务端所能 accept 的最大客户端上限, 即完成连接上限</span></span><br><span class="line">        <span class="comment">// 默认为 128, 不过通常都会修改成 1024 以上</span></span><br><span class="line">        somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)backlog &gt; somaxconn)</span><br><span class="line">            backlog = somaxconn;</span><br><span class="line"></span><br><span class="line">        err = security_socket_listen(sock, backlog);</span><br><span class="line">        <span class="keyword">if</span> (!err)</span><br><span class="line">            <span class="comment">// 调用 inet_listen 进行监听</span></span><br><span class="line">            err = sock-&gt;ops-&gt;<span class="built_in">listen</span>(sock, backlog);</span><br><span class="line"></span><br><span class="line">        fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先仍然是获取 fd 对应的 struct socket，然后会根据内核中设置的 somaxconn 的值修正 backlog 参数，确保半连接队列的长度不能超过最大 accept 队列的长度。<br>
然后调用 sock-&gt;ops-&gt;listen 开始监听，还是和上面一样，其实调用的是 inet_stream_ops 中的 inet_listen 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_listen</span><span class="params">(struct socket *sock, <span class="keyword">int</span> backlog)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> old_state;</span><br><span class="line">    <span class="keyword">int</span> err, tcp_fastopen;</span><br><span class="line"></span><br><span class="line">    lock_sock(sk);</span><br><span class="line"></span><br><span class="line">    err = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (sock-&gt;state != SS_UNCONNECTED || sock-&gt;type != SOCK_STREAM)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    old_state = sk-&gt;sk_state;</span><br><span class="line">    <span class="keyword">if</span> (!((<span class="number">1</span> &lt;&lt; old_state) &amp; (TCPF_CLOSE | TCPF_LISTEN)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    WRITE_ONCE(sk-&gt;sk_max_ack_backlog, backlog);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 socket 已经处在 TCP_LISTEN 状态, 我们就只能够调整 backlog 的值</span></span><br><span class="line">    <span class="keyword">if</span> (old_state != TCP_LISTEN) &#123;</span><br><span class="line">        <span class="comment">// tcp_fastopen 允许服务器和客户端在建立连接阶段交换数据以减少时延, 默认关闭, 不作讨论</span></span><br><span class="line">        tcp_fastopen = sock_net(sk)-&gt;ipv4.sysctl_tcp_fastopen;</span><br><span class="line">        <span class="keyword">if</span> ((tcp_fastopen &amp; TFO_SERVER_WO_SOCKOPT1) &amp;&amp;</span><br><span class="line">            (tcp_fastopen &amp; TFO_SERVER_ENABLE) &amp;&amp;</span><br><span class="line">            !inet_csk(sk)-&gt;icsk_accept_queue.fastopenq.max_qlen) &#123;</span><br><span class="line">            fastopen_queue_tune(sk, backlog);</span><br><span class="line">            tcp_fastopen_init_key_once(sock_net(sk));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inet_csk_listen_start 这里真正进入监听状态</span></span><br><span class="line">        err = inet_csk_listen_start(sk, backlog);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        tcp_call_bpf(sk, BPF_SOCK_OPS_TCP_LISTEN_CB, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    release_sock(sk);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(inet_listen);</span><br></pre></td></tr></table></figure>
<p>不难看出，inet_listen 会调用 inet_csk_listen_start 进入监听状态，里面出现了一个新结构 struct inet_connection_sock，看到 inet_csk 这种结构体指针转换函数其实就不难想到，struct inet_connection_sock 是 struct inet_sock 的扩展结构，而 struct inet_sock 又是 struct sock 的扩展结构，它们其实是一个不断嵌套的过程，唯一的要求是这些子结构体都必须位于扩展结构体的头部。<br>
<strong>我们说 TCP 是面向连接的，并不是指客户端与服务器之间有一条通路，而是 TCP 的两端都有一个维护连接状态的结构体，这个结构体就是 struct inet_connection_sock，这是一个面向连接的传输控制块</strong>。<br>
接下来我们来到 <code>reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue)</code>，看看 icsk_accept_queue 是什么。<br>
从内核的角度来说，我们不需要像写代码时那样在服务端调用 accept 之后才能让客户端发起 connect，事实上在服务端 listen 之后客户端就可以发起连接了。内核会为每个 socket 维护两个队列，一个是已经成功建立连接的队列，处于 established 状态，一个是尚未完成三次握手的队列，处于 syn_rcvd 状态，这里的 icsk_accept_queue 其实就是已经成功连接的队列，服务端调用 accept 其实就是从这个队列中取出一个连接进行处理。<br>
随后将 socket 状态设置为 TCP_LISTEN，再次判断端口是否被占用，listen 到此结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_csk_listen_start</span><span class="params">(struct sock *sk, <span class="keyword">int</span> backlog)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 struct sock 扩展为 TCP 连接维护结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> = <span class="title">inet_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="keyword">int</span> err = -EADDRINUSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里面主要是初始化队列相关的锁</span></span><br><span class="line">    reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue);</span><br><span class="line"></span><br><span class="line">    sk-&gt;sk_ack_backlog = <span class="number">0</span>;</span><br><span class="line">    inet_csk_delack_init(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 socket 状态设置为 TCP_LISTEN</span></span><br><span class="line">    inet_sk_state_store(sk, TCP_LISTEN);</span><br><span class="line">    <span class="comment">// 调用 tcp_prot 中的 inet_csk_get_port 判断端口是否被暂用</span></span><br><span class="line">    <span class="keyword">if</span> (!sk-&gt;sk_prot-&gt;get_port(sk, inet-&gt;inet_num)) &#123;</span><br><span class="line">        inet-&gt;inet_sport = htons(inet-&gt;inet_num);</span><br><span class="line"></span><br><span class="line">        sk_dst_reset(sk);</span><br><span class="line">        err = sk-&gt;sk_prot-&gt;hash(sk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(!err))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inet_sk_set_state(sk, TCP_CLOSE);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(inet_csk_listen_start);</span><br></pre></td></tr></table></figure>
<h2 id="服务端取出连接-accept">服务端取出连接 accept</h2>
<p>这里我们仍然按照编码逻辑，先分析 accept 函数，服务端在 listen 之后就可以在循环中调用 accept 等待取出成功的连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(accept, <span class="keyword">int</span>, fd, struct sockaddr __user *, upeer_sockaddr, <span class="keyword">int</span> __user *, upeer_addrlen) &#123;</span><br><span class="line">    <span class="keyword">return</span> __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的参数 fd 就是前面通过 socket 创建并且经过 bind listen 的 listenfd</span></span><br><span class="line"><span class="keyword">int</span> __sys_accept4(<span class="keyword">int</span> fd, struct sockaddr __user *upeer_sockaddr, <span class="keyword">int</span> __user *upeer_addrlen, <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -EBADF;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到 listenfd 对应的 struct file</span></span><br><span class="line">    f = fdget(fd);</span><br><span class="line">    <span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">        ret = __sys_accept4_file(f.file, <span class="number">0</span>, upeer_sockaddr, upeer_addrlen, flags, rlimit(RLIMIT_NOFILE));</span><br><span class="line">        <span class="keyword">if</span> (f.flags)</span><br><span class="line">            fput(f.file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__sys_accept4 最后还是要调用 __sys_accept4_file，首先从参数的 struct file 中取出 struct socket，然后创建了一个新的 struct socket newsock 将它的 type 与 ops 设置为与监听 socket 一样，这其实从侧面说明了监听 socket 与通信 socket 不是同一个 socket。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __sys_accept4_file(struct file *file, <span class="keyword">unsigned</span> file_flags,</span><br><span class="line">                       struct sockaddr __user *upeer_sockaddr,</span><br><span class="line">                       <span class="keyword">int</span> __user *upeer_addrlen, <span class="keyword">int</span> flags,</span><br><span class="line">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> nofile) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>, *<span class="title">newsock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err, len, newfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))</span><br><span class="line">        flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 struct file 中取出 struct socket</span></span><br><span class="line">    sock = sock_from_file(file, &amp;err);</span><br><span class="line">    <span class="keyword">if</span> (!sock)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    err = -ENFILE;</span><br><span class="line">    <span class="comment">// 创建一个新的 struct socket 并且分配一个新的 inode</span></span><br><span class="line">    newsock = sock_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!newsock)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    newsock-&gt;type = sock-&gt;type;</span><br><span class="line">    newsock-&gt;ops = sock-&gt;ops;</span><br><span class="line"></span><br><span class="line">    __module_get(newsock-&gt;ops-&gt;owner);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选取一个未使用的 fd</span></span><br><span class="line">    newfd = __get_unused_fd_flags(flags, nofile);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(newfd &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        err = newfd;</span><br><span class="line">        sock_release(newsock);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 newsock 分配一个对应的 struct file 并且将 sock 指针放入 file-&gt;private_data 中</span></span><br><span class="line">    newfile = sock_alloc_file(newsock, flags, sock-&gt;sk-&gt;sk_prot_creator-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(newfile)) &#123;</span><br><span class="line">        err = PTR_ERR(newfile);</span><br><span class="line">        put_unused_fd(newfd);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = security_socket_accept(sock, newsock);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 inet_stream_ops 中的 inet_accept 函数</span></span><br><span class="line">    err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags | file_flags, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (upeer_sockaddr) &#123;</span><br><span class="line">        len = newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr *)&amp;address, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -ECONNABORTED;</span><br><span class="line">            <span class="keyword">goto</span> out_fd;</span><br><span class="line">        &#125;</span><br><span class="line">        err = move_addr_to_user(&amp;address, len, upeer_sockaddr, upeer_addrlen);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out_fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 newfd 与成功关联 new socket 的 struct file 关联起来, 最后返回 newfd</span></span><br><span class="line">    fd_install(newfd, newfile);</span><br><span class="line">    err = newfd;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">out_fd:</span><br><span class="line">    fput(newfile);</span><br><span class="line">    put_unused_fd(newfd);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着往下看，会调用 sock-&gt;ops-&gt;accept，按照上面的逻辑，调用的是 inet_stream_ops 中的 inet_accept 函数，在该函数中会调用 tcp_prot 的 accept 函数，我们在上面的初始化中能够查询到该函数是 inet_csk_accept。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先注意这里的 sock 还是旧的 socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_accept</span><span class="params">(struct socket *sock, struct socket *newsock, <span class="keyword">int</span> flags, <span class="keyword">bool</span> kern)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk1</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err = -EINVAL;</span><br><span class="line">    <span class="comment">// 调用 tcp_prot 中的 inet_csk_accept</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk2</span> = <span class="title">sk1</span>-&gt;<span class="title">sk_prot</span>-&gt;<span class="title">accept</span>(<span class="title">sk1</span>, <span class="title">flags</span>, &amp;<span class="title">err</span>, <span class="title">kern</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sk2)</span><br><span class="line">        <span class="keyword">goto</span> do_err;</span><br><span class="line"></span><br><span class="line">    lock_sock(sk2);</span><br><span class="line"></span><br><span class="line">    sock_rps_record_flow(sk2);</span><br><span class="line">    WARN_ON(!((<span class="number">1</span> &lt;&lt; sk2-&gt;sk_state) &amp; (TCPF_ESTABLISHED | TCPF_SYN_RECV | TCPF_CLOSE_WAIT | TCPF_CLOSE)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newsock-&gt;sock = sk2, accept 将已连接队列中取出的 struct sock 与 struct socket 关联起来</span></span><br><span class="line">    sock_graft(sk2, newsock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改取出连接的状态</span></span><br><span class="line">    newsock-&gt;state = SS_CONNECTED;</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    release_sock(sk2);</span><br><span class="line">do_err:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(inet_accept);</span><br></pre></td></tr></table></figure>
<p>下面我们来看一下 inet_csk_accept 的实现，这里面最重要的是 inet_csk_wait_for_connect，如果已经完成的队列为空，就会进入这个函数，否则就从已完成连接队列中取出一个 struct sock 并返回，这个 newsock 会赋给 inet_accept 函数中的 sk2，在 sock_graft 函数中 sk2 会与这个新的 newsock 关联起来，最后将 newsock-&gt;state 设置为 SS_CONNECTED，最后被修改的 newsock 会与一个文件描述符 newfd 关联起来，返回给用户使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct sock *<span class="title">inet_csk_accept</span><span class="params">(struct sock *sk, <span class="keyword">int</span> flags, <span class="keyword">int</span> *err, <span class="keyword">bool</span> kern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先转换出 TCP 连接维护结构体 inet_connection_sock</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    <span class="comment">// 已完成连接队列, 队列项中能够直接取到 struct sock* sk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_sock_queue</span> *<span class="title">queue</span> = &amp;<span class="title">icsk</span>-&gt;<span class="title">icsk_accept_queue</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_sock</span> *<span class="title">req</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">newsk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    lock_sock(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保 socket 处在 TCP_LISTEN 状态, 这个 sk_state 表示的是 socket 底层的连接状态</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经完成连接的队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (reqsk_queue_empty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">long</span> timeo = sock_rcvtimeo(sk, flags &amp; O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个 socket 是非阻塞的, 直接返回</span></span><br><span class="line">        error = -EAGAIN;</span><br><span class="line">        <span class="keyword">if</span> (!timeo)</span><br><span class="line">            <span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则阻塞在这里</span></span><br><span class="line">        error = inet_csk_wait_for_connect(sk, timeo);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_err;</span><br><span class="line">    &#125;</span><br><span class="line">    req = reqsk_queue_remove(<span class="built_in">queue</span>, sk);</span><br><span class="line">    newsk = req-&gt;sk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;sk_protocol == IPPROTO_TCP &amp;&amp; tcp_rsk(req)-&gt;tfo_listener) &#123;</span><br><span class="line">        spin_lock_bh(&amp;<span class="built_in">queue</span>-&gt;fastopenq.lock);</span><br><span class="line">        <span class="keyword">if</span> (tcp_rsk(req)-&gt;tfo_listener) &#123;</span><br><span class="line">            req-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line">            req = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock_bh(&amp;<span class="built_in">queue</span>-&gt;fastopenq.lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    release_sock(sk);</span><br><span class="line">    <span class="keyword">if</span> (newsk &amp;&amp; mem_cgroup_sockets_enabled) &#123;</span><br><span class="line">        <span class="keyword">int</span> amt;</span><br><span class="line">        lock_sock(newsk);</span><br><span class="line"></span><br><span class="line">        amt = sk_mem_pages(newsk-&gt;sk_forward_alloc + atomic_read(&amp;newsk-&gt;sk_rmem_alloc));</span><br><span class="line">        mem_cgroup_sk_alloc(newsk);</span><br><span class="line">        <span class="keyword">if</span> (newsk-&gt;sk_memcg &amp;&amp; amt)</span><br><span class="line">            mem_cgroup_charge_skmem(newsk-&gt;sk_memcg, amt);</span><br><span class="line">        release_sock(newsk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req)</span><br><span class="line">        reqsk_put(req);</span><br><span class="line">    <span class="keyword">return</span> newsk;</span><br><span class="line">out_err:</span><br><span class="line">    newsk = <span class="literal">NULL</span>;</span><br><span class="line">    req = <span class="literal">NULL</span>;</span><br><span class="line">    *err = error;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(inet_csk_accept);</span><br></pre></td></tr></table></figure>
<p>那么我们再看一下如果连接就绪队列为空的时候，inet_csk_wait_for_connect 都做了些什么。<br>
inet_csk_wait_for_connect 最主要的功能就是等待客户端连接，为了避免竞态出现，该函数必须在 socket 上锁的情况下调用。<br>
在 icsk_accept_queue 队列为空的时候，内核会主动调度 schedule_timeout 让出 CPU 一段时间，等到重新唤醒的时候会检查 icsk_accept_queue 是否还为空，socket 是否处在监听状态以及是否有信号需要处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inet_csk_wait_for_connect</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeo)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> *<span class="title">icsk</span> = <span class="title">inet_csk</span>(<span class="title">sk</span>);</span></span><br><span class="line">    DEFINE_WAIT(wait);</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 将进程状态设置为等待资源有效时唤醒 TASK_INTERRUPTIBLE</span></span><br><span class="line">        prepare_to_wait_exclusive(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">        release_sock(sk);</span><br><span class="line">        <span class="keyword">if</span> (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))</span><br><span class="line">            <span class="comment">// 主动调度让出 CPU, timeo 时间后唤醒</span></span><br><span class="line">            timeo = schedule_timeout(timeo);</span><br><span class="line">        sched_annotate_sleep();</span><br><span class="line">        <span class="comment">// 唤醒后先上锁</span></span><br><span class="line">        lock_sock(sk);</span><br><span class="line">        err = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断 icsk_accept_queue 队列是否为空, 如果不为空, 直接退出循环返回</span></span><br><span class="line">        <span class="keyword">if</span> (!reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="comment">// 如果 socket 退出监听了, 直接退出循环返回</span></span><br><span class="line">        <span class="keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        err = sock_intr_errno(timeo);</span><br><span class="line">        <span class="comment">// 如果有信号待处理, 直接退出循环返回</span></span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        err = -EAGAIN;</span><br><span class="line">        <span class="keyword">if</span> (!timeo)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    finish_wait(sk_sleep(sk), &amp;wait);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux-Kernel</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>decltype 陷阱</title>
    <url>/posts/a4099fa0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一般场景下的-decltype">一般场景下的 decltype</h2>
<p>decltype - declared type，用于名字或表达式的类型推断，一般情况下，它都是与 auto 的推导过程相反，看几个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;              <span class="comment">// decltype(i) -&gt; const int</span></span><br><span class="line"><span class="keyword">if</span> (f(w))...                  <span class="comment">// decltype(f(w)) -&gt; bool</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>;      <span class="comment">// decltype(f) -&gt; bool(const Widget&amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> index);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;                <span class="comment">// decltype(v) -&gt; vector&lt;int&gt;</span></span><br><span class="line">v[<span class="number">0</span>] = <span class="number">0</span>;                     <span class="comment">// decltype(v[0]) -&gt; int&amp;</span></span><br></pre></td></tr></table></figure>
<p>一般来说，含有 T 类型的对象的容器，<code>operator[]</code> 会返回 T&amp;（<code>std::vector&lt;bool&gt;</code> 是个例外），我们实际编码的过程中，decltype 的主要用途是用于声明那些返回值类型需要依赖形参类型的函数模板，看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line">auto authAndAccess(Container&amp; c, Index i) -&gt; decltype(c[i]) &#123;</span><br><span class="line">    authenticateUser();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码使用的是返回值类型后置，因为 C++11 中还不支持函数返回值类型 auto 推断，如果需要在返回值中使用函数形参，我们必须将返回值后置，否则会出现参数未声明而无法使用。这样的话 <code>authAndAccess</code> 函数返回值的类型与 <code>operator[]</code> 返回值类型是一致的。</p>
<h2 id="decltype-auto-你真的懂吗">decltype(auto) 你真的懂吗</h2>
<p>从 C++14 开始，上面的函数可以得到进一步的优化，因为新的标准允许对一切 lambda 表达式和函数进行型别推导，我们可以去掉返回值后置的语法，只保留 auto，代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    authenticateUser();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个新版函数中函数返回值的类型是根据 c[i] 推导出来的，好像 auto 已经把 decltype 该做的事情做完了，那么 decltype 还有用吗？</p>
<p>当然有用，C++ 有个特性（大坑），<strong>在模板型别的推导过程中，具有引用型别的实参会被当成非引用型别来处理，也就是说，引用性会被忽略</strong>。<br>
虽然 c[i] 的型别是 Container&amp;，但是 auto 推断出来的返回值类型竟然是 Container！那么下面的代码根本不会通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">...</span><br><span class="line">authAndAccess(d, <span class="number">5</span>) = <span class="number">10</span>;   <span class="comment">// 相当于将一个右值赋给了另一个右值</span></span><br></pre></td></tr></table></figure>
<p>此时就轮到 <code>decltype(auto)</code> 出场了，auto 指定了我们打算推导的型别，而 decltype 指定了型别的推导规则：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    authenticateUser();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样 authAndAccess 的返回值类型与 c[i] 的类型就完全相同了。</p>
<h2 id="右值容器怎么处理">右值容器怎么处理</h2>
<p>细心的朋友不难发现，上面给出的 <code>authAndAccess</code> 函数只能够处理左值容器，因为右值是无法绑定到左值引用的，因此向该函数传递一个右值容器是非法行为。<br>
那么有什么方法能够同时支持左值绑定与右值绑定呢，答案就是万能引用，对于万能引用要使用 <code>std::forward</code>，下面我们直接使用 C++14 的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">authAndAccess</span><span class="params">(Container&amp;&amp; c, Index i)</span> </span>&#123;    <span class="comment">// c 现在是万能引用</span></span><br><span class="line">    authenticateUser();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::forward&lt;Container&gt;(c)[i];                 <span class="comment">// 完美转发 Container 的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="听说-decltype-还能推导表达式">听说 decltype 还能推导表达式</h2>
<p>想要彻底理解 decltype 的行为，还需要熟悉一些特殊情况，这里只选一个具有代表性的，也是 C++ Quiz 中经常遇到的难题：<br>
一个名字通常是左值表达式，如果仅有一个名字，比如 decltype(e)，decltype 会准确地推导出 e 的型别，但是<strong>如果是比仅有名字更加复杂的左值表达式，decltype 需要保证推导出的型别总是左值引用</strong>！</p>
<p>看起来是个合情合理的推导，但是会产生一些诡异的现象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) -&gt; <span class="keyword">int</span>      <span class="comment">// decltype(x) 的推导结果为 int</span></span><br><span class="line"><span class="keyword">decltype</span>((x)) -&gt; <span class="keyword">int</span>&amp;   <span class="comment">// decltype((x)) 的推导结果为 int&amp;</span></span><br></pre></td></tr></table></figure>
<p>看起来就像一个小彩蛋，但是如果遇到下面的情况就会出现奇妙的未定义行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> (x);       <span class="comment">// f2 返回的是一个局部变量的引用从而引发未定义行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Decltype</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake 项目链接时找不到静态库</title>
    <url>/posts/1c6f4546/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<ul>
<li>解决 CLion 项目链接时找不到链接库的问题</li>
</ul>
</blockquote>
<a id="more"></a>
<p>最近在用 cmake 管理项目的时候，写完 test 后发现无论如何都没有办法链接成功，报错内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: can<span class="number">'</span>t <span class="built_in">find</span> -lTripod_Lib</span><br><span class="line">error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>
<p><code>Tripod_Lib</code> 是之前生成的静态库，放在 lib 目录下。</p>
<p>手动用 g++ 命令测试能够成功编译链接，看来真的是因为找不到库😓</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g++ test/test.cc -o tb -I ./src ./lib/Tripod_Lib.a</span><br></pre></td></tr></table></figure>
<p>折磨了两天，最终还是在 <a href="https://cmake.org/cmake/help/v3.15/command/link_directories.html" target="_blank" rel="noopener">官方文档</a> 上找到了原因：<br>
<em>Specify the paths in which the linker should search for libraries. <strong>The command will apply only to targets created after it is called.</strong></em></p>
<p>也是就说，<code>link_directories()</code> 需要放在 <code>add_library()</code> 和 <code>add_executable()</code> 的前面。<br>
此外还要注意，最后链接的静态库名字里要带上 .a 的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.15</span>)</span><br><span class="line">project(Tripod)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_DEBUG_POSTFIX <span class="string">"_Base"</span>)</span><br><span class="line"></span><br><span class="line">aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125;/src SRC_DIR)</span><br><span class="line"></span><br><span class="line">link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line">add_library(_Tripod STATIC $&#123;SRC_DIR&#125;)</span><br><span class="line"></span><br><span class="line">add_executable(Tripod test/test.cc)</span><br><span class="line"></span><br><span class="line">target_link_libraries(Tripod lib_Tripod$&#123;CMAKE_DEBUG_POSTFIX&#125;.a)</span><br></pre></td></tr></table></figure>
<p>必须要吐槽 Cmake 的文档里真是一个例子都没有啊，看完之后模棱两可的东西大把，好像被人在嘴里硬塞了一把屎一样，数学课本都还有例题呢，坑货😡😡😡</p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>CMake</tag>
        <tag>Debug</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 下配置 CLion + Cygwin 开发环境</title>
    <url>/posts/1f8822d7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前已经在 CLion 中配置好了 MinGW，但是 MinGW 下无法调用 POSIX API，因此在 CLion 下重新配置 Toolchain 为 Cygwin，记录一下过程：<br>
首先要说，MinGW 与 Cygwin 还是有区别的：</p>
<ul>
<li>Cygwin 是使用一个 dll 来模拟 Linux 环境，它本质上是一个在 windows 上的可运行 POSIX 应用程序的工具环境</li>
<li>MinGW 是在编译时提供 Linux 到 Win 代码的转换，用到的其实是 Windows 运行库</li>
</ul>
<ol>
<li>
<p>在 <a href="https://www.cygwin.com/" target="_blank" rel="noopener">Cygwin</a> 下载安装文件 setup-x86_64.exe；</p>
</li>
<li>
<p>运行安装文件，一路 next，选择站点界面新增 <code>http://mirrors.163.com/cygwin/</code>；</p>
</li>
<li>
<p>Select Packages 界面，在 View 中选择 Full，然后分别输入 <code>cmake</code> <code>gcc-core</code> <code>gcc-g++</code> <code>gdb</code> <code>make</code>，选择对应的版本号，然后 next 批量安装；</p>
</li>
<li>
<p>安装过程中发现卡在了 <code>/etc/postinstall/0p_000_autorebash.dash</code>，查看了 <a href="http://cygwin.1069669.n5.nabble.com/Autorebase-hangs-on-install-td128035.html#a128036" target="_blank" rel="noopener">解决方法</a>，将 dash 进程结束掉，最后成功安装；</p>
</li>
<li>
<p>在系统环境变量中添加 <code>C:\cygwin64\bin</code>；</p>
</li>
<li>
<p>CLion-&gt;Setting-&gt;Build Execution Deployment-&gt;Toolchain 中将 Environment 选为 Cygwin，目录为 Cygwin 安装文件夹，Cmake Debugger 均在 <code>C:\cygwin64\bin</code> 目录下选择，Make、C Complier、C++ Complier 这三项留给 CLion 自动检测。</p>
</li>
<li>
<p>点击向上的箭头，把 Cygwin 设置为 Default，Cmake 会重新 Config 项目代码：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C:\SOFTWARE\cygwin64\bin\cmake.exe -DCMAKE_BUILD_TYPE=Debug -G <span class="string">"CodeBlocks - Unix Makefiles"</span> /cygdrive/d/LinuxShare/Tripod-cxx</span><br><span class="line">-- The C compiler identification is GNU <span class="number">9.2</span><span class="number">.0</span></span><br><span class="line">-- The CXX compiler identification is GNU <span class="number">9.2</span><span class="number">.0</span></span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++.exe</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++.exe -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>CLion</tag>
        <tag>Cygwin</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Quiz 题解 201~300</title>
    <url>/posts/7651320d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="Q-205">Q 205</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">array</span>[] = &#123; id % <span class="number">3</span>, id % <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="built_in">array</span>[<span class="number">0</span>]) &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="built_in">array</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：10<br>
array 是一个 <code>char</code> 类型的数组，但是却使用 unsigned int 初始化，unsigned int 转换为 <code>char</code> 属于 narrow 转换，即新类型并不能完整地表示原类型。<br>
但是代码中的源是一个常量表达式，它类型提升后的值是能够适合目标类型的。</p>
<h4 id="Q-206">Q 206</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(<span class="number">0</span>)[<span class="string">"abcdefghij"</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
sizeof 后可以跟着一元表达式，此处的一元表达式为 <code>(0)[&quot;abcdefghij&quot;]</code>；<br>
表达式 <code>E1[E2]</code> 等价于 <code>*((E1)+(E2))</code>，因此一元表达式结果为 <code>'a'</code>，sizeof 的结果为 1。</p>
<h4 id="Q-208">Q 208</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> default_constructed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> constructed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> assigned = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() &#123; default_constructed = <span class="literal">true</span>; &#125;</span><br><span class="line">    C(<span class="keyword">int</span>) &#123; constructed = <span class="literal">true</span>; &#125;</span><br><span class="line">    C&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> C&amp;) &#123; assigned = <span class="literal">true</span>; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, C&gt; m;</span><br><span class="line">    m[<span class="number">7</span>] = C(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; default_constructed &lt;&lt; constructed &lt;&lt; assigned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：111<br>
如果 key 不存在，operator [] 操作会插入一个元素，在类的情况下，元素是默认构造的，因此 m[7] 会调用 C 的默认构造函数（不管我们是否马上给它赋值），default_constructed 被设置为 true。<br>
表达式 C(1) 使用构造函数 C(int) 构造了一个 C 实例，constructed 被设置为 true。<br>
m[7] = C(1) 调用了赋值运算符，将新建的 C(1) 赋值给 map 中默认创建的 C，assigned 被设置为 true。<br>
如果不想在这个过程中调用到默认构造函数，可以使用下面的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m.insert(pair&lt;<span class="keyword">int</span>, C&gt;(<span class="number">7</span>, C(<span class="number">1</span>)));</span><br><span class="line">m.emplace(<span class="number">7</span>, C(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h4 id="Q-217">Q 217</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span>&amp; a = i &gt; <span class="number">0</span> ? i : <span class="number">1</span>;</span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：21<br>
本题的关键在于 a 是否是 i 的引用。<br>
条件表达式的类型和值类别都取决于第二和第三个表达式的类型和值类别，如果两者都是左值，结果会是左值，但是此时 i 和 1 分别是左值与右值。<br>
按照 <a href="https://timsong-cpp.github.io/cppwp/n4659/expr.cond" target="_blank" rel="noopener">expr.cond 8.16.6</a> 能够得出表达式 i &gt; 0 ? i : 1 的结果是一个纯右值，也就是临时量，因此 a 绑定的是一个临时变量，对 i 的修改不会影响到 a 的值。</p>
<h4 id="Q-219">Q 219</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T arg, Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg + sum&lt;T&gt;(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n1 = sum(<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0.5</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> n2 = sum(<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1 &lt;&lt; n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：32<br>
<code>T sum(T arg, Args... args)</code> 是一个迭代类型的函数模板，它会一直调用自身一直到 base case <code>T sum(T arg)</code>，当 T 的类型没有被指定时，它会被推导为 <code>sum</code> 的第一个参数，那么当 <code>sum</code> 迭代的时候，T 已经指定了相关类型，对于 n1 来说是 <code>double</code>，对于 n2 来说是 <code>int</code>。</p>
<h4 id="Q-220">Q 220</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'f'</span>; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'g'</span>; <span class="keyword">return</span> <span class="string">'g'</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'h'</span>; <span class="keyword">return</span> <span class="string">'h'</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> result = f() ? g() : h();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：ffh<br>
三元运算符的基本操作</p>
<h4 id="Q-222">Q 222</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    variant&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="keyword">char</span>&gt; v;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.index();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：0<br>
<code>variant</code> 是类型安全的 <code>union</code>，它可以在任意时间保存模板参数列表中某一类型的值或者空值，<code>variant</code> 不能存放引用、数组或 <code>void</code>，空 <code>variant</code> 应该写为 <code>std::variant&lt;std::monostate&gt;</code>。<br>
与 <code>union</code> 一样，<code>variant</code> 默认初始化为它模板类型列表中的第一个值，除非该项无法默认构造。<br>
<code>variant.index()</code> 返回当前保有项的下标，如果 <code>variant</code> 无值则返回 <code>variant_npos</code>。</p>
<h4 id="Q-224">Q 224</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Base::f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Derived::f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived object;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; object.f();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ((Base&amp;)object).f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：22<br>
首先，为纯虚函数提供定义是有效的，只要它不是在类的声明中实现即可。<br>
<code>((Base&amp;)object).f()</code> 在调用 f 之前将对象强制转换为 <code>Base&amp;</code>，但是由于 f 为虚函数，因此仍然输出 2。</p>
<h4 id="Q-225">Q 225</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    X() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    X(<span class="keyword">const</span> X &amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">    ~X() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4"</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125; object;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X(object);</span><br><span class="line">    object.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：11422<br>
首先，<code>struct X {...} object;</code> 定义了一个 X 类型的 object，调用 1 次构造函数；<br>
<code>X(object)</code> 是一个新变量 object 的声明，而不是复制构造一个 X 对象，如果写成 <code>X object</code> 就很清楚了，局部变量覆盖掉了全局变量，调用 1 次构造函数；<br>
最后别忘了调用两次析构函数。</p>
<h4 id="Q-226">Q 226</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    X() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    X(X &amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    X(<span class="keyword">const</span> X &amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">    X(X &amp;&amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4"</span>; &#125;</span><br><span class="line">    ~X() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span></span><br><span class="line">    <span class="keyword">mutable</span> X x;</span><br><span class="line">    Y() = <span class="keyword">default</span>;</span><br><span class="line">    Y(<span class="keyword">const</span> Y &amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Y y1;</span><br><span class="line">    Y y2 = <span class="built_in">std</span>::<span class="built_in">move</span>(y1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1255<br>
首先构造一个 Y 对象，Y 中有一个 X 类型的成员类，使用默认构造，输出 1。<br>
<code>std::move</code> 会将 y1 转变为右值，但是 Y 并没有移动构造函数，因此调用的是它的拷贝构造函数，这个隐式定义的拷贝构造函数将会执行 X 类成员对象的拷贝，现在的问题是到底会执行哪个拷贝构造函数。<br>
因为 X 有 <code>mutable</code> 修饰，因此 X 被认为是非 <code>const</code> 成员，重载解析认为 <code>X(X &amp;)</code> 更加合适，因为 <code>X(const X &amp;)</code> 还需要进行常数转换，所以此时输出 2。<br>
最后，因为调用的是拷贝构造函数，会输出两个 5，即析构两次。</p>
<h4 id="Q-227">Q 227</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Func = <span class="keyword">int</span>();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    Func f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S::f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
<code>using Func = int()</code> 是一种<strong>别名声明</strong>，这种声明方式既可以用于普通函数，也可以用于成员函数。</p>
<h4 id="Q-228">Q 228</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    X(Ts ...args) : Var(<span class="number">0</span>, args...) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> Var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X&lt;&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序行为未定义<br>
首先看一下 <code>X(Ts ...args) : Var(0, args...) {}</code> 的初始化，如果没有模板参数，该初始化是有效的，因为它只是 <code>Var(0)</code>，但是如果有任何模板参数，它们将扩展为无效的 int 类型的初始化，因此 X 唯一有效的特化就是没有参数的特化。因此 <code>X&lt;&gt; x</code> 在没有参数的情况下实例化模板是合法行为。<br>
C++ 标准规定，如果可变参数模板的每个有效特化都需要一个空的模板参数包，那么这个程序是病态的，无需诊断。因此不会报编译出错，而是程序行为未定义。</p>
<h4 id="Q-229">Q 229</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：5<br>
lambda 表达式的隐式捕获规则是它不会显示捕获 *this 和具有自动存储周期的变量，而此处的 a 具有静态存储周期，因此 lambda 不会隐式捕获 a。这里的 a 仅仅代表全局变量的引用。</p>
<h4 id="Q-230">Q 230</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> var1 : <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (&amp;x.var1 &lt; &amp;x.var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
取地址运算符 <code>&amp;</code> 不能用于位域</p>
<h4 id="Q-231">Q 231</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">override</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">override</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    virtual auto f() -&gt; override override&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">override</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived().f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
这道题的考点在于 <code>override</code> 能否用作类型名称。<br>
C++ 标准中的保留关键字不包含 <code>override</code>，只有出现在特定的上下文中时，<code>override</code> 和 <code>final</code> 才具有特殊意义，而 <code>override</code> 只有出现在声明符之后才具有特殊意义，如果我们用 type 替换类型名，<code>Drived::f</code> 可以写为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">virtual auto f() -&gt; type override&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">return</span> type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Q-233">Q 233</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = &amp;X::f;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; is_same_v&lt;<span class="keyword">decltype</span>(ptr), <span class="keyword">int</span>()&gt;</span><br><span class="line">         &lt;&lt; is_same_v&lt;<span class="keyword">decltype</span>(ptr), <span class="keyword">int</span>(X::*)()&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：00<br>
返回类型，参数类型，引用标识符，const &amp; volatile 标识符以及异常规范（不包括缺省参数）是函数类型的一部分。<br>
这说明代码中的 <code>ptr</code> 类型应该是 <code>int(X::f)() const&amp;&amp;</code>。</p>
<h4 id="Q-236">Q 236</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">auto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = Foo();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：A1<br>
转换函数能够有推断返回类型（只有转换函数模板不能这么做）。</p>
<h4 id="Q-248">Q 248</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="built_in">max</span> = <span class="built_in">std</span>::<span class="built_in">max</span>(x, y);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="built_in">min</span> = <span class="built_in">std</span>::<span class="built_in">min</span>(x, y);</span><br><span class="line"></span><br><span class="line">    x = <span class="number">11</span>;</span><br><span class="line">    y = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1111<br>
<code>std::max</code> 与 <code>std::min</code> 当两数相等时返回第一个数。</p>
<h4 id="Q-249">Q 249</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span> &amp;b = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：00<br>
对于 <code>T1&amp; cv1 = (T2)cv2</code> 来说，<strong>只有当 T1 与 T2 两个类型相同或者有继承关系，它们才是引用相关的，否则就是引用无关的</strong>。<br>
当 ·T1 与 T2 引用无关时，初始化的引用表达式会将 cv2 隐式转换出一个临时的 T1 类型的对象用于引用绑定，该对象与原对象没有关系。<br>
<code>'0'</code> 是 <code>char</code> 类型的字面量，ASCII 码为 48，a 中保存的为 <code>int</code> 类型的 48，但是 b 是 <code>char const</code> 类型的引用，因此 <code>char const</code> 与 <code>int</code> 不存在引用相关的关系，b 绑定的是一个 a 转换出来的临时 <code>char const</code> 类型对象，因此两次打印都为 0。</p>
<h4 id="Q-250">Q 250</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T...)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'A'</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T...)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'B'</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    foo(<span class="number">1</span>);</span><br><span class="line">    foo(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：AB<br>
第一个 <code>foo</code> 函数是老式的可变参数函数模板，接收类型为 T 的第一个参数，接着是可变数目的参数。<br>
第二个 <code>foo</code> 是可变参函数模板，它需要接收一个参数包。<br>
重载函数的时候，我们首先要找到对于给定的函数调用，哪些函数是可用的，然后再这些可用的函数中找到最合适的，对于函数模板来说，我们首先对模板参数进行推导来生成这些候选的特化函数。<br>
先看调用 <code>foo(1)</code>：<br>
对于第一个函数模板 <code>foo</code> 来说，T 被推导为 <code>int</code>，重载解析中参数列表 … 会被忽略，因为它没有匹配参数，最后得到 <code>foo(int)</code>。对于第二个函数模板 <code>foo</code> 来说，也会推断出 <code>foo(int)</code>，所以这两种都是可行的，我们必须找到一个更合适的。<br>
C++ 规范<strong>首先会比较哪一个模板的转换序列更佳</strong>，但是在这里两个模板的转换序列是一样的；<br>
<strong>接着比较哪一个模板更加特化</strong> - <em>more specialized</em> - 我们能够从 <code>foo2</code> 中推导出 <code>foo1</code> 却无法从 <code>foo1</code> 中推导出 <code>foo2</code>，因此对于 <code>foo(1)</code> 来说，第一个模板更合适。<br>
再看 <code>foo(1,2)</code>，第一个函数模板 <code>foo</code> 需要省略 <code>...</code> 来匹配转换序列，而第二个函数模板 <code>foo</code> 则不需要省略，从比较模板转换序列的角度来说，第二个 <code>foo</code> 更合适。</p>
<h4 id="Q-251">Q 251</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">f</span>(<span class="title">T</span>) &#123;</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> f&lt;&gt;(<span class="keyword">int</span>*) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">f</span>(<span class="title">T</span>*) &#123;</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">3</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    f( p );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：3<br>
重载解析值考虑函数模板，而不会考虑已经显式特化的 <code>void f&lt;&gt;(int*)</code>，因此是在 f(T) 和 f(T*) 中选择一个更好的函数模板。<br>
简单来说，f(T*) 接受的任何参数都会被 f(T) 接受，反之则不会，因此 f(T*) 是一个更加专业的模板，编译器更偏向选择它。<br>
现在重载解析选择了 <code>void f(T*)</code>，那么特化应该选择哪一个呢？<br>
<code>void f&lt;&gt;(int*)</code> 是 <code>void f(T)</code> 的显式特化，因为 f(T) 是在其之前的唯一函数模板声明，因为重载解析已经选择了另一个函数模板，编译器会使用该模板的隐式特化，打印 3。</p>
<h4 id="Q-252">Q 252</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="string">'3'</span> - <span class="string">'2'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
C++ 标准中，只能保证十进制数字之间的间隔相差 1，不能保证 <code>'b' - 'a' = 1</code>。</p>
<h4 id="Q-254">Q 254</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same_v&lt;<span class="keyword">void</span>(<span class="keyword">int</span>), <span class="keyword">void</span>(<span class="keyword">const</span> <span class="keyword">int</span>)&gt;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same_v&lt;<span class="keyword">void</span>(<span class="keyword">int</span>*), <span class="keyword">void</span>(<span class="keyword">const</span> <span class="keyword">int</span>*)&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：10<br>
当 T 和 U 类型相同时返回 true。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">U</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">constexpr</span> <span class="title">bool</span> <span class="title">is_same_v</span> = <span class="title">is_same</span>&lt;T, U&gt;:</span>:value;</span><br></pre></td></tr></table></figure>
<p>参数的常量不是函数类型的一部分，在生成函数类型时会删除顶级 cv 限定符。<br>
因此 <code>void(const int)</code> 的类型其实是 <code>void(int)</code>；<br>
而第二种情况中参数分别是指向 int 类型的指针和指向 const int 类型的指针，指针参数本身并不是 const，因此不需要删除 const 限定符；<br>
为什么参数的常量不是函数类型的一部分：当一个参数通过值传递时，就会复制该参数，而原始参数永远不会被修改。因此，对于调用者来说，参数是否为 const 并不重要，它只与函数内部相关。</p>
<h4 id="Q-259">Q 259</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"u"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span>          </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>)</span>         </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> y = <span class="number">2</span>;</span><br><span class="line">    f(x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序输出未定<br>
两个 <code>char</code> 类型的和并不是唯一确定的，虽然能肯定结果不是 <code>char</code>。<br>
在运算之前操作数会进行通用类型转换，而 <code>char</code> 在不同的场合可能会被提升为 <code>int</code> 或 <code>unsigned int</code>。</p>
<h4 id="Q-261">Q 261</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(<span class="string">"a"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ss.str();</span><br><span class="line">    ss &lt;&lt; <span class="string">"b"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ss.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：ab<br>
stringstream 有一个字符缓冲区，使用字符串初始化后它将使用该字符串初始化字符缓冲区，也就是字符 a。<br>
输出 a 后，操作符 <code>operator &lt;&lt;</code> 将向缓冲区的下一个位置写入字符，在本题中是缓冲区的开头，即写入 b 覆盖掉先前写的 a。<br>
我们可以通过下面的初始化方式来改变输出的结果：<br>
<code>std::stringstream ss(&quot;a&quot;, std::ios_base::out|std::ios_base::ate);</code><br>
其中 <code>std::ios_base::out|std::ios_base::ate</code> 表示写打开，并且打开后立即将光标放在文本末尾<br>
这样 a 不会被覆盖，输出 aab，第一个 a 来自 <code>ss.str()</code> 的第一个调用，ab 来自 <code>ss.str()</code> 的第二个调用。</p>
<h4 id="Q-264">Q 264</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    C() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> C c;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
由于 c 是 const 并且有默认构造函数，是不能默认初始化 c 的。<br>
C++ 标准规定，如果程序调用 <code>const</code> 限定类型 T 对象的默认初始化，那么 T 应该是 - <em>const-default-constructible</em> - 常量默认可构造的，常量默认可构造指的是<strong>类类型 T 的默认初始化调用了用户提供的 T 的构造函数</strong>或者<strong>每个直接的非变量非静态数据成员有默认成员初始化</strong>，如果要将本题修改正确有两种方法：<br>
给 <code>int i</code> 一个初始值 <code>int i{0}</code>；<br>
为 C 提供构造函数，移除 <code>= default</code>，执行 <code>C::C() = default</code>。</p>
<h4 id="Q-265">Q 265</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>*&amp;&amp;)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>*&amp;)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">    f(&amp;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
<code>&amp;c</code> 返回的是左值 c 的地址，这个地址是右值，因为它是一个 <code>operator&amp;</code> 返回的匿名临时对象。</p>
<h4 id="Q-273">Q 273</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span> <span class="keyword">new</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：main<br>
<code>sizeof</code> 运算符的操作数可以是一个表达式，也可以是一个带圆括号的 type-id。<br>
本题中 <code>sizeof</code> 的操作数是表达式 <code>new A</code>，它的类型是指向 A 对象的指针，指针的大小在每个平台是不同的，但是这里我们并不关系，因为无需打印它，问题是 <code>new A</code> 是否构造了一个新的 A 对象，我们是否需要析构它。<br>
C++ 标准规定，<code>sizeof</code> 的操作数如果是表达式，它会是一个未求值的操作数 - an unevaluated operand，因此表达式 <code>new A</code> 不会被求值，A 并不会被构造，表达式仅仅用于计算 <code>sizeof</code>。</p>
<h4 id="Q-283">Q 283</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">show_id</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~show_id() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; id; &#125;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] <span class="keyword">new</span> show_id[<span class="number">3</span>]&#123; &#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：210<br>
这道题的核心在于对象析构的顺序是怎样的，C++ 中，对象通常按照它们构造的相反顺序析构，包括 <code>delete[]</code> 运算。</p>
<h4 id="Q-284">Q 284</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">auto main() -&gt; int &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> out&#123;<span class="string">"Hello world"</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (out[out.<span class="built_in">size</span>()] == <span class="string">'\0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
当 pos 与字符串长度相等时，std::string 的 operator[size_type pos] 操作符必须返回一个空字符。</p>
<h4 id="Q-286">Q 286</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> short x=<span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> short y=<span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="keyword">auto</span> z=x*y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (z &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序行为未定义<br>
x 和 y 在运算之前都会被转换成另外一种类型，在大多数系统上这个类型为 <code>int</code>，即 32 位有符号。<br>
但 0xFFFF * 0xFFFF 的乘积为 4294836225 已经超过了 int 能表示的最大值 2147483647，有符号整数溢出，属于未定义行为。</p>
<h4 id="Q-287">Q 287</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::string_literals;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello world"</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"hello world"</span>s, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：hello world<br>
相同的构造函数在使用 C 风格字符串和使用 basic_string 所表现出来的行为是不一样的，对于前者来说，它表示到达此位置，对于后者来说，它表示从此位置开始。<br>
<code>basic_string(const charT* s, size_type n, const Allocator&amp; a = Allocator());</code><br>
第二个参数 n 表示从 C 样式字符串的开始处取多少个字符。<br>
<code>basic_string(const basic_string&amp; str, size_type pos, const Allocator&amp; a = Allocator());</code><br>
初始化从 pos 开始长度为 str.size() - pos 的字符串。</p>
<h4 id="Q-288">Q 288</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> I = <span class="number">1</span>, J = <span class="number">1</span>, K = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (++I || ++J &amp;&amp; ++K);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; I &lt;&lt; J &lt;&lt; K;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1211<br>
运算符 &amp;&amp; 的优先级高于 ||，原表达式等价于 <code>(++I || (++J &amp;&amp; ++K))</code>，先计算 ++I，表达式为 true，后面的表达式被短路，不会再计算了。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Quiz</tag>
        <tag>Programming-Language</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Quiz 题解 101~200</title>
    <url>/posts/467b42a7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="Q-105">Q 105</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">label:</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">if</span> (i--)</span><br><span class="line">        <span class="keyword">goto</span> label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：aAaA<br>
C++ 标准对于 <code>goto</code> 语句有如下要求：<br>
具有自动存储期的变量会在跳转之前被销毁而不是在跳转之后被销毁。</p>
<h4 id="Q-106">Q 106</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="keyword">int</span> y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序链接错误，行为未定义<br>
C++ 为了支持函数重载，其中的函数在被 C++ 编译后在符号库中的名字与 C 语言的不同。为了实现 C++ 与 C 的混合编程，C++ 引入了 <code>extern &quot;C&quot;</code>，被 <code>extern &quot;C&quot;</code> 修饰的函数或者变量是按照C语言方式编译和链接的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;       <span class="comment">//声明一个全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a = <span class="number">0</span>;   <span class="comment">//定义全局变量并给初值</span></span><br></pre></td></tr></table></figure>
<p>原代码中的<code>extern &quot;C&quot; int x;</code> 表示被它修饰的目标是 extern 的；其次，被它修饰的目标代码是 “C” 的。所以说这条语句表示的是<strong>声明一个 C 类型的变量</strong>。<br>
而<code>extern &quot;C&quot; { int y; }</code> 表示则的是定义一个 C 类型的变量。</p>
<h4 id="Q-107">Q 107</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f"</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g"</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    h(&#123;f(), g()&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：fg<br>
这道题的考点是初始化列表中参数的计算顺序，C++ 标准规定，初始化列表中的子句按照它们出现的顺序进行计算。</p>
<h4 id="Q-109">Q 109</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_with</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(T)&gt; f, T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">print</span> = [] (<span class="keyword">int</span> x) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x; &#125;;</span><br><span class="line">    call_with(<span class="built_in">print</span>, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
编译器会推导每个参数的 <code>T</code> 并检查推导类型是否匹配。<br>
<code>lambda</code> 是完全不同的类型，不能与 <code>std::function&lt;void(T)</code>&gt; 匹配，这种情况需要将第一个参数转换为非推导上下文 - <em>nondeduced context</em> - 来解决。<br>
非推导上下文是一种类型的嵌套名称说明符。<br>
举几个例子：<br>
类型 <code>A&lt;T&gt;::B&lt;T2&gt;</code> 中 <code>T</code> 与 <code>T2</code> 都是非推导的；<br>
<code>void f(typename A&lt;T&gt;::B, A&lt;T&gt;)</code> 中的第一个 <code>T</code> 是非推导的，第二个 <code>T</code> 是推导的。<br>
使用一个 helper struct 辅助结构模板可以将 <code>std::function&lt;void(T)&gt;</code> 转换为非推导上下文：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_identity</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_with</span><span class="params">(<span class="keyword">typename</span> type_identity&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(T)&gt;&gt;::type f, T val)</span> </span>&#123;</span><br><span class="line">    f(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，还可以像下面这样明确指定模板参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">call_with&lt;<span class="keyword">int</span>&gt;(<span class="built_in">print</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Q-111">Q 111</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
<code>continue</code> 语句会将控制传递给最小封闭迭代语句的循环延续部分，换句话说，就是<strong>循环的末尾而不是起始</strong>。</p>
<h4 id="Q-112">Q 112</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    A(A&amp;&amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a;</span><br><span class="line">    B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4"</span>; &#125;</span><br><span class="line">    B(<span class="keyword">const</span> B&amp; b) : a(b.a) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5"</span>; &#125;</span><br><span class="line">    B(B&amp;&amp; b) : a(b.a) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"6"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    B b2 = <span class="built_in">std</span>::<span class="built_in">move</span>(b1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1426<br>
b1 默认构造成功之前 a 先默认构造，因此输出 14.<br>
接着用移动构造函数初始化 b2，<code>std::move(b1)</code> 将 b1 的引用转化为一个将亡值，在 B 的移动构造函数中，a 在初始化列表中被构造，尽管此处的 b 是一个绑定了右值的右值引用，b 本身仍然是一个左值，因此调用的是 A 的拷贝构造函数，最后输出 26。</p>
<h4 id="Q-113">Q 113</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">0.0</span>);</span><br><span class="line">    f(<span class="number">0</span>);</span><br><span class="line">    f&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：132<br>
对于 f(0.0) 来说，T 被推导为 double，函数模板的一个特化被加入到重载解析的候选中，在所有的候选函数中 <code>f(double)</code> 是一个最好的匹配，输出 1。<br>
对于 f(0) 来说，函数模板中的 T 被推导为 int，函数模板的一个特化 <code>void f(int)</code> 被加入到重载解析的候选中，另一个则是非模板函数的 <code>void f(int)</code>，C++ 标准规定，一个非模板函数比一个特化的模板函数更加适合重载，因此输出 3。<br>
最后 f&lt;&gt;(0) 中的 &lt;&gt; 是一个空模板参数列表，可以为模板函数指定，但是不可以为非模板函数指定，因此 f&lt;&gt;(0) 显式地要求函数模板，C++ 标准规定，一个空的模板参数列表可以用于指定使用特化的函数模板，即使同时存在非模板函数。<br>
T 被推导为 int，int 的特化是唯一的候选项，打印 2。</p>
<h4 id="Q-114">Q 114</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>       </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;C&gt; v;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;C&gt; u;</span><br><span class="line">    C *<span class="keyword">const</span> p;</span><br><span class="line">    S() : v(<span class="number">1</span>), u(<span class="keyword">new</span> C()), p(u.<span class="built_in">get</span>()) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    <span class="keyword">const</span> S &amp;r = s;</span><br><span class="line"></span><br><span class="line">    s.v[<span class="number">0</span>].foo();</span><br><span class="line">    s.u-&gt;foo();</span><br><span class="line">    s.p-&gt;foo();</span><br><span class="line"></span><br><span class="line">    r.v[<span class="number">0</span>].foo();</span><br><span class="line">    r.u-&gt;foo();</span><br><span class="line">    r.p-&gt;foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：AAABAA<br>
C++ 标准规定，cv 限定符应用于指针而不是指向的对象。<br>
因此对于原始指针和引用，包括试图模拟它们的标准类型 <code>std::unique_ptr</code> 来说，<code>const</code> 限定符属于浅限定，而对于标准容器来说，<code>const</code> 则不是浅限定。<br>
上面的代码中对象 s 是 non-const 的，因此该对象的成员都保留了它的默认常量属性，即 non-const，并且所有对该对象成员的调用都使用 <code>C::foo()</code> 的 non-const 版本。<br>
然而，r 是对象 s 的常量引用，const 限定符改变了它的成员 v 的行为，此时 <code>std::vector</code> 的 <code>operator[]</code> 返回的是 <code>const C&amp;</code>，因此调用的是 <code>C::foo()</code> 的 const 版本，同时 r 的 const 属性也传递给它的成员 u 和 p，也就是说指针本身变成了常量，但指向的对象并不是常量，因此它们仍然调用 <code>C::foo()</code> 的 non-const 版本。<br>
最后，还要注意 <code>C* const p</code> 是一个指向非常量对象的常量指针。</p>
<h4 id="Q-115">Q 115</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：d<br>
浮点数字面量的类型为 <code>double</code>，除非明确地用后缀指定。</p>
<h4 id="Q-116">Q 116</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y</span><span class="params">(<span class="keyword">int</span> &amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y</span><span class="params">(<span class="keyword">int</span> &amp;&amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">int</span> <span class="title">f</span>(<span class="title">T</span> &amp;&amp;<span class="title">x</span>) &#123;</span> <span class="keyword">return</span> y(x); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">int</span> <span class="title">g</span>(<span class="title">T</span> &amp;&amp;<span class="title">x</span>) &#123;</span> <span class="keyword">return</span> y(<span class="built_in">std</span>::<span class="built_in">move</span>(x)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">int</span> <span class="title">h</span>(<span class="title">T</span> &amp;&amp;<span class="title">x</span>) &#123;</span> <span class="keyword">return</span> y(<span class="built_in">std</span>::forward&lt;T&gt;(x)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f(i) &lt;&lt; f(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g(i) &lt;&lt; g(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; h(i) &lt;&lt; h(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：112212<br>
<strong>模板化函数中的 T&amp;&amp; 不一定表示右值引用，如果用左值实例化，它会坍缩成左值引用，如果用右值实例化，则会坍缩成右值引用</strong>。<br>
这三个函数分别使用左值和右值调用了一次，三种情况下都会分别坍缩成左值和右值引用，但是<strong>在函数内部，x 本身就是左值，不管它的类型是左值引用还是右值引用</strong>。</p>
<h4 id="Q-118">Q 118</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(short num)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"abc"</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误，<code>print(0)</code> 重载函数调用不明确<br>
空指针常量既可以是一个值为 0 的整型字面量，也可以是 std::nullptr_t 类型的右值。<br>
因此 0 既可以隐式转化为任何指针类型，也可以隐式转化为 short 类型。</p>
<h4 id="Q-119">Q 119</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * p = &amp;p;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">bool</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
p 中保存的是它自己的地址。</p>
<h4 id="Q-120">Q 120</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    x = a, b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：10<br>
逗号运算符的优先级在 C++ 中是最低的。</p>
<h4 id="Q-121">Q 121</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  x = (a, b);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：20<br>
先执行完括号内的表达式，然后将 b 赋值给 x。</p>
<h4 id="Q-122">Q 122</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">unsigned</span> ll)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo(<span class="number">2u</span>ll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：2<br>
默认情况下 <code>signed</code> <code>unsigned</code> <code>long</code> <code>short</code> 都暗指 <code>int</code>，因此在这些符号类型之后出现的类型名称均被视为声明的名称。<br>
因此 <code>void foo(unsigned ll)</code> 被编译器认为是需要一个 <code>unsigned(int)</code> 类型的变量，名称为 <code>ll</code>。</p>
<h4 id="Q-124">Q 124</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = A&gt;</span><br><span class="line">struct X;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&lt;A&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&lt;B&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = B&gt; class C&gt;</span><br><span class="line"><span class="keyword">void</span> g() &#123;</span><br><span class="line">    C&lt;&gt;::f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    g&lt;X&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：2<br>
模板的模板参数为 C，C 的范围是函数 g，因此默认的 T = B 被作为 C 的默认参数；<br>
也就是说，g 需要模板参数 C，此时传入 X，而 X 作为模板参数还需要一个参数，默认是 A，但是调用 <code>C::f</code> 时的默认参数为 B，因此调用的是 <code>X&lt;B&gt;::f</code>，因此输出 2。</p>
<h4 id="Q-125">Q 125</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">f</span>(<span class="title">T</span>) &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">1</span>);</span><br><span class="line">    f(<span class="number">1.0</span>);</span><br><span class="line">    f(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：112<br>
每个实例化后的函数模板都有它自己的一份静态变量的拷贝。<br>
本题中我们有两个 f 的实例化，一个 T = int，另一个 T = double，f(double) 中的静态变量 i 与 f(int) 中的静态变量 i 不是同一个 i。</p>
<h4 id="Q-126">Q 126</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foobar</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> foobar::x = foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foobar::x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：11<br>
在类的静态成员定义中使用的名称和类中成员函数的名称是一致的，换句话说，尽管 <code>foo()</code> 调用发生在类外，但是它位于静态数据成员的定义中，可以看作 <code>foo()</code> 是 <code>footbar</code> 的成员函数调用，而不是全局 <code>foo()</code> 的调用。</p>
<h4 id="Q-127">Q 127</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, &amp;j = i;</span><br><span class="line">    [=] &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; is_same&lt;<span class="keyword">decltype</span>   ((j)),     <span class="keyword">int</span>         &gt;::value</span><br><span class="line">            &lt;&lt; is_same&lt;<span class="keyword">decltype</span>   (((j))),    <span class="keyword">int</span>      &amp;  &gt;::value</span><br><span class="line">            &lt;&lt; is_same&lt;<span class="keyword">decltype</span>  ((((j)))),   <span class="keyword">int</span> <span class="keyword">const</span>&amp;  &gt;::value</span><br><span class="line">            &lt;&lt; is_same&lt;<span class="keyword">decltype</span> (((((j))))),  <span class="keyword">int</span>      &amp;&amp; &gt;::value</span><br><span class="line">            &lt;&lt; is_same&lt;<span class="keyword">decltype</span>((((((j)))))), <span class="keyword">int</span> <span class="keyword">const</span>&amp;&amp; &gt;::value;</span><br><span class="line">    &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：00100(01000)<br>
这其实是一道有点争议的题目，答案是 00100，VS2019 上是 01000。<br>
关键在于 lambda 表达式中捕获的 j 是否带有 const 限定符。<br>
因为 lambda 没有声明为 mutable，因此闭包类型重载 operator() 会是一个 const 成员函数。<br>
而当表达式出现在 const 成员函数中时，这个表达式也是 const 表达式。<br>
仅供参考。</p>
<h4 id="Q-129">Q 129</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; delimiters = &#123; <span class="string">","</span>, <span class="string">";"</span> &#125;;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; delimiters[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序行为未定义<br>
这道题用两个字符串字面量来初始化 <code>vector&lt;char&gt;</code>，模板类 <code>template &lt;class T&gt; vector</code> 的初始化列表的构造函数为 <code>vector(initializer_list&lt;T&gt;)</code> ，本题中为 <code>vector(initializer_list&lt;char&gt;)</code>，而字符串字面量的类型为 - <em>array of n const char</em> - 常量字符数组，并不匹配。<br>
但是这题为什么没有出现编译错误，是因为编译器找到了另一个匹配的构造函数。<br>
C++ 标准规定，当类型为 T 的类对象采用列表初始化的时候，重载解析会有两个选择构造函数的阶段：<br>
首先，候选函数是类 T 的初始化列表构造函数，参数列表只有一个参数，即初始化列表；<br>
如果没有找到合适的构造函数，重载解析会从类 T 的所有构造函数中寻找候选函数，参数列表由初始化列表中的元素组成；<br>
对于本题来说，<code>template &lt;class InputIterator&gt; vector(InputIterator first, InputIterator last)</code> 恰好满足第二种情况，构造函数认为它传入了两个正确的迭代器类型，但是其实这两个迭代器分别属于两个不同的序列，因此这个程序行为是未定义的。</p>
<h4 id="Q-130">Q 130</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adl</span><span class="params">(T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"T"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_adl</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    adl(S());</span><br><span class="line">    adl(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adl</span><span class="params">(S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"S"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    call_adl(S());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：TS<br>
当查找模板定义中使用的名称的声明时，对于非依赖模板参数的名称查找使用的是通常的查找规则，而依赖模板参数的名称查找会延迟到实际模板参数已知时。<br>
adl(s()) 属于非依赖调用，因此在定义函数模板的时候就进行了名称查找；<br>
adl(t) 属于依赖调用，该调用的解析推迟到模板实例化之后；<br>
当在定义函数模板时查找 adl 时，存在的 adl 的唯一版本就是 adl(t)，此时 adl(S) 还不存在，因此只会调用 adl(T)。</p>
<h4 id="Q-131">Q 131</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    C(<span class="keyword">double</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">c1</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    C c2 = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：id<br>
由于 explicit 关键字的存在，<code>C c2 = 7</code> 中是不会调用隐式转化构造函数的，在第二种情况下整型字面量会被转化为 <code>double</code> 类型构造函数。</p>
<h4 id="Q-132">Q 132</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i = foo())</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：11<br>
<code>foo()</code> 被调用了两次</p>
<h4 id="Q-133">Q 133</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>; &#125;</span><br><span class="line">    B(<span class="keyword">const</span> B &amp;) &#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"b"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() &#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"C"</span>; &#125;</span><br><span class="line">    C(<span class="keyword">const</span> C &amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"c"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span>B,C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D() &#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"D"</span>; &#125;</span><br><span class="line">    D(<span class="keyword">const</span> D &amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d1;</span><br><span class="line">    <span class="function">D <span class="title">d2</span><span class="params">(d1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：ABCDABCd<br>
构造 d1 的时候，派生类是按照基类说明列表中的顺序来构造的，因此输出 ABCD；<br>
对于 d2 来说，一个隐式定义的拷贝/移动构造函数是会调用它基类的拷贝/移动构造函数的，但是如果提供了一个用户自定义的拷贝构造函数，就必须要手动设置调用基类的拷贝/移动构造函数。</p>
<h4 id="Q-135">Q 135</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">bool</span>,<span class="keyword">int</span>&gt; mb = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mb.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mi = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mi.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：13<br>
<code>map</code> 中的 <code>key</code> 是唯一的，而 mb 中的三个 <code>key</code> 都是 <code>true</code>，因此 size 为 1。</p>
<h4 id="Q-140">Q 140</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_size_1</span><span class="params">(<span class="keyword">int</span>* arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_size_2</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_size_3</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//Assume sizeof(int*) != sizeof(int[10])</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">sizeof</span>(<span class="built_in">array</span>) == get_size_1(<span class="built_in">array</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">sizeof</span>(<span class="built_in">array</span>) == get_size_2(<span class="built_in">array</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">sizeof</span>(<span class="built_in">array</span>) == get_size_3(<span class="built_in">array</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：001<br>
首先，<code>sizeof(array)</code> 返回的是数组 array 的大小。<br>
在 <code>get_size_3</code> 函数中，参数是一个大小为 10 的 <code>int</code> 类型数组的引用，C++ 标准规定，对一个引用类型使用 <code>sizeof</code> 运算符，结果是被引用类型的大小，因此 <code>get_size_3</code> 返回 10。<br>
而 <code>get_size_1</code> <code>get_size_2</code> 的参数均为指针，其中 <code>get_size_2</code> 的参数会从数组退化成指针，<code>sizeof</code> 运算符返回指针变量的大小。</p>
<h4 id="Q-144">Q 144</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt;::digits==<span class="number">63</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::digits==<span class="number">31</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;::digits==<span class="number">32</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">int</span> i = <span class="number">-0xffffffff</span>; i ; --i) &#123;</span><br><span class="line">            N[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        N[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; N[<span class="number">0</span>] &lt;&lt; N[<span class="number">1</span>] &lt;&lt; N[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：010<br>
无符号量的负值是从 2 ^ n 减去它的值计算出来的，其中 n 是提升操作数中的位数。<br>
本题中 n 为 32，因此 i = 1。</p>
<h4 id="Q-145">Q 145</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> &#123;</span></span><br><span class="line">    E() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    E(<span class="keyword">const</span> E&amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    ~E() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> E();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：13<br>
这道题的关键在于 E() 到底是什么。<br>
C++ 标准规定，纯右值是一个表达式，该表达式的值用于初始化一个对象、位域或者计算运算符的操作值。<br>
return 语句通过拷贝构造函数将函数调用对象初始化为全局左值或纯右值。<br>
E() 只是一个纯右值。</p>
<h4 id="Q-147">Q 147</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">//What is wrong here??/</span></span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
<code>??/</code> 在 C++17 中已经被 <code>\</code> 取代了，具体可以参考 <a href="https://stackoverflow.com/questions/1234582/purpose-of-trigraph-sequences-in-c" target="_blank" rel="noopener">C++ Trigraph</a></p>
<h4 id="Q-148">Q 148</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (a + a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序行为未定义<br>
这里的问题不是缺少变量 a 的初始化 - 这里会隐式初始化为 0，而是两次访问变量 a 的顺序没有排序。<br>
C++ 标准规定，访问 volatile 类型的 glvalue（左值或将亡值）会产生副作用，针对同一片内存区域的无序访问属于未定义行为。</p>
<h4 id="Q-151">Q 151</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_signed&lt;<span class="keyword">char</span>&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序输出未指定<br>
char 对象能否保存负值完全是由实现决定的。</p>
<h4 id="Q-152">Q 152</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::is_signed&lt;<span class="keyword">char</span>&gt;::value)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">char</span>, <span class="keyword">signed</span> <span class="keyword">char</span>&gt;::value;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">char</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;::value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：0<br>
<code>char</code> <code>unsigned char</code> <code>signed char</code> 是三种完全不同的类型。</p>
<h4 id="Q-153">Q 153</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">"X"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
字符串字面量的类型为 <code>const</code> 字符数组，虽然大多数编译器允许 <code>char const []</code> 类型转换为 <code>char*</code>，但是 C++11 开始这是不合法的操作。</p>
<h4 id="Q-157">Q 157</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; (&amp;<span class="keyword">typeid</span>(A) == &amp;<span class="keyword">typeid</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：输出不确定<br>
<code>typeid</code> 表达式的返回值是一个静态类型 <code>const std::type_info</code> 的左值，因此我们比较的是两个指向 <code>const std::type_info</code> 的指针，C++ 标准中并不保证所有针对相同类型的 <code>typeid</code> 表达式的计算都会引用同一个 <code>std::type_info</code> 类型的实例，因此此处答案是不确定的。</p>
<h4 id="Q-158">Q 158</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"a"</span>; &#125;</span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"b"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Foo&gt; <span class="title">bar</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：aaaaa<br>
从 C++11 开始，<code>std::vector</code> 具有只有一个参数的构造函数：<code>explicit vector(size_type n, const Allocator&amp; = Allocator())</code>，用于创建一个<strong>具有 n 个已经值初始化了的元素</strong>的 vector，每一个值初始化的元素都需要调用默认构造函数。</p>
<h4 id="Q-159">Q 159</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">    f(i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：34<br>
C++ 标准规定，在调用函数时，进入函数之前，对函数所有参数的计算都已经结束，因此进入函数 <code>f(i++)</code> 之前 i 已经自增完成，所以函数中的 i 值为 4。</p>
<h4 id="Q-160">Q 160</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> a = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> a = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A *b = <span class="keyword">new</span> B;</span><br><span class="line">    b-&gt;foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：B1<br>
本题创建了一个 B 类对象，然后用 A 指针指向它，由于 foo 是虚函数，因此父类指针指向子类对象，调用的是 B 类中的 foo，但是虚函数调用中使用的缺省参数由表示对象的指针或者引用的静态类型决定，因此这里使用的是 A 类的默认参数，a 等于 1。</p>
<h4 id="Q-161">Q 161</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                ++i;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">while</span> (--n &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：5<br>
C++ 标准规定，<code>switch</code> 语句后可以跟随任何有效语句，包括复合语句，<code>do-while</code> 的执行不会被 <code>case</code> 标签所改变。</p>
<h4 id="Q-162">Q 162</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B&lt;T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
根据 C++ 标准，在类或类模板的定义中，如果基类依赖于模板参数，则在类模板的定义处以及类模板的实例化过程中不会检查基类的范围。因此当编译器看到 <code>g()</code> 调用 <code>f()</code> 的时候，应该从全局作用域中选择一个。</p>
<h4 id="Q-163">Q 163</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> foo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span>&amp; <span class="title">getFoo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> foo; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printFoo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bar = a.getFoo();</span><br><span class="line">    ++bar;</span><br><span class="line"></span><br><span class="line">    a.printFoo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：0<br>
对于函数模板来说，每个已声明变量的类型都是由占位符类型推导决定的。<br>
下面两种写法是一致：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Method 1</span></span><br><span class="line"><span class="keyword">auto</span> bar = a.getFoo();</span><br><span class="line"><span class="comment">// Method 2</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f</span><span class="params">(T t)</span></span>;</span><br><span class="line">f(a.getFoo());</span><br></pre></td></tr></table></figure>
<p>而函数模板参数的推断过程会尝试着去找到一个参数<strong>使得推断出的参数与调用的参数保持一致</strong> - <em>the deduction process attempts to find template argument values that will make the deduced A identical to A where A is the type of the argument of the call</em><br>
<code>getFoo()</code> 返回 <code>int&amp;</code> 类型，C++ 标准规定，如果表达式最初具有 <code>T&amp;</code> 类型，在进行任何 further analysis 之前类型都会被调整为 <code>T</code>。<br>
因此 <code>a.getFoo()</code> 的类型被推断为 <code>int</code>，也就是说 <code>f(T t)</code> 中 <code>T</code> 也为 <code>int</code>，<code>bar</code> 的类型也为 <code>int</code>。</p>
<h4 id="Q-174">Q 174</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    f(x,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：01<br>
变量 a 和 b 都绑定在同一个 x 上，const int&amp; b 表示函数中不能通过引用修改传入参数的值。</p>
<h4 id="Q-177">Q 177</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;::digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：输出不确定（可能为 8）<br>
大概率的搞笑题，<code>unsigned char</code> 和 <code>char</code> 大小相同，<code>char</code> 的大小足以存储实现的基本字符集的任何成员即可。</p>
<h4 id="Q-178">Q 178</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a+++++b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
<code>a+++++b</code> 会被解析为 <code>a++ ++ + b</code>，但是 a++ 的结果是个纯右值，而后置自增运算符需要参数为可修改的左值，因此编译错误。</p>
<h4 id="Q-184">Q 184</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    d.f(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：d<br>
重载解析之所以没有选择明显更优的函数 void f(int)，因为 void f(int) 根本不在重载解析的范围内。<br>
派生类中引入函数名称 f 时将会隐藏基类中的同名函数。</p>
<h4 id="Q-185">Q 185</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> stat = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stat++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    f&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    f&lt;<span class="keyword">const</span> <span class="keyword">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：010<br>
<code>f&lt;int&gt;()</code> 和 <code>f&lt;const int&gt;()</code> 是不同的函数，因此它们的 static int stat 不是共享的。</p>
<h4 id="Q-186">Q 186</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">takes_pointer</span><span class="params">(<span class="keyword">int</span>* pointer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeid</span>(pointer) == <span class="keyword">typeid</span>(<span class="keyword">int</span>[])) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeid</span>(pointer) == <span class="keyword">typeid</span>(<span class="keyword">int</span>*)) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'p'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">takes_array</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeid</span>(<span class="built_in">array</span>) == <span class="keyword">typeid</span>(<span class="keyword">int</span>[])) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeid</span>(<span class="built_in">array</span>) == <span class="keyword">typeid</span>(<span class="keyword">int</span>*)) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'p'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* pointer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    takes_pointer(<span class="built_in">array</span>);</span><br><span class="line">    takes_array(pointer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">typeid</span>(<span class="keyword">int</span>*) == <span class="keyword">typeid</span>(<span class="keyword">int</span>[]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：pp0<br>
接收指针作为参数的函数也能够使用数组来调用，反之亦然。<br>
先看 <code>takes_pointer(array)</code>，当函数需要一个指针作为参数时，如果传入的是一个数组，该数组会退化成一个指针。<br>
更准确地说，一个元素类型为 T 的数组类型的左值或者右值可以转化为指向 T 类型的指针的纯右值。<br>
因此数组 array 会转化成指向 <code>int</code> 类型的指针，这个指针是一个纯右值。<br>
再看 <code>takes_array(pointer)</code>，C++ 标准规定，在确定了每个参数的类型后，任何 T 类型的数组都会被转换成 T 类型的指针。<br>
因此 <code>takes_array(int array[])</code> 中的 array[] 其实已经被转换为 <code>int*</code> 了。</p>
<h4 id="Q-187">Q 187</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    C() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    C(<span class="keyword">const</span> C&amp; other) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    C&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> C&amp; other) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c1;</span><br><span class="line">    C c2 = c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：12<br>
拷贝构造指的是通过 <em>brace-or-equal-initializer</em> 方式初始化的构造，<code>C c2 = c1</code> 就是通过 equal 来<strong>构造一个新的对象</strong>。</p>
<h4 id="Q-188">Q 188</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">"Hello"</span>);</span><br><span class="line">    a[<span class="number">4</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：未定义行为<br>
修改字符串字面量是未定义行为，实际上，字符串字面量的存储是在只读存储区内。<br>
此外，对于使用 <code>const_cast</code> 去除 <code>const</code> 限定的目的绝对不是为了修改它的内容，只是出于无奈。</p>
<h4 id="Q-190">Q 190</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A(<span class="keyword">int</span> i) : m_i(i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_i &gt; <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1(1), a2(2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a1 + a2 &lt;&lt; (a1 == a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：21<br>
<code>a1 + a2</code> 和 <code>a1 == a2</code> 使用的都是 <code>int</code> 类型的内建运算符。a1 和 a2 先是隐式转换为 <code>bool</code> 然后再隐式转换为 <code>int</code>。<br>
由于结构体 A 并没有重载 <code>operator+</code>，使用的是 <code>int</code> 的内建运算符，那么我们有什么方法可以将 a1 和 a2 转换成语 <code>operator+</code> 兼容呢，首先尝试的是用户自动一的转换函数 <code>bool()</code>，因为一个纯右值的 <code>bool</code> 量能够转换成 <code>int</code> 类型，因此隐式转换继续执行，true 会被转换为 1，false 会被转换为 0，<code>operator==</code> 也是同样的转换方式。</p>
<h4 id="Q-191">Q 191</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; B::x;</span><br><span class="line">    A::x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; B::x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：01<br>
出现在不同命名空间范围内的具有相同名称的变量的两个声明指的是同一个变量。</p>
<h4 id="Q-192">Q 192</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    g(f1(), f2());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    h();</span><br><span class="line">    h();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (v[<span class="number">0</span>] == v[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序行为未指定<br>
函数参数表达式的计算顺序是未指定的，我们唯一能确定的就是函数 f1 和 f2 会在函数 g 执行之前执行完毕。</p>
<h4 id="Q-193">Q 193</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &lt;%<span class="number">1</span>%&gt;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a&lt;:<span class="number">0</span>:&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
C++ 标准为一些标点符号提供了可选标记，原代码等价于下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>除了拼写不同，这些符号的行为都是相同的，即：<br>
<code>&lt;%%&gt;</code> 等价于 <code>{}</code><br>
<code>&lt;::&gt;</code> 等价于 <code>[]</code></p>
<h4 id="Q-195">Q 195</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_pointer_v&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：0<br>
<code>std::is_pointer_v</code> 用于判断参数是否为指针类型。<br>
nullptr 是类型为 <code>std::nullptr_t</code> 的纯右值，该类型不是指针类型，事实上 nullptr 是一个空指针常量，它能够被转换为指针。</p>
<h4 id="Q-196">Q 196</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> x &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> y &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> x::C&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(x::C());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
函数 f(x::C()) 调用没有指定命名空间，但是 C++ 中使用了依赖于实参名字的查找，函数参数的命名空间被添加到函数命名空间的查找中，因为我们将 x::C() 传递给了函数 f，因此在编译函数 f 时也会查找命名空间 x 并找到 x::f。</p>
<h4 id="Q-197">Q 197</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; i = j, j;</span><br><span class="line">    j = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：12<br>
局部变量 j 的作用域是从它定义开始一直到 main 函数结束，在这段时间内，局部的 j 会将全局的 j 覆盖掉。<br>
因此引用 i 绑定的是全局的 j，j = 2 修改的是局部的 j，因此答案为 12。</p>
<h4 id="Q-198">Q 198</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="keyword">int</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="keyword">int</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; B::x;</span><br><span class="line">    A::x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; B::x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
C++ 标准规定，出现在不同命名空间范围中的具有相同名称的 C 语言链接的变量的两个声明指的是同一个变量。因此 A::x 和 B::x 表示的是同一个变量。<br>
这道题与 #191 的不同之处在于 int x 是一个定义而不是声明，直接包含在链接规范中的声明被看作包含 extern 说明符，而变量 x 并没有直接包含在链接规范中，因此它没有隐式的 extern 说明，这两个 x 被看作重复定义。<br>
具体的区别还可以参考下面的代码来理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// declaration</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// definition</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Quiz</tag>
        <tag>Programming-Language</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Quiz 题解 001~100</title>
    <url>/posts/e24af74a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="Q-001">Q 001</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">f</span>(<span class="title">T</span> &amp;<span class="title">i</span>) &#123;</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">    f(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
<code>template &lt;&gt; void f(const int &amp;i)</code> 中 T 的类型为 <code>const int</code>，<code>f(i)</code> 中的 i 为 <code>int</code> 型，模板参数推导出 <code>T = int</code>。</p>
<h4 id="Q-002">Q 002</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="string">"foo"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *bar = <span class="string">"bar"</span>;</span><br><span class="line">    f(bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：22<br>
字符串字面量不是 <code>std::string</code> 类型，而是一个 <code>const char*</code> 类型，如果要让编译器选择 <code>f(const std::string &amp;)</code>，用户必须通过转换来创造一个临时的 <code>std::string</code> 对象，而使用 <code>f(const void *)</code> 不需要用户自定义的转换。</p>
<h4 id="Q-003">Q 003</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">unsigned</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">-2.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
重载选择不明确，调用 f(-2.5) 有两个选项，为了让编译器选择其中一个，必须要一个比另外一个更加合适才行。<br>
而此题中 double 类型转换成 int 和 unsigned int 都属于浮点数-整数转换，它们的 rank 是相同的，没有发生一个转换优于另一个转换的情况，因此编译器不知道如何进行重载选择。</p>
<h4 id="Q-004">Q 004</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">2.5</span>);</span><br><span class="line">    f(<span class="number">2.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：21<br>
浮点数字面量 2.5 是 <code>double</code> 类型的，2.5f 是 <code>float</code> 类型的</p>
<h4 id="Q-006">Q 006</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：012012<br>
前置和后置在执行完之后 i 的值都是相同的。</p>
<h4 id="Q-007">Q 007</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A &amp;a)</span> </span>&#123; a.f(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    g(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：A<br>
因为 <code>A::f()</code> 不是虚函数，因此即使有基类指针或引用指向 B 类，调用的也总是 <code>A::f()</code>。</p>
<h4 id="Q-008">Q 008</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A a)</span> </span>&#123; a.f(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    g(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：A<br>
<code>g(A a)</code> 是通过值传递接收一个 A 类型的对象而不是通过引用传递，因此这里会调用 A 的拷贝构造函数生成一个临时对象传给函数，因此函数 <code>g(A a)</code> 中的 a 是一个全新的 A，这也是常见的对象切片问题。</p>
<h4 id="Q-009">Q 009</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = f(a, a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：428<br>
传入的两个参数都是变量 a，因此 b 不会被修改</p>
<h4 id="Q-011">Q 011</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：0<br>
由于 a 是在命名空间范围内声明的，它具有静态存储期，并且它未初始化，因此默认初始化为 0，此时不需要在前面添加 <code>static</code> 关键字，否则只是表示内部连接，外部不可见。</p>
<h4 id="Q-012">Q 012</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：0<br>
局部静态变量会被初始化为 0。</p>
<h4 id="Q-013">Q 013</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b"</span>; &#125;</span><br><span class="line">    ~B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c"</span>; &#125;</span><br><span class="line">    ~C() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：acbBCA<br>
a 一定会在 c 和 b 之前初始化。</p>
<h4 id="Q-014">Q 014</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b"</span>; &#125;</span><br><span class="line">    ~B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c"</span>; &#125;</span><br><span class="line">    ~C() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">static</span> C c; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：abcBCA<br>
a 不是 constexpr，因此 a 的初始化是动态的并且具有全局作用域<br>
接下来初始化 b，静态局部变量会在第一次执行到它的时候初始化<br>
当 main 退出时，b 超出作用域先被析构，所有静态变量按照初始化的相反顺序析构</p>
<h4 id="Q-015">Q 015</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (x++ == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'A'</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'b'</span>; &#125;</span><br><span class="line">    ~B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'B'</span>; &#125;</span><br><span class="line">    A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">static</span> B b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="built_in">std</span>::exception &amp;) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'c'</span>;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：acabBA<br>
静态局部变量在第一次访问它的时候初始化，第一次调用 <code>foo</code> 时，尝试初始化 b，在调用 B 的构造函数之前首先构造类 B 的成员变量，因此先调用 <code>A::A()</code>，打印 a，该构造函数抛出一个异常，中止构造，被 <code>catch(std::exception &amp;)</code> 捕捉到，打印 c，第二次调用 <code>foo</code> 函数，因为 b 第一次没有被成功初始化，此时会再次尝试构造 b，这次构造成功，打印 ab，当 main 结束后，静态变量 b 被析构，最后析构成员变量 a。</p>
<h4 id="Q-016">Q 016</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'a'</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'A'</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'b'</span>; &#125;</span><br><span class="line">    ~B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'B'</span>; &#125;</span><br><span class="line">    A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; B b; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：abBA<br>
先构造父类再构造子类，先析构子类再析构父类</p>
<h4 id="Q-017">Q 017</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'a'</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'A'</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'b'</span>; &#125;</span><br><span class="line">    ~B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'B'</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; B b; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：abBA<br>
构造先 A 后 B，析构先 B 后 A。</p>
<h4 id="Q-018">Q 018</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A &amp;a)</span> </span>&#123; a.f(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    g(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：B<br>
这道题的难点在于尽管 B::f() 是私有的，它仍然能够被它的基类引用成功调用。</p>
<h4 id="Q-024">Q 024</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：0<br>
<code>numeric_limits</code> 类模板用于提供查询各种算术类型属性的标准化方式，<code>std::numeric_limits&lt;unsigned int&gt;::max()</code> 表示的是无符号整型的最大可能值，加 1 之后溢出了，i 重新回到了 0。</p>
<h4 id="Q-025">Q 025</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序行为未定义<br>
C++ 标准规定，有符号整数溢出是未定义的行为 - 如果在计算一个表达式时，结果在数学上没有定义或者不在其类型的可表示值的范围内，那么该行为是未定义的。</p>
<h4 id="Q-026">Q 026</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i / --j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序行为未定义<br>
对 0 的 <code>/</code> 操作与 <code>%</code> 操作都是未定义行为。</p>
<h4 id="Q-027">Q 027</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::ostream &amp;<span class="title">put</span><span class="params">(<span class="built_in">std</span>::ostream &amp;o)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o &lt;&lt; <span class="string">'A'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::ostream &amp;<span class="title">put</span><span class="params">(<span class="built_in">std</span>::ostream &amp;o)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o &lt;&lt; <span class="string">'B'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;o, <span class="keyword">const</span> A &amp;a) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">put</span>(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：B<br>
这是一种获得 <code>operator &lt;&lt;</code> 多态的方法。</p>
<h4 id="Q-028">Q 028</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;a) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"C"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">        x.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：AABCBC<br>
数组初始化的时候，调用默认构造函数，输出 AA，循环数组的时候 <code>auto</code> 推断 x 的类型为 A，因此调用拷贝构造函数后再调用 f，输出 BCBC。</p>
<h4 id="Q-029">Q 029</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; foo(); &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A() &#123; foo(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; foo(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：121<br>
虽然 <code>foo()</code> 是虚函数，但是在基类的构造和析构函数调用时不会执行，因为此时的派生类不存在。<br>
基类析构函数写成虚函数是为了防止基类指针在析构派生类对象时只能析构基类对象造成内存泄露。</p>
<h4 id="Q-030">Q 030</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    X() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"X"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="function">X <span class="title">x</span><span class="params">()</span></span>; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：输出为空<br>
<code>X x()</code> 是函数原型，不是实例化类 X，如果要输出 X，可以将代码修改为 <code>X x{}</code></p>
<h4 id="Q-031">Q 031</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    X() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"X"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span></span><br><span class="line">    Y(<span class="keyword">const</span> X &amp;x) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Y"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Y <span class="title">y</span><span class="params">(X())</span></span>;</span><br><span class="line">    y.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
<code>Y y(X())</code> 原先的意图是定义一个 Y 类型的变量，而本题中的 y 是一个参数为函数 X()（无参数，返回值为 X），返回值为 Y 的函数，如果要修改，应改为 <code>Y y{X{}}</code>。</p>
<h4 id="Q-032">Q 032</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    X() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span>; &#125;</span><br><span class="line">    X(<span class="keyword">const</span> X &amp;x) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b"</span>; &#125;</span><br><span class="line">    <span class="keyword">const</span> X &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> X &amp;x) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c"</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    <span class="function">X <span class="title">y</span><span class="params">(x)</span></span>;</span><br><span class="line">    X z = y;</span><br><span class="line">    z = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：ABBC<br>
<code>X y(x)</code> 调用的是拷贝构造函数。</p>
<h4 id="Q-033">Q 033</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GeneralException</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"G"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpecialException</span> :</span> <span class="keyword">public</span> GeneralException &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"S"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> SpecialException(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (GeneralException e) &#123;</span><br><span class="line">        e.<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：G<br>
我们抛出了一个 SpecialException 异常，这是一个 GeneralException 的派生类，但是该异常是被值捕获的，因此 e 具有的是动态类型 GeneralException 而不是 SpecialException，这就是对象切片。<br>
我们应该通过 <code>catch(GeneralException&amp; e)</code> 来捕获这个异常，这样程序输出才为 S。</p>
<h4 id="Q-035">Q 035</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; v2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：12<br>
v1 初始化为 1 个 2；<br>
v2 初始化为 1 和 2。</p>
<h4 id="Q-037">Q 037</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(a) b = a;</span><br><span class="line">    b++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：01<br>
<code>auto</code> 忽略顶层 <code>const</code>，<code>decltype</code> 保留顶层 <code>const</code><br>
对引用操作，<code>auto</code> 推断出原有类型，<code>decltype</code> 推断出引用<br>
对解引用操作，<code>auto</code> 推断出原有类型，<code>decltype</code> 推断出引用</p>
<h4 id="Q-038">Q 038</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>((a)) b = a;</span><br><span class="line">    b++;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：11<br>
一般情况下，<code>decltype</code> 只会返回给定的名称或表达式的确切类型；<br>
C++14 开始，<code>auto</code> 可以用于函数返回值类型的推导，但是当函数返回值用于被初始化的场景下，初始化表达的引用性会被忽略。而 <code>decltype(auto)</code> 能够解决这个问题。<br>
当 <code>decltype(e)</code> 中的 e 是比仅有名称更复杂的左值表达式时，<code>decltype(e)</code> 就保证得出的型别总是左值引用。<br>
因此 <code>decltype((a))</code> 推断出的类型为 <code>int&amp;</code>，b 是 a 的引用，因此 a 和 b 都为 1。</p>
<h4 id="Q-041">Q 041</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>[<span class="string">"ABC"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：B<br>
表达式 <code>E1[E2]</code> 含义是 <code>*((E1) + (E2))</code>，所以 <code>1[&quot;ABC&quot;]</code> 可以写为 <code>*(&quot;ABC&quot; + 1)</code>，这相当于直接取出字母 B。</p>
<h4 id="Q-042">Q 042</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    A(<span class="keyword">int</span>) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    A(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    A a2&#123;&#125;;</span><br><span class="line">    A a3&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    A a4&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1133<br>
初始化列表构造函数是贪婪的，对于 a3 来说，即使 <code>A(int)</code> 也是满足条件的构造函数，编译器仍然会优先考虑 <code>initializer_list&lt;int&gt;</code>。</p>
<h4 id="Q-044">Q 044</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"X"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> X &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Y"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> X &amp;x)</span> </span>&#123; x.f(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X arr[<span class="number">1</span>];</span><br><span class="line">    Y y1;</span><br><span class="line">    arr[<span class="number">0</span>] = y1;</span><br><span class="line">    <span class="built_in">print</span>(y1);</span><br><span class="line">    <span class="built_in">print</span>(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：YX<br>
<code>arr</code> 是 X 的数组，而不是指向 X 的指针，当类型为 Y 的对象存入该数组中时会被转化为 X 类型，因此存入数组 <code>arr</code> 中的对象 y1 失去对象的 Y 的那一部分，这种现象也被称为对象切片。</p>
<h4 id="Q-049">Q 049</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C(<span class="keyword">int</span> i) : i(i) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i; &#125;</span><br><span class="line">    ~C() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i + <span class="number">5</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> C &amp;c = C(<span class="number">1</span>);</span><br><span class="line">    C(<span class="number">2</span>);</span><br><span class="line">    C(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：127386<br>
临时变量一般在该行运行结束时就要被销毁，而第一个变量 C(1) 因为与变量 c 引用绑定，该临时变量的生存期被延长到和 c 一样，所以整个过程是 <code>C(1) C(2) ~C(2) C(3) ~C(3) ~C(1)</code>。</p>
<h4 id="Q-052">Q 052</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> B <span class="title">A::createB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">    <span class="function">B <span class="title">createB</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> B(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b = a.createB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
当声明函数 <code>A::createB()</code> 为类 B 的友元函数时，编译器并不知道这个函数存在，因为它只看到了类 A 的声明而不是类 A 的定义。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Quiz</tag>
        <tag>Programming-Language</tag>
      </tags>
  </entry>
  <entry>
    <title>在博客中显示文章阅读量排行</title>
    <url>/posts/a510178f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>博客从 <code>Hexo-3.8</code> <code>Next-6.7.0</code> 更新到了 <code>Hexo-4.2</code> <code>Next-7.7.1</code> 之后，原来的文章阅读量排行失效了，<code>F12</code> 发现下面的 URL 报错 <code>401 - unauthorized</code>：<br>
<code>https://us.leancloud.cn/1.1/classes/Comment?redirectByAPI=cn</code></p>
<p>错误原因是原 SDK 版本太低，将 <code>top/index.md</code> 中的<br>
<code>&lt;script src=&quot;https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js&quot;&gt;&lt;/script&gt;</code><br>
修改为：<br>
<code>&lt;script src=&quot;https://cdn1.lncld.net/static/js/3.10.0/av-min.js&quot;&gt;&lt;/script&gt;</code></p>
<p>重新 hexo 三连，问题解决。</p>
<p>完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"top"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/cdn1.lncld.net/</span><span class="keyword">static</span>/js/<span class="number">3.10</span><span class="number">.0</span>/av-min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">AV.initialize("</span>APP-ID<span class="string">", "</span>APP-KEY<span class="string">");</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script type="</span>text/javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  var time=0</span></span><br><span class="line"><span class="string">  var title="</span><span class="string">"</span></span><br><span class="line"><span class="string">  var url="</span><span class="string">"</span></span><br><span class="line"><span class="string">  var query = new AV.Query('Counter');</span></span><br><span class="line"><span class="string">  query.notEqualTo('id',0);</span></span><br><span class="line"><span class="string">  query.descending('time');</span></span><br><span class="line"><span class="string">  query.limit(1000);</span></span><br><span class="line"><span class="string">  query.find().then(function (todo) &#123;</span></span><br><span class="line"><span class="string">    for (var i=0;i&lt;1000;i++)&#123;</span></span><br><span class="line"><span class="string">      var result=todo[i].attributes;</span></span><br><span class="line"><span class="string">      time=result.time;</span></span><br><span class="line"><span class="string">      title=result.title;</span></span><br><span class="line"><span class="string">      url=result.url;</span></span><br><span class="line"><span class="string">      var content="</span>&lt;p&gt;<span class="string">"+"</span>&lt;font color=<span class="string">'#1C1C1C'</span>&gt;<span class="string">"+"</span>&lt;<span class="regexp">/font&gt;"+"&lt;a href='"+"https:/</span><span class="regexp">/archiescott.github.io/</span><span class="string">"+url+"</span><span class="string">'&gt;"+title+"&lt;/a&gt;"+"&lt;br&gt;"+"阅读次数："+time+"&lt;br&gt;"+"&lt;/p&gt;";</span></span><br><span class="line"><span class="string">      document.getElementById("top").innerHTML+=content</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;, function (error) &#123;</span></span><br><span class="line"><span class="string">    console.log("error");</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的 syncPrimitives：lock</title>
    <url>/posts/47473230/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="std-lock-guard">std::lock_guard</h2>
<h3 id="std-lock-guard-特性"><code>std::lock_guard</code> 特性</h3>
<p><code>lock_guard</code> 是一种互斥封装器，利用 RAII 机制为代码块提供 <code>mutex</code> 的所有权。</p>
<p><code>lock_guard</code> 的拷贝构造与赋值函数均为 <code>delete</code>。</p>
<p><code>explicit lock_guard(mutex_type&amp; m)</code> 相当于调用 <code>m.lock()</code>，如果当前线程已经拥有了 mutex，则该行为未定义。</p>
<p><code>lock_guard(mutex_type&amp; m, std::adopt_lock_t t)</code> 用到了后面的 <code>locktag</code>，<strong>用于该线程已经获取 <code>mutex</code> 的情况下将 <code>mutex</code> 交给 <code>lock_guard</code> 接管</strong>，看个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    mtx.lock();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mtx, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread id: "</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(<span class="built_in">process</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads)</span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="std-lock-guard-示例"><code>std::lock_guard</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex g_i_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// g_i_mutex 在锁离开作用域时自动释放</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(g_i_mutex)</span></span>;</span><br><span class="line">    ++g_i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">": "</span> &lt;&lt; g_i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main: "</span> &lt;&lt; g_i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main: "</span> &lt;&lt; g_i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-lock">std::lock</h2>
<h3 id="std-lock-特性"><code>std::lock</code> 特性</h3>
<p>当需要同时操作两个或两个以上对象时，就需要同时锁定这些对象，而不是将它们依次锁定。</p>
<p><code>lock(Lockable1&amp; lock1, ..., LockableN&amp; lockn)</code> 能够以避免死锁的方式锁定给定的对象，如果在调用 <code>lock</code> 或 <code>unlock</code> 时发生了异常，会将已上锁的对象全部解锁。</p>
<h3 id="std-lock-示例"><code>std::lock</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Employee，将他的 lunch_partners 放入 vector 中输出</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line">    Employee(<span class="built_in">std</span>::<span class="built_in">string</span> id) : id(id) &#123;&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; lunch_partners;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> ret = <span class="string">"Employee "</span> + id + <span class="string">" has lunch partners: "</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">const</span> <span class="keyword">auto</span>&amp; partner : lunch_partners )</span><br><span class="line">            ret += partner + <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_mail</span><span class="params">(Employee &amp;, Employee &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟耗时的发信操作</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign_lunch_partner</span><span class="params">(Employee &amp;e1, Employee &amp;e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 静态 mutex 对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex io_mutex;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 排队 wait for lock</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e1.id &lt;&lt; <span class="string">" and "</span> &lt;&lt; e2.id &lt;&lt; <span class="string">" are waiting for locks"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时使用 lock 同时锁定两个需要操作的对象，而不是先锁一个再锁一个</span></span><br><span class="line">    <span class="comment">// 使用 lock_guard + std::adopt_lock 接管，方便解锁</span></span><br><span class="line">    <span class="comment">// 此时 e1 与 e2 已经被锁定，不能再和别的 employee have lunch 了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock(e1.m, e2.m);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk1</span><span class="params">(e1.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk2</span><span class="params">(e2.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line"><span class="comment">// 等价代码（若需要 unique_locks ，例如对于条件变量）</span></span><br><span class="line"><span class="comment">//        std::unique_lock&lt;std::mutex&gt; lk1(e1.m, std::defer_lock);</span></span><br><span class="line"><span class="comment">//        std::unique_lock&lt;std::mutex&gt; lk2(e2.m, std::defer_lock);</span></span><br><span class="line"><span class="comment">//        std::lock(lk1, lk2);</span></span><br><span class="line"><span class="comment">// C++17 中可用的较优解法</span></span><br><span class="line"><span class="comment">//        std::scoped_lock lk(e1.m, e2.m);</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e1.id &lt;&lt; <span class="string">" and "</span> &lt;&lt; e2.id &lt;&lt; <span class="string">" got locks"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        e1.lunch_partners.push_back(e2.id);</span><br><span class="line">        e2.lunch_partners.push_back(e1.id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 告知午餐指派</span></span><br><span class="line">    send_mail(e1, e2);</span><br><span class="line">    send_mail(e2, e1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee alice("alice"), bob("bob"), christina("christina"), dave("dave");</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在平行线程指派，因为发邮件给用户告知午餐指派，会消耗长时间</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(alice), <span class="built_in">std</span>::ref(bob));</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(christina), <span class="built_in">std</span>::ref(bob));</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(christina), <span class="built_in">std</span>::ref(alice));</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(dave), <span class="built_in">std</span>::ref(bob));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 资源回收</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thread : threads) thread.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; alice.output() &lt;&lt; <span class="string">'\n'</span>  &lt;&lt; bob.output() &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; christina.output() &lt;&lt; <span class="string">'\n'</span> &lt;&lt; dave.output() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-scoped-lock">std::scoped_lock</h2>
<h3 id="std-scoped-lock-特性"><code>std::scoped_lock</code> 特性</h3>
<p><code>scoped_lock</code> 在作用域块的存在期间占有一或多个互斥，当 <code>scoped_lock</code> 析构时以逆序释放锁。</p>
<p><code>scoped_lock(MutexTypes&amp; ... m)</code><br>
当 <code>sizeof(MutexTypes) == 0</code> 时无事发生<br>
当 <code>sizeof(MutexTypes) == 1</code> 时等效于 <code>m.lock()</code><br>
否则等效于 <code>std::lock(m...)</code></p>
<p><code>scoped_lock( std::adopt_lock_t, MutexTypes&amp;... m )</code><br>
<code>scoped_lock</code> 也可以批量接管 <code>mutex</code>。</p>
<p><code>scoped_lock</code> 不能复制，但是可以移动。</p>
<h3 id="std-scoped-lock-示例"><code>std::scoped_lock</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line">    Employee(<span class="built_in">std</span>::<span class="built_in">string</span> id) : id(id) &#123;&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; lunch_partners;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> ret = <span class="string">"Employee "</span> + id + <span class="string">" has lunch partners: "</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">const</span> <span class="keyword">auto</span>&amp; partner : lunch_partners )</span><br><span class="line">            ret += partner + <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_mail</span><span class="params">(Employee &amp;, Employee &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign_lunch_partner</span><span class="params">(Employee &amp;e1, Employee &amp;e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex io_mutex;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e1.id &lt;&lt; <span class="string">" and "</span> &lt;&lt; e2.id &lt;&lt; <span class="string">" are waiting for locks"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用 scoped_lock 相当于锁定并接管了 e1.m e2.m</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::scoped_lock <span class="title">lock</span><span class="params">(e1.m, e2.m)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等价代码 1 （用 std::lock 和 std::lock_guard ）</span></span><br><span class="line">        <span class="comment">// std::lock(e1.m, e2.m);</span></span><br><span class="line">        <span class="comment">// std::lock_guard&lt;std::mutex&gt; lk1(e1.m, std::adopt_lock);</span></span><br><span class="line">        <span class="comment">// std::lock_guard&lt;std::mutex&gt; lk2(e2.m, std::adopt_lock);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等价代码 2 （若需要 unique_lock ，例如对于条件变量）</span></span><br><span class="line">        <span class="comment">// std::unique_lock&lt;std::mutex&gt; lk1(e1.m, std::defer_lock);</span></span><br><span class="line">        <span class="comment">// std::unique_lock&lt;std::mutex&gt; lk2(e2.m, std::defer_lock);</span></span><br><span class="line">        <span class="comment">// std::lock(lk1, lk2);</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e1.id &lt;&lt; <span class="string">" and "</span> &lt;&lt; e2.id &lt;&lt; <span class="string">" got locks"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        e1.lunch_partners.push_back(e2.id);</span><br><span class="line">        e2.lunch_partners.push_back(e1.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    send_mail(e1, e2);</span><br><span class="line">    send_mail(e2, e1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee alice("alice"), bob("bob"), christina("christina"), dave("dave");</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在并行线程中指派，send_mail 耗时较长</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(alice), <span class="built_in">std</span>::ref(bob));</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(christina), <span class="built_in">std</span>::ref(bob));</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(christina), <span class="built_in">std</span>::ref(alice));</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(dave), <span class="built_in">std</span>::ref(bob));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thread : threads) thread.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; alice.output() &lt;&lt; <span class="string">'\n'</span>  &lt;&lt; bob.output() &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; christina.output() &lt;&lt; <span class="string">'\n'</span> &lt;&lt; dave.output() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-try-lock">std::try_lock</h2>
<h3 id="std-try-lock-特性"><code>std::try_lock</code> 特性</h3>
<p><code>int try_lock( Lockable1&amp; lock1, ..., LockableN&amp;... lockn)</code><br>
会尝试给 <code>lock1</code> 到 <code>lockn</code> 依次 <code>try_lock</code>，当 <code>try_lock</code> 失败时就不再继续调用 <code>try_lock</code>，并且已锁对象会依次 <code>unlock</code>。锁定失败返回对象下标，如果锁定成功返回 -1。</p>
<p>用陈硕的话来说，<code>try_lock</code> 在生产代码中并不多见，因为程序大多时候都不需要试着去锁一锁。</p>
<h3 id="std-try-lock-示例"><code>std::try_lock</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> foo_count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::mutex foo_count_mutex;</span><br><span class="line">    <span class="keyword">int</span> bar_count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::mutex bar_count_mutex;</span><br><span class="line">    <span class="keyword">int</span> overall_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">std</span>::mutex done_mutex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> increment = [](<span class="keyword">int</span> &amp;counter, <span class="built_in">std</span>::mutex &amp;m, <span class="keyword">const</span> <span class="keyword">char</span> *desc) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">            ++counter;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; desc &lt;&lt; <span class="string">": "</span> &lt;&lt; counter &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个线程分别获取自身的 mutex 后修改自身的 count</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">increment_foo</span><span class="params">(increment, <span class="built_in">std</span>::ref(foo_count), <span class="built_in">std</span>::ref(foo_count_mutex), <span class="string">"foo"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">increment_bar</span><span class="params">(increment, <span class="built_in">std</span>::ref(bar_count), <span class="built_in">std</span>::ref(bar_count_mutex), <span class="string">"bar"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用捕获创建线程</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">update_overall</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        done_mutex.lock();</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">while</span> (!done) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            done_mutex.unlock();</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> result = <span class="built_in">std</span>::try_lock(foo_count_mutex, bar_count_mutex);</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="comment">// 如果锁定成功将两个 count 计入总数</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                overall_count += foo_count + bar_count;</span></span></span><br><span class="line"><span class="function"><span class="params">                foo_count = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">                bar_count = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"overall: "</span> &lt;&lt; overall_count &lt;&lt; <span class="string">'\n'</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">                foo_count_mutex.unlock();</span></span></span><br><span class="line"><span class="function"><span class="params">                bar_count_mutex.unlock();</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span></span></span><br><span class="line"><span class="function"><span class="params">            done_mutex.lock();</span></span></span><br><span class="line"><span class="function"><span class="params">        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">        done_mutex.unlock();</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    increment_foo.join();</span><br><span class="line">    increment_bar.join();</span><br><span class="line">    <span class="comment">// 等待两个线程都结束了再修改 done</span></span><br><span class="line">    <span class="comment">// done 必须要在 while 循环中修改才行</span></span><br><span class="line">    done_mutex.lock();</span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    done_mutex.unlock();</span><br><span class="line">    update_overall.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Done processing\n"</span></span><br><span class="line">              &lt;&lt; <span class="string">"foo: "</span> &lt;&lt; foo_count &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"bar: "</span> &lt;&lt; bar_count &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"overall: "</span> &lt;&lt; overall_count &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-unique-lock">std::unique_lock</h2>
<h3 id="std-unique-lock-特性"><code>std::unique_lock</code> 特性</h3>
<p><code>unique_lock( unique_lock&amp;&amp; other ) noexcept</code><br>
<code>unique_lock</code> 不支持复制构造，但支持移动构造，用其他的 <code>unique_lock</code> 对象初始化新 <code>unique_lock</code> 对象</p>
<p><code>unique_lock( mutex_type&amp; m, locktag t )</code><br>
<code>locktag</code> 可以为下面三种：<br>
<code>std::defer_lock</code> 接管 <code>mutex</code> 但不锁定<br>
<code>std::try_to_lock</code> 接管 <code>mutex</code> 后尝试锁定，锁定失败也不会阻塞<br>
<code>std::adopt_lock</code> 锁定后接管 <code>mutex</code></p>
<p><code>unique_lock( mutex_type&amp; m, const std::chrono::duration&lt;Rep,Period&gt;&amp; timeout_duration )</code><br>
<code>unique_lock</code> 阻塞直至经过指定的 <code>timeout_duration</code> 或者获得锁。</p>
<p><code>unique_lock( mutex_type&amp; m, const std::chrono::time_point&lt;Clock,Duration&gt;&amp; timeout_time )</code><br>
<code>unique_lock</code> 阻塞直至到达指定的 <code>timeout_time</code> 或者获得锁。</p>
<p><code>unique_lock</code> 接管 <code>mutex</code> 之后可以调用 <code>lock</code> 和 <code>unlock</code> 来临时锁定和解锁线程，<code>unique_lock</code> 还可以通过 <code>release</code> 释放对 <code>mutex</code> 的管理。</p>
<h3 id="std-unique-lock-示例"><code>std::unique_lock</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Box</span><span class="params">(<span class="keyword">int</span> num)</span> : num_things</span>&#123;num&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num_things;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 from 取 num 给 to</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Box &amp;from, Box &amp;to, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只是接管，并未锁定</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock1</span><span class="params">(from.m, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock2</span><span class="params">(to.m, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁两个 unique_lock 而不死锁</span></span><br><span class="line">    <span class="built_in">std</span>::lock(lock1, lock2);</span><br><span class="line"></span><br><span class="line">    from.num_things -= num;</span><br><span class="line">    to.num_things += num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 'from.m' 与 'to.m' 互斥解锁于 'unique_lock' 析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">acc1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">acc2</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(<span class="built_in">transfer</span>, <span class="built_in">std</span>::ref(acc1), <span class="built_in">std</span>::ref(acc2), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(<span class="built_in">transfer</span>, <span class="built_in">std</span>::ref(acc2), <span class="built_in">std</span>::ref(acc1), <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex m_a, m_b, m_c;</span><br><span class="line"><span class="keyword">int</span> a, b, c = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;   <span class="comment">// 注意：可用 std::lock_guard 或 atomic&lt;int&gt; 代替</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m_a)</span></span>;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// 注意：细节和替代品见 std::lock 及 std::scoped_lock</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk_b</span><span class="params">(m_b, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk_c</span><span class="params">(m_c, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::lock(lk_b, lk_c);</span><br><span class="line">        <span class="comment">// 用 newValue(b+c) 替换 c 的值，返回的 oldValue 赋值给 b</span></span><br><span class="line">        b = <span class="built_in">std</span>::exchange(c, b+c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">        threads.emplace_back(update);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i: threads)</span><br><span class="line">        i.join();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">"'th and "</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; <span class="string">"'th Fibonacci numbers: "</span></span><br><span class="line">            &lt;&lt; b &lt;&lt; <span class="string">" and "</span> &lt;&lt; c &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-shared-lock">std::shared_lock</h2>
<h3 id="std-shared-lock-特性"><code>std::shared_lock</code> 特性</h3>
<p><code>shared_lock</code> 会以共享模式锁定 <code>mutex</code>，注意与 <code>unique_lock</code> 的排他性锁定相区分，<code>shared_lock</code> 类可移动，但不可复制。</p>
<p><code>explicit shared_lock( mutex_type&amp; m )</code><br>
相当于调用 <code>m.lock_shared()</code>，除此之外，<code>shared_lock</code> 也可以使用 <code>locktag</code>、<code>try_lock_shared_for</code>、<code>try_lock_shared_until</code>。</p>
<p>写到这里需要提醒一下 <code>mutex</code> 与 <code>lock</code> 的关系，<code>mutex</code> 是底层同步原语，而 <code>lock</code> 是通过 RAII 来管理 <code>mutex</code> 的对象，因此 <code>lock</code> 中的锁定与解锁其实是对 <code>mutex</code> 中锁定与解锁的封装。</p>
<h3 id="std-shared-lock-示例"><code>std::shared_lock</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::shared_timed_mutex m;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 两个线程都获得对整数 i 的访问</span></span><br><span class="line">   <span class="function"><span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_timed_mutex&gt; <span class="title">slk</span><span class="params">(m)</span></span>;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"read i as "</span> &lt;&lt; i &lt;&lt; <span class="string">"...\n"</span>;</span><br><span class="line">   <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"woke up...\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function"><span class="built_in">std</span>::thread <span class="title">r1</span><span class="params">(<span class="built_in">read</span>)</span></span>;</span><br><span class="line">   <span class="function"><span class="built_in">std</span>::thread <span class="title">r2</span><span class="params">(<span class="built_in">read</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   r1.join();</span><br><span class="line">   r2.join();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="locktag">locktag</h2>
<h3 id="locktag-属性"><code>locktag</code> 属性</h3>
<p><code>std::defer_lock</code> 为空标签类 <code>std::defer_lock_t</code> 的实例，只接管不上锁</p>
<p><code>std::try_to_lock</code> 为空标签类 <code>std::try_to_lock_t</code> 的实例，接管后尝试上锁，失败也不阻塞</p>
<p><code>std::adopt_lock</code> 为空标签类 <code>std::adopt_lock_t</code> 的实例，上锁后才接管</p>
<h3 id="locktag-示例"><code>locktag</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mutex 放在 struct 中防止多线程同时修改 bank_account</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bank_account</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="keyword">int</span> balance)</span> : <span class="title">balance</span><span class="params">(balance)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(bank_account &amp;from, bank_account &amp;to, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 锁定两个互斥而不死锁</span></span><br><span class="line">    <span class="built_in">std</span>::lock(from.m, to.m);</span><br><span class="line">    <span class="comment">// 保证二个已锁定互斥在作用域结尾解锁</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock1</span><span class="params">(from.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock2</span><span class="params">(to.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价方法：</span></span><br><span class="line"><span class="comment">//    std::unique_lock&lt;std::mutex&gt; lock1(from.m, std::defer_lock);</span></span><br><span class="line"><span class="comment">//    std::unique_lock&lt;std::mutex&gt; lock2(to.m, std::defer_lock);</span></span><br><span class="line"><span class="comment">//    std::lock(lock1, lock2);</span></span><br><span class="line"></span><br><span class="line">    from.balance -= amount;</span><br><span class="line">    to.balance += amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">bank_account <span class="title">my_account</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">bank_account <span class="title">your_account</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(<span class="built_in">transfer</span>, <span class="built_in">std</span>::ref(my_account), <span class="built_in">std</span>::ref(your_account), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(<span class="built_in">transfer</span>, <span class="built_in">std</span>::ref(your_account), <span class="built_in">std</span>::ref(my_account), <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-call-once">std::call_once</h2>
<h3 id="std-call-once-属性"><code>std::call_once</code> 属性</h3>
<p>无论有多少个线程调用，<code>call_once</code> 只执行一次。</p>
<p><code>void call_once( std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args )</code><br>
如果 <code>once_flag</code> 显示 <code>f</code> 已经被调用过了，<code>call_once</code> 立即返回，否则以参数 <code>args</code> 调用 <code>f</code>；调用过程中如果发生了异常，<code>once_flag</code> 不会翻转。</p>
<p>如果对于同一个 <code>once_flag</code>，<code>call_once</code> 调用不同的 <code>f</code>，无法确定调用的具体是哪一个 <code>f</code>。</p>
<h3 id="std-call-once-示例"><code>std::call_once</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::once_flag flag1, flag2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(flag1, []()&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple example: called once\n"</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">may_throw_function</span><span class="params">(<span class="keyword">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (do_throw) &#123;</span><br><span class="line">        <span class="comment">// 可能有多次</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"throw: call_once will retry\n"</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只会出现一次</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Didn't throw, call_once will not attempt again\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_once</span><span class="params">(<span class="keyword">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::call_once(flag2, may_throw_function, do_throw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处只会执行一次 flag1 对应的 lambda 表达式</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">st1</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">st2</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">st3</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">st4</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    st1.join();</span><br><span class="line">    st2.join();</span><br><span class="line">    st3.join();</span><br><span class="line">    st4.join();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t3</span><span class="params">(do_once, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t4</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MultiThreading</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Inter-Threading-Communication</tag>
        <tag>Multithreading</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中的 syncPrimitives：mutex</title>
    <url>/posts/2f6c672d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在撸日志库的时候发现了 C++11 竟然有这么多的 <code>mutex</code> 类型与 <code>lock</code> 类型，本篇先总结一下 <code>mutex</code> 类型。<br>
本文中的示例均来自 <em>CppReference</em>，仅添加部分注释，不再做特殊说明。</p>
<h2 id="std-mutex">std::mutex</h2>
<h3 id="std-mutex-特性"><code>std::mutex</code> 特性</h3>
<p><code>mutex</code> 类能够保护共享数据某个时刻只能允许单个线程访问。</p>
<p>当某个线程占有 <code>mutex</code> 时，<strong>其他</strong>试图获取 <code>mutex</code> 所有权的线程将会阻塞 - 通过 <code>lock</code> 调用，或者收到 <code>false</code> - 通过 <code>try_lock</code> 调用。</p>
<p>当某个线程占有 <code>mutex</code> 时，<strong>该线程</strong>再次尝试 <code>lock</code> 会出现未定义行为，比如死锁，C++ 标准推荐此时能够抛出 <code>std::system_error(resource_deadlock_would_occur)</code> 来取代死锁。</p>
<p><code>mutex</code> 的复制构造函数与赋值运算符都被 <code>delete</code> 掉，因为没有意义。</p>
<p><code>mutex</code> 类的成员函数 <code>lock</code> 与 <code>unlock</code> 不应该手工调用，而应该交给栈上的锁管理对象通过构造和析构管理。</p>
<h3 id="std-mutex-示例"><code>std::mutex</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; g_pages;</span><br><span class="line"><span class="built_in">std</span>::mutex g_pages_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_page</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟长页面读取</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result = <span class="string">"fake content"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save_page 结束后 mutex 释放</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard</span><span class="params">(g_pages_mutex)</span></span>;</span><br><span class="line">    g_pages[url] = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// t1 t2 依次将网页内容填入 map 中</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(save_page, <span class="string">"http://foo"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(save_page, <span class="string">"http://bar"</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在访问 g_pages 是安全的，因为 t1 t2 生命周期已结束</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : g_pages) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; pair.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-timed-mutex">std::timed_mutex</h2>
<h3 id="std-timed-mutex-特性"><code>std::timed_mutex</code> 特性</h3>
<p><code>timed_mutex</code> 在 <code>mutex</code> 的基础上新增了一些功能，添加了两个成员函数 <code>try_lock_for</code> 和 <code>try_lock_until</code>。</p>
<p><code>try_lock_for</code> 在尝试获取锁的过程中会阻塞一段时间，如果在这段时间都没有获取到锁就返回 <code>false</code>，而 <code>try_lock_until</code> 则会阻塞到指定时间，除非在这个过程中获得了锁。</p>
<h3 id="std-timed-mutex-示例"><code>std::timed_mutex</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制到 std::cout 的访问</span></span><br><span class="line"><span class="built_in">std</span>::mutex cout_mutex;</span><br><span class="line"><span class="built_in">std</span>::timed_mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">job</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Ms = <span class="built_in">std</span>::chrono::milliseconds;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个线程都尝试 3 次获取 timed_mutex</span></span><br><span class="line">    <span class="comment">// 成功了打印 success 并 sleep 100Ms</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mutex.try_lock_for(Ms(<span class="number">100</span>))) &#123;</span><br><span class="line">            stream &lt;&lt; <span class="string">"success "</span>;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(Ms(<span class="number">100</span>));</span><br><span class="line">            mutex.unlock();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stream &lt;&lt; <span class="string">"failed "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(Ms(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印输出时也需要获取 mutex</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(cout_mutex)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; id &lt;&lt; <span class="string">"] "</span> &lt;&lt; stream.str() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// explicit thread(Function&amp;&amp; f, Args&amp;&amp;... args)</span></span><br><span class="line">        <span class="comment">// 值传递构造线程并启动</span></span><br><span class="line">        threads.emplace_back(job, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i: threads) &#123;</span><br><span class="line">        i.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::timed_mutex test_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="comment">// 填入要阻塞到的最大时间点</span></span><br><span class="line">    test_mutex.try_lock_until(now + <span class="built_in">std</span>::chrono::seconds(<span class="number">10</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 主线程已经获得了 time_mutex，thread t 只能阻塞 10S</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::timed_mutex&gt; <span class="title">l</span><span class="params">(test_mutex)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(f)</span></span>;</span><br><span class="line">    t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-recursive-mutex">std::recursive_mutex</h2>
<h3 id="std-recursive-mutex-特性"><code>std::recursive_mutex</code> 特性</h3>
<p><code>recursive_mutex</code> 又被称为递归互斥器，它与 <code>non-recursive mutex</code> 的区别在于拥有锁的线程再次 <code>lock</code> 时不会出现未定义行为，而是记入加锁次数中，<code>unlock</code> 时必须匹配到 <code>lock</code> 的次数才能成功解锁。</p>
<p>对 <code>recursive_mutex</code> 加锁的最大次数是未知的，达到最大次数时继续 <code>lock</code> 会抛出 <code>std::system_error</code>。</p>
<p>部分场合下，<code>recursive_mutex</code> 会掩盖代码的一些问题，比如下面的情形中，当 <code>doit</code> 不小心间接调用到了 <code>post</code>，<code>mutex</code> 有可能会死锁，而 <code>recursive_mutex</code> 会偶尔 <code>crash</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Foo&gt; foos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">const</span> Foo&amp; f)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    foos.push_back(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = foos.<span class="built_in">begin</span>(); it != foos.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        it-&gt;doit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="std-recursive-mutex-示例"><code>std::recursive_mutex</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::recursive_mutex test;</span><br><span class="line">    <span class="comment">// 尝试锁定并解锁</span></span><br><span class="line">    <span class="keyword">if</span> (test.try_lock()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lock acquired"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        test.unlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lock not acquired"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次锁定</span></span><br><span class="line">    test.lock();</span><br><span class="line">    <span class="comment">// 再次锁定仍然能够成功</span></span><br><span class="line">    <span class="keyword">if</span> (test.try_lock()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lock acquired"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lock not acquired"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    test.unlock();</span><br><span class="line">    <span class="comment">//test.unlock();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-recursive-timed-mutex">std::recursive_timed_mutex</h2>
<h3 id="std-recursive-timed-mutex-特性"><code>std::recursive_timed_mutex</code> 特性</h3>
<p><code>recursive_timed_mutex</code> 是 <code>recursive_mutex</code> 和 <code>timed_mutex</code> 的合体，特性与示例均参照以上。</p>
<h2 id="std-shared-mutex">std::shared_mutex</h2>
<h3 id="std-shared-mutex-特性"><code>std::shared_mutex</code> 特性</h3>
<p><code>shared_mutex</code> 是 C++17 中引入的新特性。它拥有两个访问级别：<br>
多个线程能够共享同一个 <code>shared_mutex</code> 的所有权；<br>
仅一个线程能获得 <code>shared_mutex</code> 的所有权。</p>
<p><code>shared_mutex</code> 即有排他锁定的成员函数 <code>lock</code>、<code>try_lock</code>、<code>unlock</code>，又有共享锁定的成员函数 <code>lock_shared</code>、<code>try_lock_shared</code>、<code>unlock_shared</code>。</p>
<p><code>shared_mutex</code> 本质是 <code>rwlock</code>，基本规则可以总结为<strong>写优先、读共享、交叉互斥</strong>，之所以写优先是因为能够保证读到数据是最新的。</p>
<p>当 <code>shared_mutex</code> 当前是写加锁时，所有尝试 <code>lock</code> 的线程都会阻塞；<br>
当 <code>shared_mutex</code> 当前是读加锁时，所有尝试以读模式 <code>lock</code> 的线程能够获得访问权，以写模式 <code>lock</code> 的线程会被阻塞；<br>
当 <code>shared_mutex</code> 读加锁时有其它线程尝试以写模式 <code>lock</code> 时，<code>shared_mutex</code> 会阻塞后面的读模式，直到写模式结束释放锁。</p>
<p>如果是自己实现读写锁的时候可能存在这样的问题，<strong>通常 <code>reader lock</code> 是可重入的，而 <code>writer lock</code> 是不可重入的，那么 <code>reader lock</code> 重入的时候可能会造成死锁</strong>。</p>
<h3 id="std-shared-mutex-示例"><code>std::shared_mutex</code> 示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeCounter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ThreadSafeCounter() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读的时候使用共享锁</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::shared_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写的时候使用独占锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        value_++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置的时候使用独占锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        value_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// get const 中需要加锁，因此 mutex_ 需要定义为 mutable</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::shared_mutex mutex_;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> value_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadSafeCounter counter;</span><br><span class="line">    <span class="built_in">std</span>::mutex printMutex;</span><br><span class="line">    <span class="keyword">auto</span> increment_and_print = [&amp;counter, &amp;printMutex]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            counter.increment();</span><br><span class="line">            <span class="comment">// 写入 std::cout 实际上也要由另一互斥同步</span></span><br><span class="line">            <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(printMutex)</span></span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">' '</span> &lt;&lt; counter.<span class="built_in">get</span>() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">thread1</span><span class="params">(increment_and_print)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">thread2</span><span class="params">(increment_and_print)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread1.join();</span><br><span class="line">    thread2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-shared-timed-mutex">std::shared_timed_mutex</h2>
<h3 id="std-shared-timed-mutex-特性"><code>std::shared_timed_mutex</code> 特性</h3>
<p><code>shared_timed_mutex</code> 是 <code>shared_mutex</code> 与 <code>timed_mutex</code> 的合体：<br>
排他锁定成员函数 <code>lock</code>、<code>try_lock</code>、<code>try_lock_for</code>、<code>try_lock_until</code>、<code>unlock</code>；<br>
共享锁定成员函数 <code>lock_shared</code>、<code>try_lock_shared</code>、<code>try_lock_shared_for</code>、<code>try_lock_shared_until</code>、<code>unlock_shared</code>。</p>
]]></content>
      <categories>
        <category>MultiThreading</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>MultiThreading</tag>
        <tag>Inter-Threading-Communication</tag>
        <tag>Mutex</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 和 Java：区别到底在哪里</title>
    <url>/posts/54e19ff4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在做 C/C++ 开发的时候也会经常接触到 Java 相关的代码与知识，下面总结一下它们两者之间的区别：</p>
<h2 id="变量语义的区别">变量语义的区别</h2>
<p>C++ 中所有的变量缺省都是值语义，如果不使用指针或者引用，变量不会引用一个堆上的对象。<br>
值语义的生命周期管理简单，因为它们都是 <em>stack object</em>，但是通过指针或引用来操作堆上对象的时候，C++ 就需要考虑所指对象是否成功释放。<strong>智能指针能够将引用语义转化为值语义来解决上述对象生命周期的问题</strong>。由于 <em>memory locality</em>，C++ 的值语义在性能上具有极大的优势。<br>
Java 中大部分变量则是引用语义，栈空间的变量都是引用类型，因此如果发生拷贝都是浅拷贝。</p>
<h2 id="编程范式的区别">编程范式的区别</h2>
<p>C++ 是一门多范式的编程语言，支持面向过程编程、面向对象编程、泛型编程、函数式编程，开发灵活性高。<br>
Java 支持面向对象编程，或许还有泛型？</p>
<h2 id="申请对象方式的区别">申请对象方式的区别</h2>
<p>变量语义的区别带来了申请对象方式的区别。<br>
C++ 可以自由控制对象是在堆上分配还是在栈上分配，堆上分配时间不确定，而栈上分配速度极快。<br>
Java 提倡所有对象都在堆上分配（原生类型也有对应的封装类），由 GC 统一管理对象生命周期。</p>
<h2 id="资源管理方式的区别">资源管理方式的区别</h2>
<p>C++ 没有垃圾回收机制，因此 C++ 在堆上开辟了一段新空间存放数据之后还需要手动释放空间。<br>
对于一些生命周期模糊的对象，C++11 之后使用了改进版的智能指针来管理 new 出来的对象，释放对象的任务交给智能指针自动完成，整个过程使用的是 RAII 技术，感兴趣的朋友可以参考上一篇智能指针的文章。<br>
Java 中有垃圾回收机制，堆中申请的空间 GC 会自动回收，而 Java 没有析构函数，也几乎很少用 RAII 来管理资源。</p>
<h2 id="错误处理方式的区别">错误处理方式的区别</h2>
<p>C++ 出于历史原因（Google 编码风格）或是性能原因（异常抛出导致系统实时性受损）可以不使用异常，因为如果使用异常，代码中可能出现大量的 <code>try{...}catch{...}</code> 语句，代码将会变得冗长难读，而且<strong>在泛型编程的代码中我们甚至不知道可能会出现哪些异常</strong>。<br>
所以 <strong>从 C++17 开始，对异常的处理标准变成了我们只能声明某些函数不能抛出异常</strong>。在运行之前，无论是代码声明还是编译器都不能发现异常。<br>
Java 中如果一个函数抛出异常，则强制它的调用方必须要处理异常。</p>
<h2 id="对外暴露接口的区别">对外暴露接口的区别</h2>
<p>C++ 除了<strong>模板类需要将接口和实现都放在头文件中</strong>，其他情况下都是<strong>头文件提供对外接口，源文件实现对外接口</strong>。<br>
Java 主要是通过继承和多态来实现自定义接口。</p>
<h2 id="引用外部类与依赖关系的区别">引用外部类与依赖关系的区别</h2>
<p>C++ 的头文件机制会引入大量不相关的代码依赖，编译过程中经常出现某个依赖的头文件不匹配，但是却找不到是如何使用这个头文件的，同样的，链接时也会出现库版本不对或者库的编译参数不匹配等错误。<br>
Java 的 import 机制以及 package 机制能够很好地解决上面的问题，用到哪个类就 import 哪个类，用到的库文件也能够编译成一个 .jar 包用于外部 import，简单高效。</p>
<h2 id="编译运行方式的区别">编译运行方式的区别</h2>
<p>C++ 先将代码编译成二进制文件，这个二进制文件是和平台有关的，所以常说 <strong>C++ 不是跨平台的</strong>，操作系统将这个二进制文件读入内存执行。<br>
Java 是将源文件 .java 编译成 .class 字节码，再<strong>通过 Jvm 将字节码载入内存中翻译执行</strong>。所以 Java 的跨平台是通过与平台无关的字节码实现的。<br>
因为 Jvm 加载字节码后是一边翻译一边执行的，执行效率会略低于 C++，但是在硬件成本极低的现在执行效率的差异已经被拉到很低了。</p>
<p>以上，Java 与 C++ 相比，社区更加活跃，工具也更加丰富，开源库也多，难怪在讲究速度与效率的互联网行业如此受欢迎。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Programming-Language</tag>
      </tags>
  </entry>
  <entry>
    <title>从 RAII 到 smartPtr：智能指针剖析</title>
    <url>/posts/3a3d14bc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="RAII-的基本概念">RAII 的基本概念</h2>
<h3 id="什么是堆">什么是堆</h3>
<p>在内存管理的范畴中，我们将程序中能够动态分配内存的区域称为堆 - <em>heap</em>，C/C++ 都提供了操作 <em>heap</em> 的函数或运算符：</p>
<ul>
<li>
<p>C 使用 <code>malloc/free</code> 操作 <em>heap</em></p>
</li>
<li>
<p>C++ 使用 <code>new/delete</code> 操作 <em>heap</em></p>
</li>
</ul>
<p>类似于下面的代码就会在堆上分配内存：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> vecPtr = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>在堆上分配了内存之后的另一个问题就是释放内存，和 Java 的垃圾收集机制不同，C++ 的内存分配和释放都由内存管理器来操作，通常都不使用垃圾收集，我们需要做的只是把 <code>new</code> 出来的内存再通过 <code>delete</code> 释放掉即可，但是事实上真的这么简单吗？</p>
<h3 id="什么是栈">什么是栈</h3>
<p>函数在运行过程中调用数据、生成数据时使用的内存区域称为栈 - <em>stack</em>，它和数据结构中的栈类似，都是 LIFO。以 x86 为例，<strong>栈的增长方向是由高地址向低地址增长</strong>，函数之间调用时，调用函数会将自己的参数压入栈中，同时把自己下一行的指令也压入栈中，再跳转到新的函数并调整栈指针，新的函数在执行完之后会根据栈中保存的调用函数的地址<strong>重新回到调用函数未执行的地方继续执行</strong>。</p>
<p>由此可见，栈上空间的分配和释放逻辑都十分简单，只要移动栈指针即可，具体分配空间的时候，每个函数分到的属于自己的那一份称为栈帧 - <em>stack frame</em>，即使是有构造函数和析构函数的情况下，C++ 的编译器也会在栈帧的适当位置添加对构造函数和析构函数的调用。这个过程中，<strong>就算函数抛出了异常，编译器也会自动调用析构函数</strong>，来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Obj()&#123; <span class="built_in">puts</span>(<span class="string">"Obj()"</span>); &#125;</span><br><span class="line">    ~Obj()&#123; <span class="built_in">puts</span>(<span class="string">"~Obj()"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    Obj obj;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"func error"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        func(<span class="number">0</span>);</span><br><span class="line">        func(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* str)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">    Obj()</span><br><span class="line">    ~Obj()</span><br><span class="line">    Obj()</span><br><span class="line">    ~Obj()</span><br><span class="line">    func error</span><br></pre></td></tr></table></figure>
<p>也就是说，<code>func(1)</code> 在将异常抛出之前就已经调用了自身的析构函数，而这点正是 RAII 的基础，也是最重要的部分。</p>
<h3 id="什么是-RAII">什么是 RAII</h3>
<p>RAII - <em>Resource Acquisition Is Initialization</em>，资源获取即初始化，<strong>RAII 是一种资源管理方式，它通过栈和析构函数来管理包括堆在内的所有资源</strong>，主流的编程语言中只有 C++ 是使用 RAII 来管理资源的，下面来看一个 C++ 工厂方法的简单示例，为了防止发生对象切片的错误（<strong>C++ 的值语义特点所带来的的编码陷阱：函数返回类型为父类对象，实际返回的为子类对象</strong>），工厂方法需要返回一个父类对象的指针或者是引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++11 后建议使用强类型枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">animalType</span> &#123;</span></span><br><span class="line">    cat,</span><br><span class="line">    dog,</span><br><span class="line">    fox,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span> &#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> :</span> <span class="keyword">public</span> animal &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> :</span> <span class="keyword">public</span> animal &#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fox</span> :</span> <span class="keyword">public</span> animal &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">animal* <span class="title">buyNewAnimal</span><span class="params">(animalType ani_type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(ani_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> animalType::cat :</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> cat();</span><br><span class="line">        <span class="keyword">case</span> animalType::dog :</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> dog();</span><br><span class="line">        <span class="keyword">case</span> animalType::fox :</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> fox();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时返回的是一个 <code>animal</code> 类型的父类指针，指向的是子类对象，问题来了，<code>buyNewAnimal</code> 函数返回 <code>animal</code> 指针后便退出了，堆上已经开辟出空间 <code>animal</code> 子类的对应空间，如何才能保证这一部分内存不泄漏？</p>
<h2 id="智能指针的基本概念">智能指针的基本概念</h2>
<p>C 和 C++ 的老程序员都曾大量接触过裸指针，都曾一边享受着指针带来的便利一边不停地给自己挖坑埋坑，在介绍智能指针之前，先看看使用指针的时候常见的坑有哪些：</p>
<ul>
<li>
<p>忘记 <code>delete/free</code> 导致内存泄露</p>
</li>
<li>
<p>同一个指针释放多次，程序崩溃</p>
</li>
<li>
<p>逻辑 bug，写了 <code>delete/free</code> 结果没有执行到</p>
</li>
<li>
<p><code>delete/free</code> 之前抛出了异常</p>
</li>
</ul>
<p>前面已经介绍过了，C++ 没有自动内存回收机制，<code>new</code> 出来的必须要自己 <code>delete</code> 掉，智能指针的引入，让程序员可以不再关注资源的释放，它能够保证程序无论正常或异常，在到期的时候都能通过 RAII 机制成功回收。</p>
<p>来看上一节中 <code>buyNewAnimal</code> 函数返回的 <code>animal</code> 指针，<strong>只需要将这个返回值放入一个本地变量中，确保这个变量析构的时候会删除上面的对象</strong>即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartAnimalPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smartAnimalPtr</span><span class="params">(animal* animalPtr)</span> : <span class="title">animalPtr_</span><span class="params">(animalPtr)</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// delete nullptr is legal operation</span></span><br><span class="line">    ~smartAnimalPtr()&#123;</span><br><span class="line">        <span class="keyword">delete</span> animalPtr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">animal* <span class="title">getPtr</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> animalPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    animal* animalPtr_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">smartAnimalPtr <span class="title">newAnimalPtr</span><span class="params">(buyNewAnimal(dog))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func</code> 调用的 <code>buyNewAnimal</code> 函数返回值被 <code>newAnimalPtr</code> 接管，使用者可以直接调用 <code>newAnimalPtr.getPtr()</code> 使用原指针，当 <code>func</code> 函数结束时，<code>newAnimalPtr</code> 析构，<code>animalPtr_</code> 所指向的区域被释放，整个过程不需要手动调用 <code>delete</code>，而是通过 RAII 巧妙地交给编译器处理了。</p>
<p>除了 <code>delete</code> 之外，在本地变量的析构函数中还可以执行以下操作：</p>
<ul>
<li>释放同步锁，如下面的多线程累加范例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex sum_lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>&amp; sum, <span class="keyword">int</span>&amp; num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 结束一轮 while 后 sum_lock 自动释放</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(sum_lock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            num += <span class="number">1</span>;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; tdVec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">std</span>::thread td = <span class="built_in">std</span>::thread(add, <span class="built_in">std</span>::ref(sum), <span class="built_in">std</span>::ref(num));</span><br><span class="line">        tdVec.emplace_back(<span class="built_in">std</span>::<span class="built_in">move</span>(td));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// std::mem_fn can generate an object for pointers to members as well as ref and pointers to an object</span></span><br><span class="line">    <span class="built_in">std</span>::for_each(tdVec.<span class="built_in">begin</span>(), tdVec.<span class="built_in">end</span>(), <span class="built_in">std</span>::mem_fn(&amp;<span class="built_in">std</span>::thread::join));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭文件，如 <code>fstream</code> 析构时会调用 <code>close</code> 以防止流对象销毁后还与打开的文件相关联</li>
</ul>
<p>上面实现的 <code>smartAnimalPtr</code> 已经可以算是一个简单的智能指针啦。</p>
<h2 id="auto-ptr">auto_ptr</h2>
<p>我们将 <code>smartAnimalPtr</code> 模板化，并添加一些常用的指针操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartAutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smartAutoPtr</span><span class="params">(T* ptr)</span> : <span class="title">ptr_</span><span class="params">(ptr)</span> </span>&#123;&#125;</span><br><span class="line">    ~smartAutoPtr() &#123; <span class="keyword">delete</span> ptr_; &#125;</span><br><span class="line">    <span class="function">T* <span class="title">getPtr</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line">    <span class="comment">// 重载 bool 转换运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码存在一个很严重的问题，当 <code>smartAutoPtr</code> 拷贝构造或者被赋值时，<strong>因为有两个指针指向同一片区域，RAII 会让这片区域释放两次</strong>！解决这个问题的第一种方法、也是最简单的方法是禁用这两个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">smartAutoPtr(<span class="keyword">const</span> smartAutoPtr&lt;T&gt;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">smartAutoPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> smartAutoPtr&lt;T&gt;&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<p>第二种方法，我们可以在拷贝构造和赋值时转移指针的所有权，而这也正是 <code>auto_ptr</code> 的处理方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartAutoPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smartAutoPtr</span><span class="params">(T* ptr)</span> : <span class="title">ptr_</span><span class="params">(ptr)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    smartAutoPtr(<span class="keyword">const</span> smartAutoPtr&amp; _Right) &#123;</span><br><span class="line">        ptr_ = _Right.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy and swap</span></span><br><span class="line">    <span class="comment">// _Right --&gt; smartAutoPtr(_Right) --&gt; _New</span></span><br><span class="line">    smartAutoPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> smartAutoPtr&amp; _Right) &#123;</span><br><span class="line">        smartAutoPtr(_Right).reset(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~smartAutoPtr() &#123; <span class="keyword">delete</span> ptr_; &#125;</span><br><span class="line">    <span class="function">T* <span class="title">getPtr</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剥夺原 smartAutoPtr 对指针的所有权给新 smartAutoPtr</span></span><br><span class="line">    <span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T* _Tmp = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> _Tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(smartAutoPtr&amp; _New)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(ptr_, _New.ptr_);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>赋值运算符的重载利用了 <em>copy and swap</em> 技术，即先通过拷贝构造创建一个新的对象，再交换它们的指针，这样能够保证强安全性，构造是否成功完全不会破坏赋值运算符两边的数据。</p>
<p>由上面的代码不难看出，<code>auto_ptr</code> 在拷贝构造和赋值运算时都会完全剥夺原对象对指针的所有权，也就是说除了最后一个 <code>auto_ptr</code>，其余所有的 <code>auto_ptr</code> 都变成了 <code>nullptr</code>，全部失效了，这样会带来几个问题：</p>
<ul>
<li>
<p><strong>STL 对容器类型的要求是要有值语义，即可以复制和赋值</strong>。<code>auto_ptr</code> 的复制和赋值经过了 <code>release</code> 和 <code>reset</code> 的处理，<strong>因此 <code>auto_ptr</code> 对象不能作为 STL 的容器元素</strong>。</p>
</li>
<li>
<p>将 <code>auto_ptr</code> 作为函数参数按值传递时，函数会在其作用域中生成该 <code>auto_ptr</code> 的拷贝，此时的指针所有权已经转移给了这个临时对象，当函数退出时，该临时对象析构，原 <code>auto_ptr</code> 所指向的对象也被删除了，<strong>如果不得不使用 <code>auto_ptr</code> 作为函数参数时，最好使用 <code>const auto_ptr&amp;</code> 的方式</strong>。</p>
</li>
</ul>
<p>值得注意的是，<code>auto_ptr</code> 已经从 C++17 标准中删除了。</p>
<h2 id="unique-ptr">unique_ptr</h2>
<p><code>unique_ptr</code> 与 <code>auto_ptr</code> 在特性上相差不大，<strong>同一时刻只能有唯一的一个 <code>unique_ptr</code> 指向给定的对象</strong>，<code>unique_ptr</code> 在处理智能指针拷贝构造和赋值时发生的浅拷贝问题上采用了 <code>smartAutoPtr</code> 所使用的方法一，即直接将拷贝构造和赋值运算禁用，此外，<code>unique_ptr</code> 还引入了移动构造，从 C++11 开始，我们不再需要复制对象，只需要移动对象即可，也就是把源对象的资源控制权转交给目标对象，这个过程中不再需要多余的复制操作。而在此之前，如果想要将源对象的状态转移到目标对象只能通过拷贝构造。我们将上面的 <code>auto_ptr</code> 稍微修改可以得到一个简化版的 <code>unique_ptr</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartUniquePtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smartUniquePtr</span><span class="params">(T* ptr)</span> : <span class="title">ptr_</span><span class="params">(ptr)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数不会在类中默认生成</span></span><br><span class="line">    smartUniquePtr(smartUniquePtr&amp;&amp; _Right) &#123;</span><br><span class="line">        ptr_ = _Right.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换移动构造</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    smartUniquePtr(smartUniquePtr&lt;U&gt;&amp;&amp; _Right) &#123;</span><br><span class="line">        ptr_ = _Right.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// necessary</span></span><br><span class="line">    smartUniquePtr(<span class="keyword">const</span> smartUniquePtr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    smartUniquePtr(<span class="keyword">const</span> smartUniquePtr&lt;U&gt;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new _Right --&gt; *this</span></span><br><span class="line">    smartUniquePtr&amp; <span class="keyword">operator</span>=(smartUniquePtr _Right) &#123;</span><br><span class="line">        _Right.reset(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~smartUniquePtr() &#123; <span class="keyword">delete</span> ptr_; &#125;</span><br><span class="line">    <span class="function">T* <span class="title">getPtr</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T* _Tmp = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> _Tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(smartUniquePtr&amp; _New)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(ptr_, _New.ptr_);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码需要注意，<strong>在定义了移动构造函数的情况下，如果没有提供拷贝构造函数，会自动禁用拷贝构造函数</strong>。<br>
但是，<strong>编译器并不会把 <code>smartUniquePtr(smartUniquePtr&lt;U&gt;&amp;&amp; _Right) {}</code> 看作是移动构造，换句话说，编译器不会把所有的模板函数看作构造函数</strong>，如果想消除代码重复，仍然需要将拷贝构造函数手动禁用。<br>
再看 <code>smartUniquePtr</code> 的使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buyNewAnimal 返回的是一个临时变量，调用移动构造函数</span></span><br><span class="line">smartUniquePtr&lt;animal&gt; ptr1&#123; buyNewAnimal(animalType::dog) &#125;;</span><br><span class="line">smartUniquePtr&lt;animal&gt; ptr2&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line"><span class="comment">// ptr1 是一个左值，需要转换成右值</span></span><br><span class="line"><span class="comment">// ptr1 --&gt; temp rv obj --&gt; ptr3</span></span><br><span class="line">smartUniquePtr&lt;animal&gt; ptr3 = <span class="built_in">std</span>::<span class="built_in">move</span>(ptr1);</span><br><span class="line">smartUniquePtr&lt;animal&gt; ptr4&#123; <span class="built_in">std</span>::<span class="built_in">move</span>(ptr3) &#125;;</span><br></pre></td></tr></table></figure>
<p><code>unique_ptr</code> 除了能够支持管理堆上分配的内存，还能够通过移动语义使 <code>unique_ptr</code> 对象与容器兼容。<br>
但 <code>unique_ptr</code> 仍然有一些不足，它仍然无法避免重复释放的问题，使用移动语义之后的源对象也仍然失去了对原指针的所有权，无法再次使用。<br>
要避免上述这些情况，最好的办法是使用带有引用计数功能的智能指针。</p>
<h2 id="shared-ptr">shared_ptr</h2>
<p>在 <code>unique_ptr</code> 中，一个对象只能被一个 <code>unique_ptr</code> 拥有，这在大部分场合是无法满足要求的，更常见的是多个智能指针同时拥有一个对象，只有当所有的指针都失效了，才会删除该对象，这样的智能指针就是 <code>shared_ptr</code>。<br>
<code>shared_ptr</code> 的底层通过引用计数来进行空间管理，每当有一个新的指针指向这块空间时，引用计数加一，反之减一，直到引用计数为零时才释放空间。<br>
来看一下 <code>shared_ptr</code> 的简单实现，和 <code>unique_ptr</code> 的不同之处在于它需要实现共享的引用计数，因此我们<strong>在堆上 <code>new</code> 一个 <code>ref_count</code> 出来，并在 <code>shared_ptr</code> 中保存指向它的指针</strong>，完整的操作需要包含 <code>add</code>、<code>reduce</code> 和 <code>get</code> 三种行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ref_count</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ref_count() <span class="keyword">noexcept</span> : cnt_(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; ++cnt_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">reduce</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> --cnt_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> cnt_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> cnt_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartSharedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">smartSharedPtr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smartSharedPtr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> : <span class="title">ptr_</span><span class="params">(ptr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            refptr_ = <span class="keyword">new</span> ref_count();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy constructor ref_count add</span></span><br><span class="line">    smartSharedPtr(<span class="keyword">const</span> smartShared&amp; _Right) &#123;</span><br><span class="line">        ptr_ = _Right.ptr_;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            _Right.refptr_-&gt;add();</span><br><span class="line">            refptr_ = _Right.refptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// template copy constructor</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    smartSharedPtr(<span class="keyword">const</span> smartSharedPtr&lt;U&gt;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        ptr_ = _Right.ptr_;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            _Right.refptr_-&gt;add();</span><br><span class="line">            refptr_ = _Right.refptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// template move constructor</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    smartSharedPtr(smartSharedPtr&lt;U&gt;&amp;&amp; _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        ptr_ = _Right.ptr_;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            refptr_ = _Right.refptr_;</span><br><span class="line">            _Right.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overload assignment operator</span></span><br><span class="line">    smartSharedPtr&amp; <span class="keyword">operator</span>=(smartSharedPtr _Right) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        _Right.swap(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~smartSharedPtr() &#123;</span><br><span class="line">        <span class="comment">// 每次析构时都需要将 ref_count 减一</span></span><br><span class="line">        <span class="keyword">if</span> (ptr_ &amp;&amp; !refptr_-&gt;reduce()) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            <span class="keyword">delete</span> ref_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get ref_count</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getRefCnt</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">            <span class="keyword">return</span> refptr_-&gt;<span class="built_in">get</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">getptr</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(smartSharedPtr&amp; _New)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(ptr_, _New.ptr_);</span><br><span class="line">        swap(refptr_, _New.refptr_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">    ref_count* refptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(smartSharedPtr&lt;T&gt;&amp; _Left, smartSharedPtr&lt;T&gt;&amp; _Right)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    _Left.swap(_Right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，需要注意以下几点：</p>
<ul>
<li>
<p>为了让编译器优化代码，需要为移动构造函数添加 <code>noexcept</code> 声明</p>
</li>
<li>
<p><code>refptr_</code> 为每个类的私有成员，是不能在 <code>smartSharedPtr</code> 对象之间共享的，需要添加友元类的声明</p>
</li>
<li>
<p>按照现代 C++ 标准需要设计支持移动的对象，即对象不仅要有 <code>swap</code> 成员函数与另一个对象交换，在其所属名空间下还需要需要有一个全局 <code>swap</code> 函数提供给其他对象使用</p>
</li>
<li>
<p>智能指针还需要实现类型转换的函数模板，这里给出 <code>dynamic_cast</code>，其他实现与此类似：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for pointer type conversion</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">smartSharedPtr(<span class="keyword">const</span> smartSharedPtr&lt;U&gt;&amp; _Right, T* ptr) &#123;</span><br><span class="line">    ptr_ = ptr;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        _Right.refptr_-&gt;add();</span><br><span class="line">        refptr_ = _Right.refptr_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出 _Right 的 ptr_ 转换成 T 类型后将 ref_count++ 并包装返回</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">smartSharedPtr&lt;T&gt; <span class="title">dynamic_pointer_cast</span><span class="params">(<span class="keyword">const</span> smartSharedPtr&lt;U&gt;&amp; _Right)</span> </span>&#123;</span><br><span class="line">    T* _Tmp = <span class="keyword">dynamic_cast</span>&lt;T*&gt;(_Right.getptr());</span><br><span class="line">    <span class="keyword">return</span> smartSharedPtr&lt;T&gt;(_Right, _Tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="weak-ptr">weak_ptr</h2>
<p><code>shared_ptr</code> 通常被称为强智能指针，而 <code>weak_ptr</code> 被称为弱智能指针，介绍 <code>weak_ptr</code> 之前先看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A () &#123;&#125;</span><br><span class="line">    ~A () &#123;&#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; ptrb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B () &#123;&#125;</span><br><span class="line">    ~B () &#123;&#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; ptra;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ref_count of A is 1</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="comment">// ref_count of B is 1</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="comment">// ref_count of B is 2</span></span><br><span class="line">    ptra-&gt;ptrb = ptrb;</span><br><span class="line">    <span class="comment">// ref_count of A is 2</span></span><br><span class="line">    ptrb-&gt;ptra = ptra;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; ptrb.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code> 结束时，两个对象的引用计数分别减到 1，因为不等于 0，不满足对象的空间释放条件，最终导致内存泄露，这个问题被称为 <code>shared_ptr</code> 的循环引用问题。</p>
<p>那么怎么解决这个问题呢？当然是通过 <code>weak_ptr</code>，<code>weak_ptr</code> 对 <code>shared_ptr</code> 管理的对象存在非拥有性引用，换句话说，<strong>它表达的是一种临时所有权 - 如果某个对象只有存在的时候才需要被访问，而且随时可能会被删除导致指针失效时，就使用 <code>weak_ptr</code> 跟踪该对象</strong>，当 <code>weak_ptr</code> 需要使用该对象时，需要将其升级为 <code>shared_ptr</code>，如果原 <code>shared_ptr</code> 销毁，这个对象的生命周期则会延长到这个升级的 <code>shared_ptr</code> 被销毁为止。</p>
<p><code>weak_ptr</code> 的特点可以总结为下面几点：</p>
<ul>
<li>
<p><code>weak_ptr</code> 中没有提供一般的指针操作，如果要访问资源必须通过 <code>lock</code> 将其升级为 <code>shared_ptr</code></p>
</li>
<li>
<p><strong>定义对象的时候使用 <code>shared_ptr</code> ，引用对象的时候使用 <code>weak_ptr</code></strong></p>
</li>
<li>
<p><code>weak_ptr</code> 不会改变对象的引用计数，它只是一个观察者的角色</p>
</li>
</ul>
<p>上面的代码使用 <code>weak_ptr</code> 可以修改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A () &#123;&#125;</span><br><span class="line">    ~A () &#123;&#125;</span><br><span class="line">    weak_ptr&lt;B&gt; ptrb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B () &#123;&#125;</span><br><span class="line">    ~B () &#123;&#125;</span><br><span class="line">    weak_ptr&lt;A&gt; ptra;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ref_count of A is 1</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="comment">// ref_count of B is 1</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="comment">// ref_count of B is 1</span></span><br><span class="line">    ptra-&gt;ptrb = ptrb;</span><br><span class="line">    <span class="comment">// ref_count of A is 1</span></span><br><span class="line">    ptrb-&gt;ptra = ptra;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; ptrb.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="智能指针的使用">智能指针的使用</h2>
<h3 id="Deleter">Deleter</h3>
<p><code>unique_ptr</code> 的声明为：<code>std::unique_ptr&lt;T, Deleter&gt;::unique_ptr</code><br>
前面已经说过，智能指针在析构的时候除了 <code>delete</code> 堆上空间，还可以关闭文件、释放同步锁等，<code>unique_ptr</code> 可以让我们自定义指针释放资源的方式，方法是<strong>传入一个函数对象</strong>，我们用 <em>lambda</em> 表达式来简单实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;FILE, std::function&lt;void(FILE*)&gt;&gt; openFile(fopen("config.yml", "w"), [](FILE* fp)-&gt;void&#123; fclose(fp); &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>shared_ptr</code> 的 <code>Deleter</code> 的使用方法与 <code>unique_ptr</code> 稍有不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    foo() &#123;&#125;</span><br><span class="line">    ~foo() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deleter</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(func* fp)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> fp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> foo, deleter())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程场景下的智能指针">多线程场景下的智能指针</h3>
<p>多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p>
<p><code>shared_ptr/weak_ptr</code> 的线程安全可以分为两个部分讨论：</p>
<ul>
<li>
<p><code>shared_ptr/weak_ptr</code> 管理的对象是否是线程安全的</p>
</li>
<li>
<p><code>shared_ptr/weak_ptr</code> 对象本身是否是线程安全的</p>
</li>
</ul>
<p>第一个问题，<code>shared_ptr/weak_ptr</code> 能够实现多线程下其管理的对象是线程安全的，多线程下，一个常见的错误是当一个线程已经将堆上的对象析构了，此时另一个线程去访问已经析构了的对象，产生未定义行为。</p>
<p><em>muduo</em> 网络库中的 <em>Observable</em> 类给出了一个解决方法：通过 <code>weak_ptr</code> 探查对象的生死：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register_</span><span class="params">(<span class="keyword">const</span> weak_ptr&lt;Observer&gt; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> MutexLock mutex_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;weak_ptr&lt;Observer&gt;&gt; observers_;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;weak_ptr&lt;Observer&gt;&gt;::iterator Iterator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Observable::notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    Iterator it = observers_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (it != observers_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">// 遍历 vector 依次尝试 promote weak_ptr</span></span><br><span class="line">        <span class="comment">// lock 是线程安全的</span></span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;Observer&gt; <span class="title">obj</span><span class="params">(it-&gt;lock())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">            obj-&gt;update();</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// promote 失败说明对象已经销毁，从 vector 中删除 weak_ptr</span></span><br><span class="line">            it = observers_.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个问题，<code>shared_ptr</code> 本身并不是线程安全的，它的引用计数是安全无锁的，但是对象的读写不是，因为 <code>shared_ptr</code> 有两个数据成员，读写操作不能原子化。</p>
<p>如果要通过多个线程读写同一个 <code>shared_ptr</code> 对象，需要加锁。<br>
继续看一个 <em>muduo</em> 网络库中的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;foo&gt; localPtr;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        localPtr = globalPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    doit(localPtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;foo&gt; <span class="title">newPtr</span><span class="params">(<span class="keyword">new</span> foo)</span></span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        globalPtr = newPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    doit(newPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考文献：</p>
<p><a href="https://book.douban.com/subject/20471211/" target="_blank" rel="noopener">Linux 多线程服务端编程</a><br>
<a href="https://book.douban.com/subject/25923597/" target="_blank" rel="noopener">Effective Modern C++</a><br>
<a href="https://en.cppreference.com/w/Main_Page" target="_blank" rel="noopener">cppreference</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Smart-Pointer</tag>
        <tag>RAII</tag>
      </tags>
  </entry>
  <entry>
    <title>使用简单的逻辑方法进行独立思考【转】</title>
    <url>/posts/8cfab1d1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<ul>
<li>文章内容概述如下</li>
<li>可考证的数据很重要很重要很重要</li>
<li>理解集合的包含与被包含，以小见大往往不具有科学性严谨性</li>
<li>谨慎颠倒因果关系的事情与混淆无关事情之间的因果关系</li>
<li>做事要找到靠谱的基准线</li>
<li>思考要深入，要高维</li>
</ul>
</blockquote>
<p>这是一个非常复杂的世界，这个世界上有很多各式各样的观点和思维方式，作为一个程序员的我，也会有程序员的思维方式，程序员的思维方式更接近数学的思维方式，数学的思维方式让可以很容易地理清楚这个混乱的世界，其实，并不需要太复杂的数学逻辑，只需要使用一些简单的数学方法，就可以大幅提升自己的认识能力，所以，在这里，记录一篇我自己的思维方式，一方面给大家做个参考，另一方面也供更高阶的人给我进行指正。算是“开源我的思维方式”，开放不仅仅是为了输出，更是为了看看有没有更好的方式。</p>
<p>我的思维方式中，使用数学逻辑的方式进行思考，通常来说，我会使用五步思考的方式：</p>
<p><strong>第一步：信息数据可考证</strong>。如果一个观点或是一个见解的数据是错误的，那么就会造成后面的观点全是错的，所以，<em><strong>首要的是要进行数据的查证或考证</strong></em>。一般来说，如果一篇文章的作者足够严谨的话，他的需要给他的数据建立相关的引用或是可以考证的方法方式。如果一篇文章中出现的是，“有关专家表明”、“美国科学家证明”、“经济学家指出”，但是没有任出处，也没有点明这个专家或是科学家的名字，或是，也没有说明或引用让读者可以自己去验证的方法。那么，其引用的话或是数据是无法考证的，如果是无法考证的，那么，这篇文章的水份就非常大了。一般来说，当我读到一篇文章中的东西没有可考证的来源或是方法时，通常来说，我就不会再读了，因为这篇文章的价值已经不大了，如果我关心这篇文章中的东西，我会改为自己去查找的方式，虽然变“重”了，但是很安全。（所以，像 Wikipedia 这样的网站是我经常去获得信息的地方，因为信息可以被考证是其基本价值观）</p>
<p><strong>第二步：处理集合和其包含关系</strong>。这是一个非常简单的人人都会的数学逻辑。比如：哲学家是人，柏拉图是哲学家，所以，柏拉图是人。就是一个在包含关系下的推理。你不要小看这个简单的逻辑，其实很多人并不会很好的应用，相反，<em><strong>当感情支配了他们以后，他们会以点代面，以特例代替普遍性</strong></em>。比如，地图炮就是一种，他们看到了多个案例，他们就开始把这个案例上升上更大的范围，比如：河南人新疆人都是小偷，上海人都是小市民。日本人都是变态和反人类……等等。除了这些地图炮外，还有否定整个人的，比如一个人犯了个错或是性格上有缺陷，就会把整个人全盘否定掉，员工抢个月饼就上升到其价值观有问题……。在数学的逻辑包含中，<em><strong>超集的定义可以适用于子集，通过子集的特征可以对超集进行探索，但是没法定义超集</strong></em>。另外，集合的大小也是一个很重要的事，幸存者偏差会是一个很容易让人掉下去的陷阱，因为可能会有很大的样本集可能在你的视线盲区。</p>
<p><strong>第三步：处理逻辑因果关系</strong>。所谓因果关系，其实就是分辨充分条件、必要条件和充分必要条件，然后处理其中的逻辑是否有关联性，而且有非常强的因果关系。没有能力分辨充分必要条件处理因果关系是很多人的硬伤。就像我在《<a href="https://coolshell.cn/articles/19271.html" target="_blank" rel="noopener">努力就会成功</a>》中说的一样，“努力” 和 “成功”是否有因果关系？各种逻辑混淆、概念偷换、模糊因果、似是而非全是在这里。比如：掩耳盗铃、刻舟求剑就是因果关系混乱的表现。<em><strong>人们会经常地混淆两个看来一起发生，但是并没有关联在一起的事</strong></em>。因果关系是最容易被模糊和偷换的，比如：很多人都容易混淆“加班”就会有“产出”，混淆了“行动”就会有“结果”，混淆了“抵制”就会赢得“尊重”，混淆了“批评”等于“反对”……等等。除了这些以外，微信公众号里的很多时评文章，他们的文章中的结论和其论据是没有因果关系的，好多文章就是混淆、模糊、偷换……<em><strong>因果关系出问题的文章读多了是对大脑有损伤的，要尽量远离</strong></em>。</p>
<p><strong>第四步：找到靠谱的基准线</strong>。就像我们写代码一样，我们都是会去找一些最佳实践或是业内标准，原因是因为，这样的东西都是经过长时间被这个世界上很多人Review过的，是值得依赖和靠谱的，他们会考虑到很多你没有考虑过的问题。所以，你也会看到很多时评都会找欧美发达国家的作参考的做法，因为毕竟人家的文化是相对比较文明、科学、开放和先进的。找到世界或是国际的通行标准，会更容易让人进步。比如：<em><strong>以开放包容加强沟通的心态，就会比封闭抵制敌对的心态要好得多得多，智者建桥，愚者建墙</strong></em>。当然，我们也开始发现，有一些事上，有利于自己的就对标，不利于自己的就不对标，而且，除了好的事，不好的事也在找欧美作对标，于是开始“多基准线”和“乱基准线”，这种方式需要我们小心分辨。</p>
<p><strong>第五步：更为深入和高维的思考</strong>。如果一件事情只在表面上进行思考其实只是一种浅度思考，在 Amazon，线上系统出现故障的时候，需要写一个 Correction of Errors 的报告，其中需要 Ask 5 Whys（参看 Wikipedia 的 Five Whys 词条），这种思考方式可以让你不断追问到深层次的本质问题，会让你自己做大量的调查和研究，让你不会成为一个只会在表面上进行思考的简单动物。比如：当你看到有出乎你意料的事件发生时（比如负面的暴力事件），你需要问一下，为什么会发生，原因是什么？然后罗列尽可能全的原因，再不断地追问并拷证下去（这跟写程序一样，需要从正向案例和负向案例进行考虑分析，才可能写出健壮性很强的代码），我们才会得出一个比较健壮的答案或结构。</p>
<p>需要注意的是，在上述的这五种思维方式下，你的思考是不可能快得起来的，这是一个“慢思考”（注：如果读过《<a href="https://book.douban.com/subject/10785583//" target="_blank" rel="noopener">思考，快与慢</a>》这本书的人就知道我在说什么），<em><strong>独立思考是需要使用大脑中的“慢系统”，慢系统是反人性的，所以，能真正做到独立思考的人很少</strong></em>。更多的人的“独立思考”其实只不过是毫无章法的乱思考罢了。</p>
<p>通过上述的这五点，我相信你是很容易识别或是分辨出哪些信息是靠谱的，哪些信息是很扯的，甚至会改善你自己的言论和思考。但是，请注意，这些方法并不能让你获得真理或是真相。但是这也够了，一个人如果拥有了能够分辨是非的能力，也是很不错的了。虽然不知道事实是什么，但是你也不会盲从和偏信，从而不会被人煽动，而成为幕后黑手的的一只“肉鸡”。</p>
<p>多说两句，下面是一些我个人的一些实践：</p>
<p>当新闻报道报道的不是客观事实，而是加入了很多观点，那么这篇新闻报道是不可信的。<br>
对于评论性的文章，没有充足权威可信的论据时，不能完全相信。<br>
不是当事人，不是见证人，还要装作自己是知情的……不知道这种人的自信怎么来的？<br>
信息不公开的，并有意屏蔽信息的，不能作为可信的信息源。<br>
当出现大是或是大非的事时，一定要非常小心，这个世界不存在完全的美和完全的丑，这样的观点通常来说都是危险的，此时要多看看不同角度的报道和评论，要多收集一些信息，还要多问问为什么。<br>
欢迎你告诉我一些你的实践和思维方式。</p>
<p>转载自陈皓 CoolShell 博客<br>
原文链接：<a href="https://coolshell.cn/articles/20533.html" target="_blank" rel="noopener">使用简单的逻辑方法进行独立思考</a></p>
]]></content>
      <categories>
        <category>Perception</category>
      </categories>
      <tags>
        <tag>Perception</tag>
      </tags>
  </entry>
</search>
