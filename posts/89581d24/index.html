<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>浅析 Linux 内核：Socket 的创建与相关系统调用的实现 | 夏の終わり</title><meta name="description" content="剖析 socket、bind、listen、accept 系统调用的内核实现"><meta name="keywords" content="Linux,Socket,Linux-Kernel"><meta name="author" content="Archie Scott"><meta name="copyright" content="Archie Scott"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon-32x32.ico"><link rel="canonical" href="https://github.com/ArchieScott/posts/89581d24/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="浅析 Linux 内核：Socket 的创建与相关系统调用的实现"><meta property="og:url" content="https://github.com/ArchieScott/posts/89581d24/"><meta property="og:site_name" content="夏の終わり"><meta property="og:description" content="剖析 socket、bind、listen、accept 系统调用的内核实现"><meta property="og:image" content="https://i.loli.net/2020/07/19/l5ktRbcGCiYOJfz.jpg"><meta property="article:published_time" content="2020-05-02T11:21:57.000Z"><meta property="article:modified_time" content="2020-07-19T15:19:37.302Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="浅析 Linux 内核：链表的实现" href="https://github.com/ArchieScott/posts/e0e3a2af/"><link rel="next" title="decltype 陷阱" href="https://github.com/ArchieScott/posts/a4099fa0/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: {"languages":{"author":"作者: Archie Scott","link":"链接: ","source":"来源: 夏の終わり","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法制,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/self/tomorrow night.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">55</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/top/"><i class="fa-fw fas fa-signal"></i><span> 热度</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-photo-video"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建-socket"><span class="toc-text">创建 socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#绑定端口-bind"><span class="toc-text">绑定端口 bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#监听端口-listen"><span class="toc-text">监听端口 listen</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务端取出连接-accept"><span class="toc-text">服务端取出连接 accept</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/07/19/quTd2RAzcCFx4Et.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">夏の終わり</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/top/"><i class="fa-fw fas fa-signal"></i><span> 热度</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-photo-video"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">浅析 Linux 内核：Socket 的创建与相关系统调用的实现</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-02 19:21:57"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-05-02</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-19 23:19:37"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-19</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>五一在家花了两天时间将 Linux 网络系统中的源码看了个大概，在此总结，以免遗忘。相比于 UDP，TCP 的三次握手是在内核中完成的，代码会比 UDP 更加复杂，在这里我们就只分析 TCP，UDP 的如果后面有时间再更新。<br>
那么就按照最基础的网络编程的过程来一步步分析，分别是 “创建 socket”、“绑定端口 bind”、“监听端口 listen”、“客户端连接 connect”、“服务端取出连接 accept” 五个部分。<br>
客户端连接 connect 涉及了三次握手的过程，为了减少篇幅，单独将这个部分提出来放在下一篇讲述。<br>
内核代码用的是 Linux v5.6.10，<a href="https://elixir.bootlin.com/linux/latest/source" target="_blank" rel="noopener">代码在线地址</a></p>
<h2 id="创建-socket">创建 socket</h2>
<p>socket 系统调用的代码位于 <code>/net/socket.c</code> 中，代码如下：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">SYSCALL_DEFINE3(socket, <span class="hljs-keyword">int</span>, family, <span class="hljs-keyword">int</span>, type, <span class="hljs-keyword">int</span>, protocol) &#123;<br>    <span class="hljs-keyword">return</span> __sys_socket(family, type, protocol);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个代码其实只是调用了 <code>__sys_socket</code>，之所以要这样包装一下，是为了解决在 64 位系统中，原先的 32 位参数存放在 64 位寄存器中会出现符号扩展出错的情况，导致系统漏洞，现在的做法其实就是将系统调用的参数统一使用 long 类型接收，再强制转换为 int，Linux 内核中还有很多这种类似的修修补补，以后有机会我们都能看到。<br>
下面我们来看在 <code>__sys_socket</code> 中做了些什么：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**<br> * @family: 协议族, AF_INET/AF_UNIX<br> * @type: 通信类型, SOCK_STREAM/SOCK_DGRAM/SOCK_RAW<br> * @protocol: 通信协议, 现在基本已经废弃, 因为协议已经通过上面两个参数指定了, 一般写为 0<br> */</span><br><span class="hljs-keyword">int</span> __sys_socket(<span class="hljs-keyword">int</span> family, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol) &#123;<br>    <span class="hljs-keyword">int</span> retval;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span><br>    <span class="hljs-keyword">int</span> flags;<br><br>    <span class="hljs-comment">// BUILD_BUG_ON 在后面参数为 true 的时候编译错误, 是一种静态检查机制</span><br>    BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);<br>    BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);<br>    BUILD_BUG_ON(SOCK_CLOEXEC &amp; SOCK_TYPE_MASK);<br>    BUILD_BUG_ON(SOCK_NONBLOCK &amp; SOCK_TYPE_MASK);<br><br>    flags = type &amp; ~SOCK_TYPE_MASK;<br>    <span class="hljs-keyword">if</span> (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))<br>        <span class="hljs-keyword">return</span> -EINVAL;<br>    type &amp;= SOCK_TYPE_MASK;<br><br>    <span class="hljs-keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))<br>        flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;<br><br>    retval = sock_create(family, type, protocol, &amp;sock);<br>    <span class="hljs-keyword">if</span> (retval &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> retval;<br><br>    <span class="hljs-comment">// 之所以 sock_create 参数需要使用 struct socket** res</span><br>    <span class="hljs-comment">// 因为 sock_map_fd 需要使用修改后的 struct socket 指针</span><br>    <span class="hljs-keyword">return</span> sock_map_fd(sock, flags &amp; (O_CLOEXEC | O_NONBLOCK));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数中首先创建了一个 <code>struct socket</code>，然后经过一系列的参数检查，最终到达两个重要的函数：<br>
第一个 <code>sock_create</code>，它会创造一个 <code>struct socket</code> 结构放在前面构造的 <code>sock</code> 变量中；<br>
第二个 <code>sock_map_fd</code>，它会将文件描述符和这个 <code>struct socket</code> 对应起来，然后返回 socket 对应的文件描述符。<br>
点进 <code>sock_create</code>，发现它又是一个 wrapper，注意这个参数 res 是一个二重指针，因为我们在外层是用指针来接这个新建的 socket，要修改并保存指针的值，就要使用指针的地址才行。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sock_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> family, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol, struct socket **res)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> __sock_create(current-&gt;nsproxy-&gt;net_ns, family, type, protocol, res, <span class="hljs-number">0</span>);<br>&#125;<br>EXPORT_SYMBOL(sock_create);<br></code></pre></td></tr></table></figure>
<p>进入 <code>__sock_create</code>，这个函数用于真正创建一个新的 socket，并且将它赋值给参数 res：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**<br> * @net: net namespace<br> * @family: protocol family (AF_INET, ...)<br> * @type: communication type (SOCK_STREAM, ...)<br> * @protocol: protocol (0, ...)<br> * @res: new socket<br> * @kern: boolean for kernel space sockets<br> */</span><br><span class="hljs-keyword">int</span> __sock_create(struct net *net, <span class="hljs-keyword">int</span> family, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol, struct socket **res, <span class="hljs-keyword">int</span> kern) &#123;<br>    <span class="hljs-keyword">int</span> err;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span><br>    <span class="hljs-comment">// 用于保存从 net_families 数组中取出的指定协议的协议族</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> *<span class="hljs-title">pf</span>;</span><br><br>    <span class="hljs-comment">// 判断 family 和 type 参数是否合法</span><br>    <span class="hljs-keyword">if</span> (family &lt; <span class="hljs-number">0</span> || family &gt;= NPROTO)<br>        <span class="hljs-keyword">return</span> -EAFNOSUPPORT;<br>    <span class="hljs-keyword">if</span> (type &lt; <span class="hljs-number">0</span> || type &gt;= SOCK_MAX)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    <span class="hljs-keyword">if</span> (family == PF_INET &amp;&amp; type == SOCK_PACKET) &#123;<br>        pr_info_once(<span class="hljs-string">"%s uses obsolete (PF_INET,SOCK_PACKET)\n"</span>, current-&gt;comm);<br>        family = PF_PACKET;<br>    &#125;<br><br>    err = security_socket_create(family, type, protocol, kern);<br>    <span class="hljs-keyword">if</span> (err)<br>        <span class="hljs-keyword">return</span> err;<br><br>    <span class="hljs-comment">// 分配了一个新的 inode 结点与 socket 对象给 sock</span><br>    sock = sock_alloc();<br>    <span class="hljs-keyword">if</span> (!sock) &#123;<br>        net_warn_ratelimited(<span class="hljs-string">"socket: no more sockets\n"</span>);<br>        <span class="hljs-keyword">return</span> -ENFILE;<br>    &#125;<br><br>    sock-&gt;type = type;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_MODULES</span><br>    <span class="hljs-keyword">if</span> (rcu_access_pointer(net_families[family]) == <span class="hljs-literal">NULL</span>)<br>        request_module(<span class="hljs-string">"net-pf-%d"</span>, family);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    rcu_read_lock();<br>    <span class="hljs-comment">// 从 net_families[family] 中取出 family 对应的 struct net_proto_family 保存在 pf 中</span><br>    <span class="hljs-comment">// 后面我们需要调用 pf-&gt;create 来创建 socket</span><br>    pf = rcu_dereference(net_families[family]);<br>    err = -EAFNOSUPPORT;<br>    <span class="hljs-keyword">if</span> (!pf)<br>        <span class="hljs-keyword">goto</span> out_release;<br><br>    <span class="hljs-comment">// 我们需要调用 -&gt;create 函数, 它位于一个可加载模块中, 因此必须先更改可加载模块的引用计数</span><br>    <span class="hljs-keyword">if</span> (!try_module_get(pf-&gt;owner))<br>        <span class="hljs-keyword">goto</span> out_release;<br><br>    rcu_read_unlock();<br><br>    <span class="hljs-comment">// IPv4 中调用的其实是 inet_create</span><br>    err = pf-&gt;create(net, sock, protocol, kern);<br>    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out_module_put;<br><br>    <span class="hljs-keyword">if</span> (!try_module_get(sock-&gt;ops-&gt;owner))<br>        <span class="hljs-keyword">goto</span> out_module_busy;<br><br>    module_put(pf-&gt;owner);<br>    err = security_socket_post_create(sock, family, type, protocol, kern);<br>    <span class="hljs-keyword">if</span> (err)<br>        <span class="hljs-keyword">goto</span> out_sock_release;<br><br>    <span class="hljs-comment">// 修改传入的 res 地址中的值为 sock</span><br>    *res = sock;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>out_module_busy:<br>    err = -EAFNOSUPPORT;<br>out_module_put:<br>    sock-&gt;ops = <span class="hljs-literal">NULL</span>;<br>    module_put(pf-&gt;owner);<br>out_sock_release:<br>    sock_release(sock);<br>    <span class="hljs-keyword">return</span> err;<br>out_release:<br>    rcu_read_unlock();<br>    <span class="hljs-keyword">goto</span> out_sock_release;<br>&#125;<br>EXPORT_SYMBOL(__sock_create);<br></code></pre></td></tr></table></figure>
<p>首先我们看 struct socket 的定义，这个 ops 需要我们找到 family、type、protocol 三者都符合的协议操作进行更新。每个 struct socket 向下也都会对应一个 struct sock，它用于处理底层的网络协议栈，<strong>这个 struct sock，我们称之为传输控制块，它是协议无关的</strong>。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**<br> *  struct socket - general BSD socket<br> *  @state: socket 所处状态 SS_CONNECTED 等<br> *  @type: socket 类型 SOCK_STREAM 等<br> *  @flags: socket 标志位 SOCK_NOSPACE 等<br> *  @ops: 协议指定的 socket 操作<br> *  @file: 文件返回指针<br> *  @sk: 内部网络协议的 socket 表示<br> *  @wq: 等待队列<br> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> &#123;</span><br>    socket_state state;<br>    short type;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto_ops</span> *<span class="hljs-title">ops</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket_wq</span> <span class="hljs-title">wq</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>然后我们看 <code>net_families</code> 数组的定义，它位于 <code>/net/socket.c</code> 的起始位置：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> &#123;</span><br>    <span class="hljs-keyword">int</span> family;<br>    <span class="hljs-keyword">int</span> (*create)(struct net *net, struct socket *sock, <span class="hljs-keyword">int</span> protocol, <span class="hljs-keyword">int</span> kern);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">net_families</span>[<span class="hljs-title">NPROTO</span>] __<span class="hljs-title">read_mostly</span>;</span><br></code></pre></td></tr></table></figure>
<p>不难看出，它其实就是一个 <code>struct net_proto_family *</code> 类型的数组，数组的下标就是 family 协议族参数，也就是说，每一种协议其实都正好对应了一个 <code>struct net_proto_family</code>，以 <code>/net/ipv4/af_inet.c</code> 中的 <code>inet_family_ops</code> 为例：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_proto_family</span> <span class="hljs-title">inet_family_ops</span> = &#123;</span><br>    .family = PF_INET,<br>    <span class="hljs-comment">// 这里将 IPv4 协议族中创建 socket 的函数设置为 inet_create</span><br>    .create = inet_create,<br>    .owner = THIS_MODULE,<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>接下来看 <code>inet_create</code> 的实现，它位于 <code>/net/ipv4/af_inet.c</code> 中：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**<br> * @net: net namespace<br> * @sock: 这个 sock 是新建的 struct socket 类型指针<br> * @protocol: protocol (0, ...)<br> * @kern: boolean for kernel space sockets<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">inet_create</span><span class="hljs-params">(struct net *net, struct socket *sock, <span class="hljs-keyword">int</span> protocol, <span class="hljs-keyword">int</span> kern)</span> </span>&#123;<br>    <span class="hljs-comment">// 注意这个 struct sock 需要和 struct socket 区分</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>;</span><br>    <span class="hljs-comment">// 这个 answer 指向的就是 family type protocol 都符合的 struct inet_protosw</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> *<span class="hljs-title">answer</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_sock</span> *<span class="hljs-title">inet</span>;</span><br>    <span class="hljs-comment">// 这个 answer_prot 用于保存内核网络协议栈的 socket 操作</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> *<span class="hljs-title">answer_prot</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> answer_flags;<br>    <span class="hljs-keyword">int</span> try_loading_module = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> err;<br><br>    <span class="hljs-keyword">if</span> (protocol &lt; <span class="hljs-number">0</span> || protocol &gt;= IPPROTO_MAX)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    <span class="hljs-comment">// 初始化 socket 的状态应该是 SS_UNCONNECTED</span><br>    sock-&gt;state = SS_UNCONNECTED;<br><br>    <span class="hljs-comment">// 查找所需的类型/协议对</span><br>lookup_protocol:<br>    err = -ESOCKTNOSUPPORT;<br>    rcu_read_lock();<br>    <span class="hljs-comment">// inetsw 数组下标为 type</span><br>    list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="hljs-built_in">list</span>) &#123;<br>        err = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (protocol == answer-&gt;protocol) &#123;<br>            <span class="hljs-keyword">if</span> (protocol != IPPROTO_IP)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (IPPROTO_IP == protocol) &#123;<br>                protocol = answer-&gt;protocol;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        err = -EPROTONOSUPPORT;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (unlikely(err)) &#123;<br>        <span class="hljs-keyword">if</span> (try_loading_module &lt; <span class="hljs-number">2</span>) &#123;<br>            rcu_read_unlock();<br><br>            <span class="hljs-keyword">if</span> (++try_loading_module == <span class="hljs-number">1</span>)<br>                request_module(<span class="hljs-string">"net-pf-%d-proto-%d-type-%d"</span>, PF_INET, protocol, sock-&gt;type);<br>            <span class="hljs-keyword">else</span><br>                request_module(<span class="hljs-string">"net-pf-%d-proto-%d"</span>, PF_INET, protocol);<br>            <span class="hljs-keyword">goto</span> lookup_protocol;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">goto</span> out_rcu_unlock;<br>    &#125;<br><br>    err = -EPERM;<br>    <span class="hljs-keyword">if</span> (sock-&gt;type == SOCK_RAW &amp;&amp; !kern &amp;&amp; !ns_capable(net-&gt;user_ns, CAP_NET_RAW))<br>        <span class="hljs-keyword">goto</span> out_rcu_unlock;<br><br>    <span class="hljs-comment">// 修改新建的 struct socket 的 ops 为 answer-&gt;ops</span><br>    sock-&gt;ops = answer-&gt;ops;<br>    <span class="hljs-comment">// 取出 answer 的协议块与 flags</span><br>    answer_prot = answer-&gt;prot;<br>    answer_flags = answer-&gt;flags;<br>    rcu_read_unlock();<br><br>    WARN_ON(!answer_prot-&gt;slab);<br><br>    err = -ENOBUFS;<br>    <span class="hljs-comment">// 分配一个 struct sock, 新建 struct sock 的时候需要指定使用的协议族与协议块</span><br>    <span class="hljs-comment">// sk-&gt;sk_family = family(PF_INET)</span><br>    <span class="hljs-comment">// sk-&gt;sk_prot = prot(answer_prot)</span><br>    sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern);<br>    <span class="hljs-keyword">if</span> (!sk)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    err = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (INET_PROTOSW_REUSE &amp; answer_flags)<br>        sk-&gt;sk_reuse = SK_CAN_REUSE;<br><br>    <span class="hljs-comment">// 将 struct sk* 强制转换为 struct inet_sock*</span><br>    <span class="hljs-comment">// 后面的代码都是填充这个 TCP 协议对应的 struct inet_sock, 不再分析</span><br>    inet = inet_sk(sk);<br>    inet-&gt;is_icsk = (INET_PROTOSW_ICSK &amp; answer_flags) != <span class="hljs-number">0</span>;<br><br>    inet-&gt;nodefrag = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (SOCK_RAW == sock-&gt;type) &#123;<br>        inet-&gt;inet_num = protocol;<br>        <span class="hljs-keyword">if</span> (IPPROTO_RAW == protocol)<br>            inet-&gt;hdrincl = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (net-&gt;ipv4.sysctl_ip_no_pmtu_disc)<br>        inet-&gt;pmtudisc = IP_PMTUDISC_DONT;<br>    <span class="hljs-keyword">else</span><br>        inet-&gt;pmtudisc = IP_PMTUDISC_WANT;<br><br>    inet-&gt;inet_id = <span class="hljs-number">0</span>;<br><br>    sock_init_data(sock, sk);<br><br>    sk-&gt;sk_destruct = inet_sock_destruct;<br>    sk-&gt;sk_protocol = protocol;<br>    sk-&gt;sk_backlog_rcv = sk-&gt;sk_prot-&gt;backlog_rcv;<br><br>    inet-&gt;uc_ttl = <span class="hljs-number">-1</span>;<br>    inet-&gt;mc_loop = <span class="hljs-number">1</span>;<br>    inet-&gt;mc_ttl = <span class="hljs-number">1</span>;<br>    inet-&gt;mc_all = <span class="hljs-number">1</span>;<br>    inet-&gt;mc_index = <span class="hljs-number">0</span>;<br>    inet-&gt;mc_list = <span class="hljs-literal">NULL</span>;<br>    inet-&gt;rcv_tos = <span class="hljs-number">0</span>;<br><br>    sk_refcnt_debug_inc(sk);<br><br>    <span class="hljs-keyword">if</span> (inet-&gt;inet_num) &#123;<br>        inet-&gt;inet_sport = htons(inet-&gt;inet_num);<br>        err = sk-&gt;sk_prot-&gt;hash(sk);<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            sk_common_release(sk);<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sk-&gt;sk_prot-&gt;init) &#123;<br>        err = sk-&gt;sk_prot-&gt;init(sk);<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            sk_common_release(sk);<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!kern) &#123;<br>        err = BPF_CGROUP_RUN_PROG_INET_SOCK(sk);<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            sk_common_release(sk);<br>            <span class="hljs-keyword">goto</span> out;<br>        &#125;<br>    &#125;<br>out:<br>    <span class="hljs-keyword">return</span> err;<br>out_rcu_unlock:<br>    rcu_read_unlock();<br>    <span class="hljs-keyword">goto</span> out;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>inet_create</code> 中首先创建了一个 <code>struct sock</code>，这个结构体非常复杂，它是 socket 的网络层表示，主要负责向下对接内核网络协议栈，而 <code>struct socket</code> 是传输层的结构，主要负责向上为用户服务。<br>
接着创建了一个 <code>struct inet_protosw</code> 类型的指针 answer，这个结构体用于注册 IP 协议的套接字接口，定义如下：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span><br><br>    <span class="hljs-comment">// 下面两个成员变量构成了查找用的 key</span><br>    <span class="hljs-comment">// type 是 socket 的第二个参数</span><br>    <span class="hljs-keyword">unsigned</span> short type;<br>    <span class="hljs-keyword">unsigned</span> short protocol;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> *<span class="hljs-title">prot</span>;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto_ops</span> *<span class="hljs-title">ops</span>;</span><br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flags;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>然后我们看 <code>list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], list)</code> 这个循环。<br>
首先要弄明白 <code>inetsw[]</code> 这个数组是什么，从下面 <code>inet_init</code> 函数中的操作能够看出，inetsw 数组一开始是一个 <code>struct list_head</code> 类型的数组，这里用到了链表，是因为一个 type 可能对应多个 procotol。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">inetsw</span>[<span class="hljs-title">SOCK_MAX</span>];</span><br><br><span class="hljs-comment">// 将 inetsw 数组中的每一个元素都初始化为链表头节点</span><br><span class="hljs-keyword">for</span> (r = &amp;inetsw[<span class="hljs-number">0</span>]; r &lt; &amp;inetsw[SOCK_MAX]; ++r)<br>    INIT_LIST_HEAD(r);<br></code></pre></td></tr></table></figure>
<p>接着在 <code>inet_init</code> 函数中将数组 <code>inetsw_array</code> 注册到数组 <code>inetsw</code> 中：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// inetsw_array 数组的每一项都对应不同 type/protocol 的 struct inet_protosw</span><br><span class="hljs-comment">// 启动时我们将 inetsw_array[] 中的所有元素插入到链表 inetsw[] 中</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> <span class="hljs-title">inetsw_array</span>[] = &#123;</span><br>    &#123;<br>        .type = SOCK_STREAM,<br>        .protocol = IPPROTO_TCP,<br>        .prot = &amp;tcp_prot,<br>        .ops = &amp;inet_stream_ops,<br>        .flags = INET_PROTOSW_PERMANENT | INET_PROTOSW_ICSK,<br>    &#125;,<br>    &#123;<br>        .type = SOCK_DGRAM,<br>        .protocol = IPPROTO_UDP,<br>        .prot = &amp;udp_prot,<br>        .ops = &amp;inet_dgram_ops,<br>        .flags = INET_PROTOSW_PERMANENT,<br>    &#125;,<br>    &#123;<br>        .type = SOCK_DGRAM,<br>        .protocol = IPPROTO_ICMP,<br>        .prot = &amp;ping_prot,<br>        .ops = &amp;inet_sockraw_ops,<br>        .flags = INET_PROTOSW_REUSE,<br>    &#125;,<br>    &#123;<br>        .type = SOCK_RAW,<br>        .protocol = IPPROTO_IP,<br>        .prot = &amp;raw_prot,<br>        .ops = &amp;inet_sockraw_ops,<br>        .flags = INET_PROTOSW_REUSE,<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)<br>    inet_register_protosw(q);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inet_register_protosw</span><span class="hljs-params">(struct inet_protosw *p)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">lh</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_protosw</span> *<span class="hljs-title">answer</span>;</span><br>    <span class="hljs-comment">// 取出当前 struct inet_protosw 的 protocol</span><br>    <span class="hljs-keyword">int</span> protocol = p-&gt;protocol;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">last_perm</span>;</span><br><br>    spin_lock_bh(&amp;inetsw_lock);<br><br>    <span class="hljs-comment">// 下标越界 error</span><br>    <span class="hljs-keyword">if</span> (p-&gt;type &gt;= SOCK_MAX)<br>        <span class="hljs-keyword">goto</span> out_illegal;<br><br>    <span class="hljs-comment">// 根据 p-&gt;type 找到与 struct inet_protosw 下标对应的 inetsw[]</span><br>    last_perm = &amp;inetsw[p-&gt;type];<br>    <span class="hljs-comment">// #define list_for_each(pos, head) \</span><br>    <span class="hljs-comment">// for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span><br>    <span class="hljs-comment">// 一直循环找到最后一项, 然后将 &amp;p-&gt;list 挂上</span><br>    list_for_each(lh, &amp;inetsw[p-&gt;type]) &#123;<br>        <span class="hljs-comment">// list_entry 用于获取该链表项的结构</span><br>        answer = list_entry(lh, struct inet_protosw, <span class="hljs-built_in">list</span>);<br>        <span class="hljs-keyword">if</span> ((INET_PROTOSW_PERMANENT &amp; answer-&gt;flags) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (protocol == answer-&gt;protocol)<br>            <span class="hljs-keyword">goto</span> out_permanent;<br>        last_perm = lh;<br>    &#125;<br><br>    <span class="hljs-comment">// last_perm-&gt;next = &amp;p-&gt;list</span><br>    list_add_rcu(&amp;p-&gt;<span class="hljs-built_in">list</span>, last_perm);<br>out:<br>    spin_unlock_bh(&amp;inetsw_lock);<br>    <span class="hljs-keyword">return</span>;<br>out_permanent:<br>    pr_err(<span class="hljs-string">"Attempt to override permanent protocol %d\n"</span>, protocol);<br>    <span class="hljs-keyword">goto</span> out;<br>out_illegal:<br>    pr_err(<span class="hljs-string">"Ignoring attempt to register invalid socket type %d\n"</span>, p-&gt;type);<br>    <span class="hljs-keyword">goto</span> out;<br>&#125;<br>EXPORT_SYMBOL(inet_register_protosw);<br></code></pre></td></tr></table></figure>
<p>回到 <code>list_for_each_entry_rcu</code> 循环，这时候就很容易理解了，它其实是根据我们指定的类型 sock-&gt;type，在 inetsw 数组（每个元素都是一个链表）对应的 <code>inetsw[sock-&gt;type]</code> 链表中查找每一个 <code>struct inet_protosw</code> 中的 protocol 是否是用户指定的 protocol，如果是的话，我们就找到了与用户指定 protocol。<br>
到了这里，首先我们使用的 create 函数 <code>inet_create</code> 是与 family 对应的，然后选择的 struct inet_protosw 是与 type 对应的，最后在与 type 对应的链表中找到与 protocol 对应的那个 <code>struct inet_protosw *answer</code>。<br>
接下来，我们需要根据选出的 answer 来更新新建的 socket 的操作，从上面 struct inet_protosw 就能够看出，以 TCP 为例，answer 对应的 ops 为 inet_stream_ops，后面针对这个 socket 的所有操作使用的都是 inet_stream_ops。</p>
<p>inet_stream_ops 定义在 <code>/net/ipv4/af_inet.c</code> 中：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto_ops</span> <span class="hljs-title">inet_stream_ops</span> = &#123;</span><br>    .family = PF_INET,<br>    .owner = THIS_MODULE,<br>    .<span class="hljs-built_in">release</span> = inet_release,<br>    .bind = inet_bind,<br>    .<span class="hljs-built_in">connect</span> = inet_stream_connect,<br>    .socketpair = sock_no_socketpair,<br>    .accept = inet_accept,<br>    .getname = inet_getname,<br>    .poll = tcp_poll,<br>    .ioctl = inet_ioctl,<br>    .gettstamp = sock_gettstamp,<br>    .<span class="hljs-built_in">listen</span> = inet_listen,<br>    .<span class="hljs-built_in">shutdown</span> = inet_shutdown,<br>    .setsockopt = sock_common_setsockopt,<br>    .getsockopt = sock_common_getsockopt,<br>    .sendmsg = inet_sendmsg,<br>    .recvmsg = inet_recvmsg,<br>#ifdef CONFIG_MMU<br>    .mmap = tcp_mmap,<br>#endif<br>    .sendpage = inet_sendpage,<br>    .splice_read = tcp_splice_read,<br>    .read_sock = tcp_read_sock,<br>    .sendmsg_locked = tcp_sendmsg_locked,<br>    .sendpage_locked = tcp_sendpage_locked,<br>    .peek_len = tcp_peek_len,<br>#ifdef CONFIG_COMPAT<br>    .compat_setsockopt = compat_sock_common_setsockopt,<br>    .compat_getsockopt = compat_sock_common_getsockopt,<br>    .compat_ioctl = inet_compat_ioctl,<br>#endif<br>    .set_rcvlowat = tcp_set_rcvlowat,<br>&#125;;<br>EXPORT_SYMBOL(inet_stream_ops);<br></code></pre></td></tr></table></figure>
<p>接着又出现了一个新的结构 <code>struct proto</code>，它定义在 <code>/include/net/sock.h</code> 中，是附加在 socket 中的网络层协议块，是 socket 层到传输层的接口，从下面的定义可以看出，这个结构体中定义的都是 <code>struct sock</code> 的相关操作：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> &#123;</span><br>    <span class="hljs-keyword">void</span> (*<span class="hljs-built_in">close</span>)(struct sock *sk, <span class="hljs-keyword">long</span> timeout);<br>    <span class="hljs-keyword">int</span> (*pre_connect)(struct sock *sk, struct sockaddr *uaddr, <span class="hljs-keyword">int</span> addr_len);<br>    <span class="hljs-keyword">int</span> (*<span class="hljs-built_in">connect</span>)(struct sock *sk, struct sockaddr *uaddr, <span class="hljs-keyword">int</span> addr_len);<br>    <span class="hljs-keyword">int</span> (*<span class="hljs-built_in">disconnect</span>)(struct sock *sk, <span class="hljs-keyword">int</span> flags);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *(*<span class="hljs-title">accept</span>)(<span class="hljs-title">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>, <span class="hljs-title">int</span> <span class="hljs-title">flags</span>, <span class="hljs-title">int</span> *<span class="hljs-title">err</span>, <span class="hljs-title">bool</span> <span class="hljs-title">kern</span>);</span><br><br>    <span class="hljs-keyword">int</span> (*ioctl)(struct sock *sk, <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg);<br>    <span class="hljs-keyword">int</span> (*init)(struct sock *sk);<br>    <span class="hljs-keyword">void</span> (*destroy)(struct sock *sk);<br>    <span class="hljs-keyword">void</span> (*<span class="hljs-built_in">shutdown</span>)(struct sock *sk, <span class="hljs-keyword">int</span> how);<br>    <span class="hljs-keyword">int</span> (*setsockopt)(struct sock *sk, <span class="hljs-keyword">int</span> level,<br>                      <span class="hljs-keyword">int</span> optname, <span class="hljs-keyword">char</span> __user *optval,<br>                      <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> optlen);<br>    <span class="hljs-keyword">int</span> (*getsockopt)(struct sock *sk, <span class="hljs-keyword">int</span> level,<br>                      <span class="hljs-keyword">int</span> optname, <span class="hljs-keyword">char</span> __user *optval,<br>                      <span class="hljs-keyword">int</span> __user *option);<br>    <span class="hljs-keyword">void</span> (*keepalive)(struct sock *sk, <span class="hljs-keyword">int</span> valbool);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_COMPAT</span><br>    <span class="hljs-keyword">int</span> (*compat_setsockopt)(struct sock *sk,<br>                             <span class="hljs-keyword">int</span> level,<br>                             <span class="hljs-keyword">int</span> optname, <span class="hljs-keyword">char</span> __user *optval,<br>                             <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> optlen);<br>    <span class="hljs-keyword">int</span> (*compat_getsockopt)(struct sock *sk,<br>                             <span class="hljs-keyword">int</span> level,<br>                             <span class="hljs-keyword">int</span> optname, <span class="hljs-keyword">char</span> __user *optval,<br>                             <span class="hljs-keyword">int</span> __user *option);<br>    <span class="hljs-keyword">int</span> (*compat_ioctl)(struct sock *sk,<br>                        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">int</span> (*sendmsg)(struct sock *sk, struct msghdr *msg,<br>                   <span class="hljs-keyword">size_t</span> len);<br>    <span class="hljs-keyword">int</span> (*recvmsg)(struct sock *sk, struct msghdr *msg,<br>                   <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> noblock, <span class="hljs-keyword">int</span> flags,<br>                   <span class="hljs-keyword">int</span> *addr_len);<br>    <span class="hljs-keyword">int</span> (*sendpage)(struct sock *sk, struct page *page,<br>                    <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">int</span> flags);<br>    <span class="hljs-keyword">int</span> (*bind)(struct sock *sk,<br>                struct sockaddr *uaddr, <span class="hljs-keyword">int</span> addr_len);<br><br>    <span class="hljs-keyword">int</span> (*backlog_rcv)(struct sock *sk,<br>                       struct sk_buff *skb);<br><br>    <span class="hljs-keyword">void</span> (*release_cb)(struct sock *sk);<br><br>    <span class="hljs-keyword">int</span> (*hash)(struct sock *sk);<br>    <span class="hljs-keyword">void</span> (*unhash)(struct sock *sk);<br>    <span class="hljs-keyword">void</span> (*rehash)(struct sock *sk);<br>    <span class="hljs-keyword">int</span> (*get_port)(struct sock *sk, <span class="hljs-keyword">unsigned</span> short snum);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_PROC_FS</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> inuse_idx;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-keyword">bool</span> (*stream_memory_free)(<span class="hljs-keyword">const</span> struct sock *sk, <span class="hljs-keyword">int</span> wake);<br>    <span class="hljs-keyword">bool</span> (*stream_memory_read)(<span class="hljs-keyword">const</span> struct sock *sk);<br>    <span class="hljs-keyword">void</span> (*enter_memory_pressure)(struct sock *sk);<br>    <span class="hljs-keyword">void</span> (*leave_memory_pressure)(struct sock *sk);<br>    <span class="hljs-keyword">atomic_long_t</span> *memory_allocated;          <span class="hljs-comment">/* Current allocated memory. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">percpu_counter</span> *<span class="hljs-title">sockets_allocated</span>;</span> <span class="hljs-comment">/* Current number of sockets. */</span><br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> *memory_pressure;<br>    <span class="hljs-keyword">long</span> *sysctl_mem;<br><br>    <span class="hljs-keyword">int</span> *sysctl_wmem;<br>    <span class="hljs-keyword">int</span> *sysctl_rmem;<br>    u32 sysctl_wmem_offset;<br>    u32 sysctl_rmem_offset;<br><br>    <span class="hljs-keyword">int</span> max_header;<br>    <span class="hljs-keyword">bool</span> no_autobind;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmem_cache</span> *<span class="hljs-title">slab</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> obj_size;<br>    <span class="hljs-keyword">slab_flags_t</span> slab_flags;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> useroffset; <span class="hljs-comment">/* Usercopy region offset */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> usersize;   <span class="hljs-comment">/* Usercopy region size */</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">percpu_counter</span> *<span class="hljs-title">orphan_count</span>;</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_sock_ops</span> *<span class="hljs-title">rsk_prot</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timewait_sock_ops</span> *<span class="hljs-title">twsk_prot</span>;</span><br><br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_hashinfo</span> *<span class="hljs-title">hashinfo</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">udp_table</span> *<span class="hljs-title">udp_table</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">raw_hashinfo</span> *<span class="hljs-title">raw_hash</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">smc_hashinfo</span> *<span class="hljs-title">smc_hash</span>;</span><br>    &#125; h;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">32</span>];<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">node</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> SOCK_REFCNT_DEBUG</span><br>    <span class="hljs-keyword">atomic_t</span> socks;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">int</span> (*diag_destroy)(struct sock *sk, <span class="hljs-keyword">int</span> err);<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure>
<p>这也就是说，对上的 socket 操作都定义在 ops 中，而对下的 sock 操作都定义在 prot 中，从我们选定的 answer 一样能够获取到对应 TCP 的 struct proto，即 tcp_prot，我们用 tcp_prot 初始化 struct sock，这个 tcp_prot 定义在 <code>/net/ipv4/tcp_ipv4.c</code> 中，里面的行为对应的就是 TCP 协议下内核网络协议栈的所有操作：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto</span> <span class="hljs-title">tcp_prot</span> = &#123;</span><br>    .name = <span class="hljs-string">"TCP"</span>,<br>    .owner = THIS_MODULE,<br>    .<span class="hljs-built_in">close</span> = tcp_close,<br>    .pre_connect = tcp_v4_pre_connect,<br>    .<span class="hljs-built_in">connect</span> = tcp_v4_connect,<br>    .<span class="hljs-built_in">disconnect</span> = tcp_disconnect,<br>    .accept = inet_csk_accept,<br>    .ioctl = tcp_ioctl,<br>    .init = tcp_v4_init_sock,<br>    .destroy = tcp_v4_destroy_sock,<br>    .<span class="hljs-built_in">shutdown</span> = tcp_shutdown,<br>    .setsockopt = tcp_setsockopt,<br>    .getsockopt = tcp_getsockopt,<br>    .keepalive = tcp_set_keepalive,<br>    .recvmsg = tcp_recvmsg,<br>    .sendmsg = tcp_sendmsg,<br>    .sendpage = tcp_sendpage,<br>    .backlog_rcv = tcp_v4_do_rcv,<br>    .release_cb = tcp_release_cb,<br>    .hash = inet_hash,<br>    .unhash = inet_unhash,<br>    .get_port = inet_csk_get_port,<br>    .enter_memory_pressure = tcp_enter_memory_pressure,<br>    .leave_memory_pressure = tcp_leave_memory_pressure,<br>    .stream_memory_free = tcp_stream_memory_free,<br>    .sockets_allocated = &amp;tcp_sockets_allocated,<br>    .orphan_count = &amp;tcp_orphan_count,<br>    .memory_allocated = &amp;tcp_memory_allocated,<br>    .memory_pressure = &amp;tcp_memory_pressure,<br>    .sysctl_mem = sysctl_tcp_mem,<br>    .sysctl_wmem_offset = offsetof(struct net, ipv4.sysctl_tcp_wmem),<br>    .sysctl_rmem_offset = offsetof(struct net, ipv4.sysctl_tcp_rmem),<br>    .max_header = MAX_TCP_HEADER,<br>    .obj_size = <span class="hljs-keyword">sizeof</span>(struct tcp_sock),<br>    .slab_flags = SLAB_TYPESAFE_BY_RCU,<br>    .twsk_prot = &amp;tcp_timewait_sock_ops,<br>    .rsk_prot = &amp;tcp_request_sock_ops,<br>    .h.hashinfo = &amp;tcp_hashinfo,<br>    .no_autobind = <span class="hljs-literal">true</span>,<br>#ifdef CONFIG_COMPAT<br>    .compat_setsockopt = compat_tcp_setsockopt,<br>    .compat_getsockopt = compat_tcp_getsockopt,<br>#endif<br>    .diag_destroy = tcp_abort,<br>&#125;;<br>EXPORT_SYMBOL(tcp_prot);<br></code></pre></td></tr></table></figure>
<p>inet_create 函数中我们还差 struct inet_sock 结构没有分析，打开这个结构能够发现很有意思的一幕，struct inet_sock 其实就是 struct sock 的扩展，在 struct sock 的基础上增加了一些东西，具体可以看下面的注释，也就是说，inet_sk 函数其实是进行了一次强制转换，将 <code>struct sock*</code> 转换成了 <code>struct inet_sock</code>，内核中经常能见到这样的操作，将一个结构放在另一个结构的开始位置，然后对这个新的结构进行扩展，当需要访问的时候，通过对原结构指针的强制转换就能够访问新的结构体成员，这在某种意义上来说就是 C++ 中的继承和多态，果然编程的原理都是相通的。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**<br> * @sk - 祖先类<br> * @pinet6 - IPv6 控制块的指针<br> * @inet_daddr - 目标 IPv4 地址<br> * @inet_rcv_saddr - 绑定本地 IPv4 地址<br> * @inet_dport - 目标端口<br> * @inet_num - 本地端口, 主机序<br> * @inet_saddr - 发送源地址<br> * @uc_ttl - 单播 TTL<br> * @inet_sport - 源端口, 网络序<br> * @inet_id - ID counter for DF pkts<br> * @tos - TOS<br> * @mc_ttl - 多播 TTL<br> * @is_icsk - 是否是 TCP 状态维护结构 inet_connection_sock<br> * @uc_index - 单播发出设备索引<br> * @mc_index - 多播设备索引<br> * @mc_list - Group array<br> * @cork - info to build ip hdr on each ip frag while socket is corked<br> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_sock</span><br>&#123;</span><br>    <span class="hljs-comment">// sk 和 pinet6 必须放在结构体的起始位置</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> <span class="hljs-title">sk</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> IS_ENABLED(CONFIG_IPV6)</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipv6_pinfo</span> *<span class="hljs-title">pinet6</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inet_daddr sk.__sk_common.skc_daddr</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inet_rcv_saddr sk.__sk_common.skc_rcv_saddr</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inet_dport sk.__sk_common.skc_dport</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inet_num sk.__sk_common.skc_num</span><br><br>    __be32 inet_saddr;<br>    __s16 uc_ttl;<br>    __u16 cmsg_flags;<br>    __be16 inet_sport;<br>    __u16 inet_id;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip_options_rcu</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">inet_opt</span>;</span><br>    <span class="hljs-keyword">int</span> rx_dst_ifindex;<br>    __u8 tos;<br>    __u8 min_ttl;<br>    __u8 mc_ttl;<br>    __u8 pmtudisc;<br>    __u8 recverr : <span class="hljs-number">1</span>,<br>        is_icsk : <span class="hljs-number">1</span>,<br>        freebind : <span class="hljs-number">1</span>,<br>        hdrincl : <span class="hljs-number">1</span>,<br>        mc_loop : <span class="hljs-number">1</span>,<br>        transparent : <span class="hljs-number">1</span>,<br>        mc_all : <span class="hljs-number">1</span>,<br>        nodefrag : <span class="hljs-number">1</span>;<br>    __u8 bind_address_no_port : <span class="hljs-number">1</span>,<br>        defer_connect : <span class="hljs-number">1</span>;<br>    __u8 rcv_tos;<br>    __u8 convert_csum;<br>    <span class="hljs-keyword">int</span> uc_index;<br>    <span class="hljs-keyword">int</span> mc_index;<br>    __be32 mc_addr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip_mc_socklist</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">mc_list</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_cork_full</span> <span class="hljs-title">cork</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>执行完 inet_create 后，socket 的创建已经完成了，之后回到 __sys_socket，调用 sock_map_fd 将这个新建的 struct socket 和 fd 绑定并将 fd 返回，socket 调用完成。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sock_map_fd</span><span class="hljs-params">(struct socket *sock, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">newfile</span>;</span><br>    <span class="hljs-comment">// 选取一个未被使用的 fd</span><br>    <span class="hljs-keyword">int</span> fd = get_unused_fd_flags(flags);<br>    <span class="hljs-keyword">if</span> (unlikely(fd &lt; <span class="hljs-number">0</span>)) &#123;<br>        sock_release(sock);<br>        <span class="hljs-keyword">return</span> fd;<br>    &#125;<br><br>    <span class="hljs-comment">// struct socket 与一个 struct file 对应</span><br>    <span class="hljs-comment">// sock-&gt;file = file</span><br>    <span class="hljs-comment">// file-&gt;private_data = sock</span><br>    <span class="hljs-comment">// 将 struct socket 指针放在 file 的 private_data 字段中</span><br>    newfile = sock_alloc_file(sock, flags, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!IS_ERR(newfile)) &#123;<br>        <span class="hljs-comment">// 将 struct file 与 fd 关联起来, 相当于 socket 与 fd 关联起来了</span><br>        fd_install(fd, newfile);<br>        <span class="hljs-keyword">return</span> fd;<br>    &#125;<br><br>    put_unused_fd(fd);<br>    <span class="hljs-keyword">return</span> PTR_ERR(newfile);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="绑定端口-bind">绑定端口 bind</h2>
<p>创建了 socket，我们需要将这个 socket 绑定到一个地址才能使用，这就类似于去电信登记自己的手机号。bind 的系统调用位于 <code>/net/socket.c</code>：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++">SYSCALL_DEFINE3(bind, <span class="hljs-keyword">int</span>, fd, struct sockaddr __user *, umyaddr, <span class="hljs-keyword">int</span>, addrlen) &#123;<br>    <span class="hljs-keyword">return</span> __sys_bind(fd, umyaddr, addrlen);<br>&#125;<br><br><span class="hljs-keyword">int</span> __sys_bind(<span class="hljs-keyword">int</span> fd, struct sockaddr __user *umyaddr, <span class="hljs-keyword">int</span> addrlen) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-keyword">int</span> err, fput_needed;<br><br>    <span class="hljs-comment">// 根据 fd 找到对应的 struct socket</span><br>    <span class="hljs-comment">// sockfd_lookup_light 会调用 sock_from_file</span><br>    <span class="hljs-comment">// 从 struct file 的 private_data 中取出 struct socket 指针</span><br>    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);<br>    <span class="hljs-keyword">if</span> (sock) &#123;<br>        <span class="hljs-comment">// 将 sockaddr 从用户态 umyaddr 拷贝到内核态 address, address 是内核空间的地址</span><br>        err = move_addr_to_kernel(umyaddr, addrlen, &amp;address);<br>        <span class="hljs-keyword">if</span> (!err) &#123;<br>            err = security_socket_bind(sock, (struct sockaddr *)&amp;address, addrlen);<br>            <span class="hljs-keyword">if</span> (!err)<br>                <span class="hljs-comment">// 调用的是 inet_stream_ops 中的 bind 函数, 也就是 inet_bind</span><br>                err = sock-&gt;ops-&gt;bind(sock, (struct sockaddr *)&amp;address, addrlen);<br>        &#125;<br>        fput_light(sock-&gt;file, fput_needed);<br>    &#125;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先先看参数 <code>struct sockaddr __user *umyaddr</code>，这是一个通用地址结构，固定长度为 16 字节。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span><br>    <span class="hljs-comment">// 地址族 AF_XX, sa_family_t 其实是一个 unsigned short</span><br>    <span class="hljs-keyword">sa_family_t</span> sa_family;<br>    <span class="hljs-comment">// 14 Bytes 的协议地址</span><br>    <span class="hljs-keyword">char</span> sa_data[<span class="hljs-number">14</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>然后看 address 变量，这是一个 sockaddr_storage 结构，定义如下，这是一个 128 字节的地址结构，之所以会出现第二个通用地址结构，是因为 struct sockaddr 这个结构装不下 28 位的 IPv6 的地址。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sockaddr_storage __kernel_sockaddr_storage</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">kernel_sockaddr_storage</span> &#123;</span><br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-keyword">__kernel_sa_family_t</span> ss_family;<br>            <span class="hljs-comment">// #define _K_SS_MAXSIZE    128</span><br>            <span class="hljs-keyword">char</span> __data[_K_SS_MAXSIZE - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> short)];<br>        &#125;;<br>        <span class="hljs-keyword">void</span> *__align;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>然后调用的就是 sock-&gt;ops-&gt;bind，还记得上一节中 TCP 协议对应的 ops 吗？没错，TCP 协议对应的 ops 为 inet_stream_ops，那么对应的 bind 函数就是 inet_bind，这里需要注意以下函数的参数，传入的地址指针是经过强制类型转换成 struct sockaddr 这个较小的通用地址，此外还有一个 addr_len 表示地址的长度，内核中其实正是用 addr_len 参数来区分地址的类型。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_bind</span><span class="hljs-params">(struct socket *sock, struct sockaddr *uaddr, <span class="hljs-keyword">int</span> addr_len)</span> </span>&#123;<br>    <span class="hljs-comment">// 从 struct socket 中取出对应的 struct sock</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span> = <span class="hljs-title">sock</span>-&gt;<span class="hljs-title">sk</span>;</span><br>    <span class="hljs-keyword">int</span> err;<br><br>    <span class="hljs-comment">// 如果 sk_port 中有 bind 函数, 就直接调用, 比如 SOCK_RAW</span><br>    <span class="hljs-keyword">if</span> (sk-&gt;sk_prot-&gt;bind) &#123;<br>        <span class="hljs-keyword">return</span> sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (addr_len &lt; <span class="hljs-keyword">sizeof</span>(struct sockaddr_in))<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    err = BPF_CGROUP_RUN_PROG_INET4_BIND(sk, uaddr);<br>    <span class="hljs-keyword">if</span> (err)<br>        <span class="hljs-keyword">return</span> err;<br><br>    <span class="hljs-keyword">return</span> __inet_bind(sk, uaddr, addr_len, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br>EXPORT_SYMBOL(inet_bind);<br></code></pre></td></tr></table></figure>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// TCP 最后还是会调用到 __inet_bind</span><br><span class="hljs-keyword">int</span> __inet_bind(struct sock *sk, struct sockaddr *uaddr, <span class="hljs-keyword">int</span> addr_len,<br>                <span class="hljs-keyword">bool</span> force_bind_address_no_port, <span class="hljs-keyword">bool</span> with_lock) &#123;<br>    <span class="hljs-comment">// struct sockaddr_in 是 IPv4 16 Byte 的地址结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">sockaddr_in</span> *)<span class="hljs-title">uaddr</span>;</span><br>    <span class="hljs-comment">// 获取 struct sk 的 TCP 扩展 struct inet_sock</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_sock</span> *<span class="hljs-title">inet</span> = <span class="hljs-title">inet_sk</span>(<span class="hljs-title">sk</span>);</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net</span> = <span class="hljs-title">sock_net</span>(<span class="hljs-title">sk</span>);</span><br>    <span class="hljs-keyword">unsigned</span> short snum;<br>    <span class="hljs-keyword">int</span> chk_addr_ret;<br>    u32 tb_id = RT_TABLE_LOCAL;<br>    <span class="hljs-keyword">int</span> err;<br><br>    <span class="hljs-keyword">if</span> (addr-&gt;sin_family != AF_INET) &#123;<br>        err = -EAFNOSUPPORT;<br>        <span class="hljs-keyword">if</span> (addr-&gt;sin_family != AF_UNSPEC ||<br>            addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY))<br>            <span class="hljs-keyword">goto</span> out;<br>    &#125;<br><br>    tb_id = l3mdev_fib_table_by_index(net, sk-&gt;sk_bound_dev_if) ?: tb_id;<br>    chk_addr_ret = inet_addr_type_table(net, addr-&gt;sin_addr.s_addr, tb_id);<br><br>    err = -EADDRNOTAVAIL;<br>    <span class="hljs-keyword">if</span> (!inet_can_nonlocal_bind(net, inet) &amp;&amp;<br>        addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY) &amp;&amp;<br>        chk_addr_ret != RTN_LOCAL &amp;&amp;<br>        chk_addr_ret != RTN_MULTICAST &amp;&amp;<br>        chk_addr_ret != RTN_BROADCAST)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    snum = ntohs(addr-&gt;sin_port);<br>    err = -EACCES;<br>    <span class="hljs-keyword">if</span> (snum &amp;&amp; inet_port_requires_bind_service(net, snum) &amp;&amp;<br>        !ns_capable(net-&gt;user_ns, CAP_NET_BIND_SERVICE))<br>        <span class="hljs-keyword">goto</span> out;<br><br>    <span class="hljs-keyword">if</span> (with_lock)<br>        lock_sock(sk);<br><br>    err = -EINVAL;<br>    <span class="hljs-keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;inet_num)<br>        <span class="hljs-keyword">goto</span> out_release_sock;<br><br>    <span class="hljs-comment">// inet_rcv_saddr 是本地的 IPv4 地址, 用 addr 地址对其初始化</span><br>    inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;<br>    <span class="hljs-keyword">if</span> (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)<br>        inet-&gt;inet_saddr = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (snum || !(inet-&gt;bind_address_no_port || force_bind_address_no_port)) &#123;<br>        <span class="hljs-comment">// 调用 tcp_prot 中的 inet_csk_get_port 判断端口是否被占用</span><br>        <span class="hljs-comment">// 如果被占用, 将上面修改的地址清零</span><br>        <span class="hljs-keyword">if</span> (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;<br>            inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="hljs-number">0</span>;<br>            err = -EADDRINUSE;<br>            <span class="hljs-keyword">goto</span> out_release_sock;<br>        &#125;<br>        err = BPF_CGROUP_RUN_PROG_INET4_POST_BIND(sk);<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">goto</span> out_release_sock;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (inet-&gt;inet_rcv_saddr)<br>        sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK;<br>    <span class="hljs-keyword">if</span> (snum)<br>        sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK;<br>    <span class="hljs-comment">// 设置本地端口</span><br>    inet-&gt;inet_sport = htons(inet-&gt;inet_num);<br>    <span class="hljs-comment">// 对端地址和端口都设置为 0</span><br>    inet-&gt;inet_daddr = <span class="hljs-number">0</span>;<br>    inet-&gt;inet_dport = <span class="hljs-number">0</span>;<br>    sk_dst_reset(sk);<br>    err = <span class="hljs-number">0</span>;<br>out_release_sock:<br>    <span class="hljs-keyword">if</span> (with_lock)<br>        release_sock(sk);<br>out:<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="监听端口-listen">监听端口 listen</h2>
<p>将 socket 与地址绑定后，接下来就需要 listen 监听这个 socket，同样我们继续看代码：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++">SYSCALL_DEFINE2(<span class="hljs-built_in">listen</span>, <span class="hljs-keyword">int</span>, fd, <span class="hljs-keyword">int</span>, backlog) &#123;<br>    <span class="hljs-keyword">return</span> __sys_listen(fd, backlog);<br>&#125;<br><br><span class="hljs-comment">// backlog 定义了所能接受 SYN 的最大客户端数量, 即半连接上限</span><br><span class="hljs-keyword">int</span> __sys_listen(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> backlog) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span><br>    <span class="hljs-keyword">int</span> err, fput_needed;<br>    <span class="hljs-keyword">int</span> somaxconn;<br><br>    <span class="hljs-comment">// 通过 fd 获取 struct socket</span><br>    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);<br>    <span class="hljs-keyword">if</span> (sock) &#123;<br>        <span class="hljs-comment">// somaxconn 定义了服务端所能 accept 的最大客户端上限, 即完成连接上限</span><br>        <span class="hljs-comment">// 默认为 128, 不过通常都会修改成 1024 以上</span><br>        somaxconn = sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn;<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)backlog &gt; somaxconn)<br>            backlog = somaxconn;<br><br>        err = security_socket_listen(sock, backlog);<br>        <span class="hljs-keyword">if</span> (!err)<br>            <span class="hljs-comment">// 调用 inet_listen 进行监听</span><br>            err = sock-&gt;ops-&gt;<span class="hljs-built_in">listen</span>(sock, backlog);<br><br>        fput_light(sock-&gt;file, fput_needed);<br>    &#125;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先仍然是获取 fd 对应的 struct socket，然后会根据内核中设置的 somaxconn 的值修正 backlog 参数，确保半连接队列的长度不能超过最大 accept 队列的长度。<br>
然后调用 sock-&gt;ops-&gt;listen 开始监听，还是和上面一样，其实调用的是 inet_stream_ops 中的 inet_listen 函数。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_listen</span><span class="hljs-params">(struct socket *sock, <span class="hljs-keyword">int</span> backlog)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span> = <span class="hljs-title">sock</span>-&gt;<span class="hljs-title">sk</span>;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> old_state;<br>    <span class="hljs-keyword">int</span> err, tcp_fastopen;<br><br>    lock_sock(sk);<br><br>    err = -EINVAL;<br>    <span class="hljs-keyword">if</span> (sock-&gt;state != SS_UNCONNECTED || sock-&gt;type != SOCK_STREAM)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    old_state = sk-&gt;sk_state;<br>    <span class="hljs-keyword">if</span> (!((<span class="hljs-number">1</span> &lt;&lt; old_state) &amp; (TCPF_CLOSE | TCPF_LISTEN)))<br>        <span class="hljs-keyword">goto</span> out;<br><br>    WRITE_ONCE(sk-&gt;sk_max_ack_backlog, backlog);<br><br>    <span class="hljs-comment">// 如果 socket 已经处在 TCP_LISTEN 状态, 我们就只能够调整 backlog 的值</span><br>    <span class="hljs-keyword">if</span> (old_state != TCP_LISTEN) &#123;<br>        <span class="hljs-comment">// tcp_fastopen 允许服务器和客户端在建立连接阶段交换数据以减少时延, 默认关闭, 不作讨论</span><br>        tcp_fastopen = sock_net(sk)-&gt;ipv4.sysctl_tcp_fastopen;<br>        <span class="hljs-keyword">if</span> ((tcp_fastopen &amp; TFO_SERVER_WO_SOCKOPT1) &amp;&amp;<br>            (tcp_fastopen &amp; TFO_SERVER_ENABLE) &amp;&amp;<br>            !inet_csk(sk)-&gt;icsk_accept_queue.fastopenq.max_qlen) &#123;<br>            fastopen_queue_tune(sk, backlog);<br>            tcp_fastopen_init_key_once(sock_net(sk));<br>        &#125;<br><br>        <span class="hljs-comment">// inet_csk_listen_start 这里真正进入监听状态</span><br>        err = inet_csk_listen_start(sk, backlog);<br>        <span class="hljs-keyword">if</span> (err)<br>            <span class="hljs-keyword">goto</span> out;<br>        tcp_call_bpf(sk, BPF_SOCK_OPS_TCP_LISTEN_CB, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    err = <span class="hljs-number">0</span>;<br><br>out:<br>    release_sock(sk);<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br>EXPORT_SYMBOL(inet_listen);<br></code></pre></td></tr></table></figure>
<p>不难看出，inet_listen 会调用 inet_csk_listen_start 进入监听状态，里面出现了一个新结构 struct inet_connection_sock，看到 inet_csk 这种结构体指针转换函数其实就不难想到，struct inet_connection_sock 是 struct inet_sock 的扩展结构，而 struct inet_sock 又是 struct sock 的扩展结构，它们其实是一个不断嵌套的过程，唯一的要求是这些子结构体都必须位于扩展结构体的头部。<br>
<strong>我们说 TCP 是面向连接的，并不是指客户端与服务器之间有一条通路，而是 TCP 的两端都有一个维护连接状态的结构体，这个结构体就是 struct inet_connection_sock，这是一个面向连接的传输控制块</strong>。<br>
接下来我们来到 <code>reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue)</code>，看看 icsk_accept_queue 是什么。<br>
从内核的角度来说，我们不需要像写代码时那样在服务端调用 accept 之后才能让客户端发起 connect，事实上在服务端 listen 之后客户端就可以发起连接了。内核会为每个 socket 维护两个队列，一个是已经成功建立连接的队列，处于 established 状态，一个是尚未完成三次握手的队列，处于 syn_rcvd 状态，这里的 icsk_accept_queue 其实就是已经成功连接的队列，服务端调用 accept 其实就是从这个队列中取出一个连接进行处理。<br>
随后将 socket 状态设置为 TCP_LISTEN，再次判断端口是否被占用，listen 到此结束。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_csk_listen_start</span><span class="hljs-params">(struct sock *sk, <span class="hljs-keyword">int</span> backlog)</span> </span>&#123;<br>    <span class="hljs-comment">// 将 struct sock 扩展为 TCP 连接维护结构体</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock</span> *<span class="hljs-title">icsk</span> = <span class="hljs-title">inet_csk</span>(<span class="hljs-title">sk</span>);</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_sock</span> *<span class="hljs-title">inet</span> = <span class="hljs-title">inet_sk</span>(<span class="hljs-title">sk</span>);</span><br>    <span class="hljs-keyword">int</span> err = -EADDRINUSE;<br><br>    <span class="hljs-comment">// 这里面主要是初始化队列相关的锁</span><br>    reqsk_queue_alloc(&amp;icsk-&gt;icsk_accept_queue);<br><br>    sk-&gt;sk_ack_backlog = <span class="hljs-number">0</span>;<br>    inet_csk_delack_init(sk);<br><br>    <span class="hljs-comment">// 将 socket 状态设置为 TCP_LISTEN</span><br>    inet_sk_state_store(sk, TCP_LISTEN);<br>    <span class="hljs-comment">// 调用 tcp_prot 中的 inet_csk_get_port 判断端口是否被暂用</span><br>    <span class="hljs-keyword">if</span> (!sk-&gt;sk_prot-&gt;get_port(sk, inet-&gt;inet_num)) &#123;<br>        inet-&gt;inet_sport = htons(inet-&gt;inet_num);<br><br>        sk_dst_reset(sk);<br>        err = sk-&gt;sk_prot-&gt;hash(sk);<br><br>        <span class="hljs-keyword">if</span> (likely(!err))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    inet_sk_set_state(sk, TCP_CLOSE);<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br>EXPORT_SYMBOL_GPL(inet_csk_listen_start);<br></code></pre></td></tr></table></figure>
<h2 id="服务端取出连接-accept">服务端取出连接 accept</h2>
<p>这里我们仍然按照编码逻辑，先分析 accept 函数，服务端在 listen 之后就可以在循环中调用 accept 等待取出成功的连接。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++">SYSCALL_DEFINE3(accept, <span class="hljs-keyword">int</span>, fd, struct sockaddr __user *, upeer_sockaddr, <span class="hljs-keyword">int</span> __user *, upeer_addrlen) &#123;<br>    <span class="hljs-keyword">return</span> __sys_accept4(fd, upeer_sockaddr, upeer_addrlen, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 这里的参数 fd 就是前面通过 socket 创建并且经过 bind listen 的 listenfd</span><br><span class="hljs-keyword">int</span> __sys_accept4(<span class="hljs-keyword">int</span> fd, struct sockaddr __user *upeer_sockaddr, <span class="hljs-keyword">int</span> __user *upeer_addrlen, <span class="hljs-keyword">int</span> flags) &#123;<br>    <span class="hljs-keyword">int</span> ret = -EBADF;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd</span> <span class="hljs-title">f</span>;</span><br><br>    <span class="hljs-comment">// 找到 listenfd 对应的 struct file</span><br>    f = fdget(fd);<br>    <span class="hljs-keyword">if</span> (f.file) &#123;<br>        ret = __sys_accept4_file(f.file, <span class="hljs-number">0</span>, upeer_sockaddr, upeer_addrlen, flags, rlimit(RLIMIT_NOFILE));<br>        <span class="hljs-keyword">if</span> (f.flags)<br>            fput(f.file);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>__sys_accept4 最后还是要调用 __sys_accept4_file，首先从参数的 struct file 中取出 struct socket，然后创建了一个新的 struct socket newsock 将它的 type 与 ops 设置为与监听 socket 一样，这其实从侧面说明了监听 socket 与通信 socket 不是同一个 socket。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> __sys_accept4_file(struct file *file, <span class="hljs-keyword">unsigned</span> file_flags,<br>                       struct sockaddr __user *upeer_sockaddr,<br>                       <span class="hljs-keyword">int</span> __user *upeer_addrlen, <span class="hljs-keyword">int</span> flags,<br>                       <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> nofile) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>, *<span class="hljs-title">newsock</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">newfile</span>;</span><br>    <span class="hljs-keyword">int</span> err, len, newfd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span> <span class="hljs-title">address</span>;</span><br><br>    <span class="hljs-keyword">if</span> (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    <span class="hljs-keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))<br>        flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;<br><br>    <span class="hljs-comment">// 从 struct file 中取出 struct socket</span><br>    sock = sock_from_file(file, &amp;err);<br>    <span class="hljs-keyword">if</span> (!sock)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    err = -ENFILE;<br>    <span class="hljs-comment">// 创建一个新的 struct socket 并且分配一个新的 inode</span><br>    newsock = sock_alloc();<br>    <span class="hljs-keyword">if</span> (!newsock)<br>        <span class="hljs-keyword">goto</span> out;<br><br>    newsock-&gt;type = sock-&gt;type;<br>    newsock-&gt;ops = sock-&gt;ops;<br><br>    __module_get(newsock-&gt;ops-&gt;owner);<br><br>    <span class="hljs-comment">// 选取一个未使用的 fd</span><br>    newfd = __get_unused_fd_flags(flags, nofile);<br>    <span class="hljs-keyword">if</span> (unlikely(newfd &lt; <span class="hljs-number">0</span>)) &#123;<br>        err = newfd;<br>        sock_release(newsock);<br>        <span class="hljs-keyword">goto</span> out;<br>    &#125;<br><br>    <span class="hljs-comment">// 为 newsock 分配一个对应的 struct file 并且将 sock 指针放入 file-&gt;private_data 中</span><br>    newfile = sock_alloc_file(newsock, flags, sock-&gt;sk-&gt;sk_prot_creator-&gt;name);<br>    <span class="hljs-keyword">if</span> (IS_ERR(newfile)) &#123;<br>        err = PTR_ERR(newfile);<br>        put_unused_fd(newfd);<br>        <span class="hljs-keyword">goto</span> out;<br>    &#125;<br><br>    err = security_socket_accept(sock, newsock);<br>    <span class="hljs-keyword">if</span> (err)<br>        <span class="hljs-keyword">goto</span> out_fd;<br><br>    <span class="hljs-comment">// 调用 inet_stream_ops 中的 inet_accept 函数</span><br>    err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags | file_flags, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> out_fd;<br><br>    <span class="hljs-keyword">if</span> (upeer_sockaddr) &#123;<br>        len = newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr *)&amp;address, <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">0</span>) &#123;<br>            err = -ECONNABORTED;<br>            <span class="hljs-keyword">goto</span> out_fd;<br>        &#125;<br>        err = move_addr_to_user(&amp;address, len, upeer_sockaddr, upeer_addrlen);<br>        <span class="hljs-keyword">if</span> (err &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">goto</span> out_fd;<br>    &#125;<br><br>    <span class="hljs-comment">// 将 newfd 与成功关联 new socket 的 struct file 关联起来, 最后返回 newfd</span><br>    fd_install(newfd, newfile);<br>    err = newfd;<br>out:<br>    <span class="hljs-keyword">return</span> err;<br>out_fd:<br>    fput(newfile);<br>    put_unused_fd(newfd);<br>    <span class="hljs-keyword">goto</span> out;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着往下看，会调用 sock-&gt;ops-&gt;accept，按照上面的逻辑，调用的是 inet_stream_ops 中的 inet_accept 函数，在该函数中会调用 tcp_prot 的 accept 函数，我们在上面的初始化中能够查询到该函数是 inet_csk_accept。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 首先注意这里的 sock 还是旧的 socket</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_accept</span><span class="hljs-params">(struct socket *sock, struct socket *newsock, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">bool</span> kern)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk1</span> = <span class="hljs-title">sock</span>-&gt;<span class="hljs-title">sk</span>;</span><br>    <span class="hljs-keyword">int</span> err = -EINVAL;<br>    <span class="hljs-comment">// 调用 tcp_prot 中的 inet_csk_accept</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk2</span> = <span class="hljs-title">sk1</span>-&gt;<span class="hljs-title">sk_prot</span>-&gt;<span class="hljs-title">accept</span>(<span class="hljs-title">sk1</span>, <span class="hljs-title">flags</span>, &amp;<span class="hljs-title">err</span>, <span class="hljs-title">kern</span>);</span><br><br>    <span class="hljs-keyword">if</span> (!sk2)<br>        <span class="hljs-keyword">goto</span> do_err;<br><br>    lock_sock(sk2);<br><br>    sock_rps_record_flow(sk2);<br>    WARN_ON(!((<span class="hljs-number">1</span> &lt;&lt; sk2-&gt;sk_state) &amp; (TCPF_ESTABLISHED | TCPF_SYN_RECV | TCPF_CLOSE_WAIT | TCPF_CLOSE)));<br><br>    <span class="hljs-comment">// newsock-&gt;sock = sk2, accept 将已连接队列中取出的 struct sock 与 struct socket 关联起来</span><br>    sock_graft(sk2, newsock);<br><br>    <span class="hljs-comment">// 修改取出连接的状态</span><br>    newsock-&gt;state = SS_CONNECTED;<br>    err = <span class="hljs-number">0</span>;<br>    release_sock(sk2);<br>do_err:<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br>EXPORT_SYMBOL(inet_accept);<br></code></pre></td></tr></table></figure>
<p>下面我们来看一下 inet_csk_accept 的实现，这里面最重要的是 inet_csk_wait_for_connect，如果已经完成的队列为空，就会进入这个函数，否则就从已完成连接队列中取出一个 struct sock 并返回，这个 newsock 会赋给 inet_accept 函数中的 sk2，在 sock_graft 函数中 sk2 会与这个新的 newsock 关联起来，最后将 newsock-&gt;state 设置为 SS_CONNECTED，最后被修改的 newsock 会与一个文件描述符 newfd 关联起来，返回给用户使用。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">struct sock *<span class="hljs-title">inet_csk_accept</span><span class="hljs-params">(struct sock *sk, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">int</span> *err, <span class="hljs-keyword">bool</span> kern)</span> </span>&#123;<br>    <span class="hljs-comment">// 首先转换出 TCP 连接维护结构体 inet_connection_sock</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock</span> *<span class="hljs-title">icsk</span> = <span class="hljs-title">inet_csk</span>(<span class="hljs-title">sk</span>);</span><br>    <span class="hljs-comment">// 已完成连接队列, 队列项中能够直接取到 struct sock* sk</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_sock_queue</span> *<span class="hljs-title">queue</span> = &amp;<span class="hljs-title">icsk</span>-&gt;<span class="hljs-title">icsk_accept_queue</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_sock</span> *<span class="hljs-title">req</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">newsk</span>;</span><br>    <span class="hljs-keyword">int</span> error;<br><br>    lock_sock(sk);<br><br>    <span class="hljs-comment">// 确保 socket 处在 TCP_LISTEN 状态, 这个 sk_state 表示的是 socket 底层的连接状态</span><br>    error = -EINVAL;<br>    <span class="hljs-keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)<br>        <span class="hljs-keyword">goto</span> out_err;<br><br>    <span class="hljs-comment">// 如果已经完成连接的队列为空</span><br>    <span class="hljs-keyword">if</span> (reqsk_queue_empty(<span class="hljs-built_in">queue</span>)) &#123;<br>        <span class="hljs-keyword">long</span> timeo = sock_rcvtimeo(sk, flags &amp; O_NONBLOCK);<br><br>        <span class="hljs-comment">// 如果这个 socket 是非阻塞的, 直接返回</span><br>        error = -EAGAIN;<br>        <span class="hljs-keyword">if</span> (!timeo)<br>            <span class="hljs-keyword">goto</span> out_err;<br><br>        <span class="hljs-comment">// 否则阻塞在这里</span><br>        error = inet_csk_wait_for_connect(sk, timeo);<br>        <span class="hljs-keyword">if</span> (error)<br>            <span class="hljs-keyword">goto</span> out_err;<br>    &#125;<br>    req = reqsk_queue_remove(<span class="hljs-built_in">queue</span>, sk);<br>    newsk = req-&gt;sk;<br><br>    <span class="hljs-keyword">if</span> (sk-&gt;sk_protocol == IPPROTO_TCP &amp;&amp; tcp_rsk(req)-&gt;tfo_listener) &#123;<br>        spin_lock_bh(&amp;<span class="hljs-built_in">queue</span>-&gt;fastopenq.lock);<br>        <span class="hljs-keyword">if</span> (tcp_rsk(req)-&gt;tfo_listener) &#123;<br>            req-&gt;sk = <span class="hljs-literal">NULL</span>;<br>            req = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        spin_unlock_bh(&amp;<span class="hljs-built_in">queue</span>-&gt;fastopenq.lock);<br>    &#125;<br><br>out:<br>    release_sock(sk);<br>    <span class="hljs-keyword">if</span> (newsk &amp;&amp; mem_cgroup_sockets_enabled) &#123;<br>        <span class="hljs-keyword">int</span> amt;<br>        lock_sock(newsk);<br><br>        amt = sk_mem_pages(newsk-&gt;sk_forward_alloc + atomic_read(&amp;newsk-&gt;sk_rmem_alloc));<br>        mem_cgroup_sk_alloc(newsk);<br>        <span class="hljs-keyword">if</span> (newsk-&gt;sk_memcg &amp;&amp; amt)<br>            mem_cgroup_charge_skmem(newsk-&gt;sk_memcg, amt);<br>        release_sock(newsk);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (req)<br>        reqsk_put(req);<br>    <span class="hljs-keyword">return</span> newsk;<br>out_err:<br>    newsk = <span class="hljs-literal">NULL</span>;<br>    req = <span class="hljs-literal">NULL</span>;<br>    *err = error;<br>    <span class="hljs-keyword">goto</span> out;<br>&#125;<br>EXPORT_SYMBOL(inet_csk_accept);<br></code></pre></td></tr></table></figure>
<p>那么我们再看一下如果连接就绪队列为空的时候，inet_csk_wait_for_connect 都做了些什么。<br>
inet_csk_wait_for_connect 最主要的功能就是等待客户端连接，为了避免竞态出现，该函数必须在 socket 上锁的情况下调用。<br>
在 icsk_accept_queue 队列为空的时候，内核会主动调度 schedule_timeout 让出 CPU 一段时间，等到重新唤醒的时候会检查 icsk_accept_queue 是否还为空，socket 是否处在监听状态以及是否有信号需要处理。</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">inet_csk_wait_for_connect</span><span class="hljs-params">(struct sock *sk, <span class="hljs-keyword">long</span> timeo)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet_connection_sock</span> *<span class="hljs-title">icsk</span> = <span class="hljs-title">inet_csk</span>(<span class="hljs-title">sk</span>);</span><br>    DEFINE_WAIT(wait);<br>    <span class="hljs-keyword">int</span> err;<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 将进程状态设置为等待资源有效时唤醒 TASK_INTERRUPTIBLE</span><br>        prepare_to_wait_exclusive(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);<br>        release_sock(sk);<br>        <span class="hljs-keyword">if</span> (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))<br>            <span class="hljs-comment">// 主动调度让出 CPU, timeo 时间后唤醒</span><br>            timeo = schedule_timeout(timeo);<br>        sched_annotate_sleep();<br>        <span class="hljs-comment">// 唤醒后先上锁</span><br>        lock_sock(sk);<br>        err = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 判断 icsk_accept_queue 队列是否为空, 如果不为空, 直接退出循环返回</span><br>        <span class="hljs-keyword">if</span> (!reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))<br>            <span class="hljs-keyword">break</span>;<br>        err = -EINVAL;<br>        <span class="hljs-comment">// 如果 socket 退出监听了, 直接退出循环返回</span><br>        <span class="hljs-keyword">if</span> (sk-&gt;sk_state != TCP_LISTEN)<br>            <span class="hljs-keyword">break</span>;<br>        err = sock_intr_errno(timeo);<br>        <span class="hljs-comment">// 如果有信号待处理, 直接退出循环返回</span><br>        <span class="hljs-keyword">if</span> (signal_pending(current))<br>            <span class="hljs-keyword">break</span>;<br>        err = -EAGAIN;<br>        <span class="hljs-keyword">if</span> (!timeo)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    finish_wait(sk_sleep(sk), &amp;wait);<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Archie Scott</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/ArchieScott/posts/89581d24/">https://github.com/ArchieScott/posts/89581d24/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/ArchieScott" target="_blank">夏の終わり</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Socket/">Socket</a><a class="post-meta__tags" href="/tags/Linux-Kernel/">Linux-Kernel</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/07/19/KpU5NjST9hHXvbl.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechatpay.png" alt="wechat" onclick="window.open('/img/wechatpay.png')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="alipay" onclick="window.open('/img/alipay.jpg')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/e0e3a2af/"><img class="prev-cover" data-src="https://i.loli.net/2020/07/19/l5ktRbcGCiYOJfz.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">浅析 Linux 内核：链表的实现</div></div></a></div><div class="next-post pull-right"><a href="/posts/a4099fa0/"><img class="next-cover" data-src="https://i.loli.net/2020/07/19/c1EOdjLbzienwqa.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">decltype 陷阱</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/4bc0bb9f/" title="浅析 Linux 内核：connect 与三次握手"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/07/19/l5ktRbcGCiYOJfz.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-05</div><div class="relatedPosts_title">浅析 Linux 内核：connect 与三次握手</div></div></a></div><div class="relatedPosts_item"><a href="/posts/e0e3a2af/" title="浅析 Linux 内核：链表的实现"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/07/19/l5ktRbcGCiYOJfz.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-04</div><div class="relatedPosts_title">浅析 Linux 内核：链表的实现</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: '8Q0H1FlCSwH5h7HQWC46LjKJ-MdYXbMMI',
  appKey: 'j08JUoxyhUwEvKHN2JOA6w98',
  placeholder: '404 Not Found',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: true,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Archie Scott</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">好久不见      欢迎光临</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>