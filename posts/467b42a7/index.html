<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++ Quiz 题解 101~200 | 夏の終わり</title><meta name="description" content="C++ Quiz 题解 101~200 整理，本篇有趣的题目：105 111 116 122 127 129 130 133 135 148 160 163 190 193 195 198"><meta name="keywords" content="C/C++,C++ Quiz,Programming-Language"><meta name="author" content="Archie Scott"><meta name="copyright" content="Archie Scott"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon-32x32.ico"><link rel="canonical" href="https://github.com/ArchieScott/posts/467b42a7/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="C++ Quiz 题解 101~200"><meta property="og:url" content="https://github.com/ArchieScott/posts/467b42a7/"><meta property="og:site_name" content="夏の終わり"><meta property="og:description" content="C++ Quiz 题解 101~200 整理，本篇有趣的题目：105 111 116 122 127 129 130 133 135 148 160 163 190 193 195 198"><meta property="og:image" content="https://i.loli.net/2020/07/19/c1EOdjLbzienwqa.jpg"><meta property="article:published_time" content="2020-02-27T06:56:07.000Z"><meta property="article:modified_time" content="2020-07-19T07:51:45.135Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="C++ Quiz 题解 201~300" href="https://github.com/ArchieScott/posts/7651320d/"><link rel="next" title="C++ Quiz 题解 001~100" href="https://github.com/ArchieScott/posts/e24af74a/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e59f8dfb4bb380e67ac19b4fd032ba4c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: {"languages":{"author":"作者: Archie Scott","link":"链接: ","source":"来源: 夏の終わり","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法制,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">24</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-photo-video"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-105"><span class="toc-text">Q 105</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-106"><span class="toc-text">Q 106</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-107"><span class="toc-text">Q 107</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-109"><span class="toc-text">Q 109</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-111"><span class="toc-text">Q 111</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-112"><span class="toc-text">Q 112</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-113"><span class="toc-text">Q 113</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-114"><span class="toc-text">Q 114</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-115"><span class="toc-text">Q 115</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-116"><span class="toc-text">Q 116</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-118"><span class="toc-text">Q 118</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-119"><span class="toc-text">Q 119</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-120"><span class="toc-text">Q 120</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-121"><span class="toc-text">Q 121</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-122"><span class="toc-text">Q 122</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-124"><span class="toc-text">Q 124</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-125"><span class="toc-text">Q 125</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-126"><span class="toc-text">Q 126</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-127"><span class="toc-text">Q 127</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-129"><span class="toc-text">Q 129</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-130"><span class="toc-text">Q 130</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-131"><span class="toc-text">Q 131</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-132"><span class="toc-text">Q 132</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-133"><span class="toc-text">Q 133</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-135"><span class="toc-text">Q 135</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-140"><span class="toc-text">Q 140</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-144"><span class="toc-text">Q 144</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-145"><span class="toc-text">Q 145</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-147"><span class="toc-text">Q 147</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-148"><span class="toc-text">Q 148</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-151"><span class="toc-text">Q 151</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-152"><span class="toc-text">Q 152</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-153"><span class="toc-text">Q 153</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-157"><span class="toc-text">Q 157</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-158"><span class="toc-text">Q 158</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-159"><span class="toc-text">Q 159</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-160"><span class="toc-text">Q 160</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-161"><span class="toc-text">Q 161</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-162"><span class="toc-text">Q 162</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-163"><span class="toc-text">Q 163</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-174"><span class="toc-text">Q 174</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-177"><span class="toc-text">Q 177</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-178"><span class="toc-text">Q 178</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-184"><span class="toc-text">Q 184</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-185"><span class="toc-text">Q 185</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-186"><span class="toc-text">Q 186</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-187"><span class="toc-text">Q 187</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-188"><span class="toc-text">Q 188</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-190"><span class="toc-text">Q 190</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-191"><span class="toc-text">Q 191</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-192"><span class="toc-text">Q 192</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-193"><span class="toc-text">Q 193</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-195"><span class="toc-text">Q 195</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-196"><span class="toc-text">Q 196</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-197"><span class="toc-text">Q 197</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-198"><span class="toc-text">Q 198</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/07/19/KnLcaHm9CDGFJ8j.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">夏の終わり</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-photo-video"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">C++ Quiz 题解 101~200</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-02-27 14:56:07"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-02-27</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-19 15:51:45"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-19</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/C-C/">C/C++</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">7.8k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 34 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h4 id="Q-105">Q 105</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">label:</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">if</span> (i--)</span><br><span class="line">        <span class="keyword">goto</span> label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：aAaA<br>
C++ 标准对于 <code>goto</code> 语句有如下要求：<br>
具有自动存储期的变量会在跳转之前被销毁而不是在跳转之后被销毁。</p>
<h4 id="Q-106">Q 106</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="keyword">int</span> y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序链接错误，行为未定义<br>
C++ 为了支持函数重载，其中的函数在被 C++ 编译后在符号库中的名字与 C 语言的不同。为了实现 C++ 与 C 的混合编程，C++ 引入了 <code>extern &quot;C&quot;</code>，被 <code>extern &quot;C&quot;</code> 修饰的函数或者变量是按照C语言方式编译和链接的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;       <span class="comment">//声明一个全局变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a = <span class="number">0</span>;   <span class="comment">//定义全局变量并给初值</span></span><br></pre></td></tr></table></figure>
<p>原代码中的<code>extern &quot;C&quot; int x;</code> 表示被它修饰的目标是 extern 的；其次，被它修饰的目标代码是 “C” 的。所以说这条语句表示的是<strong>声明一个 C 类型的变量</strong>。<br>
而<code>extern &quot;C&quot; { int y; }</code> 表示则的是定义一个 C 类型的变量。</p>
<h4 id="Q-107">Q 107</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f"</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g"</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    h(&#123;f(), g()&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：fg<br>
这道题的考点是初始化列表中参数的计算顺序，C++ 标准规定，初始化列表中的子句按照它们出现的顺序进行计算。</p>
<h4 id="Q-109">Q 109</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_with</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(T)&gt; f, T val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">print</span> = [] (<span class="keyword">int</span> x) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x; &#125;;</span><br><span class="line">    call_with(<span class="built_in">print</span>, <span class="number">42</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
编译器会推导每个参数的 <code>T</code> 并检查推导类型是否匹配。<br>
<code>lambda</code> 是完全不同的类型，不能与 <code>std::function&lt;void(T)</code>&gt; 匹配，这种情况需要将第一个参数转换为非推导上下文 - <em>nondeduced context</em> - 来解决。<br>
非推导上下文是一种类型的嵌套名称说明符。<br>
举几个例子：<br>
类型 <code>A&lt;T&gt;::B&lt;T2&gt;</code> 中 <code>T</code> 与 <code>T2</code> 都是非推导的；<br>
<code>void f(typename A&lt;T&gt;::B, A&lt;T&gt;)</code> 中的第一个 <code>T</code> 是非推导的，第二个 <code>T</code> 是推导的。<br>
使用一个 helper struct 辅助结构模板可以将 <code>std::function&lt;void(T)&gt;</code> 转换为非推导上下文：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_identity</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_with</span><span class="params">(<span class="keyword">typename</span> type_identity&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(T)&gt;&gt;::type f, T val)</span> </span>&#123;</span><br><span class="line">    f(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，还可以像下面这样明确指定模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_with&lt;<span class="keyword">int</span>&gt;(<span class="built_in">print</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Q-111">Q 111</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
<code>continue</code> 语句会将控制传递给最小封闭迭代语句的循环延续部分，换句话说，就是<strong>循环的末尾而不是起始</strong>。</p>
<h4 id="Q-112">Q 112</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    A(A&amp;&amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a;</span><br><span class="line">    B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"4"</span>; &#125;</span><br><span class="line">    B(<span class="keyword">const</span> B&amp; b) : a(b.a) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"5"</span>; &#125;</span><br><span class="line">    B(B&amp;&amp; b) : a(b.a) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"6"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b1;</span><br><span class="line">    B b2 = <span class="built_in">std</span>::<span class="built_in">move</span>(b1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1426<br>
b1 默认构造成功之前 a 先默认构造，因此输出 14.<br>
接着用移动构造函数初始化 b2，<code>std::move(b1)</code> 将 b1 的引用转化为一个将亡值，在 B 的移动构造函数中，a 在初始化列表中被构造，尽管此处的 b 是一个绑定了右值的右值引用，b 本身仍然是一个左值，因此调用的是 A 的拷贝构造函数，最后输出 26。</p>
<h4 id="Q-113">Q 113</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">0.0</span>);</span><br><span class="line">    f(<span class="number">0</span>);</span><br><span class="line">    f&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：132<br>
对于 f(0.0) 来说，T 被推导为 double，函数模板的一个特化被加入到重载解析的候选中，在所有的候选函数中 <code>f(double)</code> 是一个最好的匹配，输出 1。<br>
对于 f(0) 来说，函数模板中的 T 被推导为 int，函数模板的一个特化 <code>void f(int)</code> 被加入到重载解析的候选中，另一个则是非模板函数的 <code>void f(int)</code>，C++ 标准规定，一个非模板函数比一个特化的模板函数更加适合重载，因此输出 3。<br>
最后 f&lt;&gt;(0) 中的 &lt;&gt; 是一个空模板参数列表，可以为模板函数指定，但是不可以为非模板函数指定，因此 f&lt;&gt;(0) 显式地要求函数模板，C++ 标准规定，一个空的模板参数列表可以用于指定使用特化的函数模板，即使同时存在非模板函数。<br>
T 被推导为 int，int 的特化是唯一的候选项，打印 2。</p>
<h4 id="Q-114">Q 114</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>       </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;C&gt; v;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;C&gt; u;</span><br><span class="line">    C *<span class="keyword">const</span> p;</span><br><span class="line">    S() : v(<span class="number">1</span>), u(<span class="keyword">new</span> C()), p(u.<span class="built_in">get</span>()) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    <span class="keyword">const</span> S &amp;r = s;</span><br><span class="line"></span><br><span class="line">    s.v[<span class="number">0</span>].foo();</span><br><span class="line">    s.u-&gt;foo();</span><br><span class="line">    s.p-&gt;foo();</span><br><span class="line"></span><br><span class="line">    r.v[<span class="number">0</span>].foo();</span><br><span class="line">    r.u-&gt;foo();</span><br><span class="line">    r.p-&gt;foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：AAABAA<br>
C++ 标准规定，cv 限定符应用于指针而不是指向的对象。<br>
因此对于原始指针和引用，包括试图模拟它们的标准类型 <code>std::unique_ptr</code> 来说，<code>const</code> 限定符属于浅限定，而对于标准容器来说，<code>const</code> 则不是浅限定。<br>
上面的代码中对象 s 是 non-const 的，因此该对象的成员都保留了它的默认常量属性，即 non-const，并且所有对该对象成员的调用都使用 <code>C::foo()</code> 的 non-const 版本。<br>
然而，r 是对象 s 的常量引用，const 限定符改变了它的成员 v 的行为，此时 <code>std::vector</code> 的 <code>operator[]</code> 返回的是 <code>const C&amp;</code>，因此调用的是 <code>C::foo()</code> 的 const 版本，同时 r 的 const 属性也传递给它的成员 u 和 p，也就是说指针本身变成了常量，但指向的对象并不是常量，因此它们仍然调用 <code>C::foo()</code> 的 non-const 版本。<br>
最后，还要注意 <code>C* const p</code> 是一个指向非常量对象的常量指针。</p>
<h4 id="Q-115">Q 115</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：d<br>
浮点数字面量的类型为 <code>double</code>，除非明确地用后缀指定。</p>
<h4 id="Q-116">Q 116</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y</span><span class="params">(<span class="keyword">int</span> &amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y</span><span class="params">(<span class="keyword">int</span> &amp;&amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">int</span> <span class="title">f</span>(<span class="title">T</span> &amp;&amp;<span class="title">x</span>) &#123;</span> <span class="keyword">return</span> y(x); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">int</span> <span class="title">g</span>(<span class="title">T</span> &amp;&amp;<span class="title">x</span>) &#123;</span> <span class="keyword">return</span> y(<span class="built_in">std</span>::<span class="built_in">move</span>(x)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">int</span> <span class="title">h</span>(<span class="title">T</span> &amp;&amp;<span class="title">x</span>) &#123;</span> <span class="keyword">return</span> y(<span class="built_in">std</span>::forward&lt;T&gt;(x)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f(i) &lt;&lt; f(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; g(i) &lt;&lt; g(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; h(i) &lt;&lt; h(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：112212<br>
<strong>模板化函数中的 T&amp;&amp; 不一定表示右值引用，如果用左值实例化，它会坍缩成左值引用，如果用右值实例化，则会坍缩成右值引用</strong>。<br>
这三个函数分别使用左值和右值调用了一次，三种情况下都会分别坍缩成左值和右值引用，但是<strong>在函数内部，x 本身就是左值，不管它的类型是左值引用还是右值引用</strong>。</p>
<h4 id="Q-118">Q 118</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(short num)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"abc"</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误，<code>print(0)</code> 重载函数调用不明确<br>
空指针常量既可以是一个值为 0 的整型字面量，也可以是 std::nullptr_t 类型的右值。<br>
因此 0 既可以隐式转化为任何指针类型，也可以隐式转化为 short 类型。</p>
<h4 id="Q-119">Q 119</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * p = &amp;p;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">bool</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
p 中保存的是它自己的地址。</p>
<h4 id="Q-120">Q 120</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    x = a, b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：10<br>
逗号运算符的优先级在 C++ 中是最低的。</p>
<h4 id="Q-121">Q 121</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  x = (a, b);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：20<br>
先执行完括号内的表达式，然后将 b 赋值给 x。</p>
<h4 id="Q-122">Q 122</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">unsigned</span> ll)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo(<span class="number">2u</span>ll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：2<br>
默认情况下 <code>signed</code> <code>unsigned</code> <code>long</code> <code>short</code> 都暗指 <code>int</code>，因此在这些符号类型之后出现的类型名称均被视为声明的名称。<br>
因此 <code>void foo(unsigned ll)</code> 被编译器认为是需要一个 <code>unsigned(int)</code> 类型的变量，名称为 <code>ll</code>。</p>
<h4 id="Q-124">Q 124</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = A&gt;</span><br><span class="line">struct X;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&lt;A&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&lt;B&gt; &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = B&gt; class C&gt;</span><br><span class="line"><span class="keyword">void</span> g() &#123;</span><br><span class="line">    C&lt;&gt;::f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    g&lt;X&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：2<br>
模板的模板参数为 C，C 的范围是函数 g，因此默认的 T = B 被作为 C 的默认参数；<br>
也就是说，g 需要模板参数 C，此时传入 X，而 X 作为模板参数还需要一个参数，默认是 A，但是调用 <code>C::f</code> 时的默认参数为 B，因此调用的是 <code>X&lt;B&gt;::f</code>，因此输出 2。</p>
<h4 id="Q-125">Q 125</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">f</span>(<span class="title">T</span>) &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="number">1</span>);</span><br><span class="line">    f(<span class="number">1.0</span>);</span><br><span class="line">    f(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：112<br>
每个实例化后的函数模板都有它自己的一份静态变量的拷贝。<br>
本题中我们有两个 f 的实例化，一个 T = int，另一个 T = double，f(double) 中的静态变量 i 与 f(int) 中的静态变量 i 不是同一个 i。</p>
<h4 id="Q-126">Q 126</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foobar</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> foobar::x = foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foobar::x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：11<br>
在类的静态成员定义中使用的名称和类中成员函数的名称是一致的，换句话说，尽管 <code>foo()</code> 调用发生在类外，但是它位于静态数据成员的定义中，可以看作 <code>foo()</code> 是 <code>footbar</code> 的成员函数调用，而不是全局 <code>foo()</code> 的调用。</p>
<h4 id="Q-127">Q 127</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, &amp;j = i;</span><br><span class="line">    [=] &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; is_same&lt;<span class="keyword">decltype</span>   ((j)),     <span class="keyword">int</span>         &gt;::value</span><br><span class="line">            &lt;&lt; is_same&lt;<span class="keyword">decltype</span>   (((j))),    <span class="keyword">int</span>      &amp;  &gt;::value</span><br><span class="line">            &lt;&lt; is_same&lt;<span class="keyword">decltype</span>  ((((j)))),   <span class="keyword">int</span> <span class="keyword">const</span>&amp;  &gt;::value</span><br><span class="line">            &lt;&lt; is_same&lt;<span class="keyword">decltype</span> (((((j))))),  <span class="keyword">int</span>      &amp;&amp; &gt;::value</span><br><span class="line">            &lt;&lt; is_same&lt;<span class="keyword">decltype</span>((((((j)))))), <span class="keyword">int</span> <span class="keyword">const</span>&amp;&amp; &gt;::value;</span><br><span class="line">    &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：00100(01000)<br>
这其实是一道有点争议的题目，答案是 00100，VS2019 上是 01000。<br>
关键在于 lambda 表达式中捕获的 j 是否带有 const 限定符。<br>
因为 lambda 没有声明为 mutable，因此闭包类型重载 operator() 会是一个 const 成员函数。<br>
而当表达式出现在 const 成员函数中时，这个表达式也是 const 表达式。<br>
仅供参考。</p>
<h4 id="Q-129">Q 129</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; delimiters = &#123; <span class="string">","</span>, <span class="string">";"</span> &#125;;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; delimiters[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序行为未定义<br>
这道题用两个字符串字面量来初始化 <code>vector&lt;char&gt;</code>，模板类 <code>template &lt;class T&gt; vector</code> 的初始化列表的构造函数为 <code>vector(initializer_list&lt;T&gt;)</code> ，本题中为 <code>vector(initializer_list&lt;char&gt;)</code>，而字符串字面量的类型为 - <em>array of n const char</em> - 常量字符数组，并不匹配。<br>
但是这题为什么没有出现编译错误，是因为编译器找到了另一个匹配的构造函数。<br>
C++ 标准规定，当类型为 T 的类对象采用列表初始化的时候，重载解析会有两个选择构造函数的阶段：<br>
首先，候选函数是类 T 的初始化列表构造函数，参数列表只有一个参数，即初始化列表；<br>
如果没有找到合适的构造函数，重载解析会从类 T 的所有构造函数中寻找候选函数，参数列表由初始化列表中的元素组成；<br>
对于本题来说，<code>template &lt;class InputIterator&gt; vector(InputIterator first, InputIterator last)</code> 恰好满足第二种情况，构造函数认为它传入了两个正确的迭代器类型，但是其实这两个迭代器分别属于两个不同的序列，因此这个程序行为是未定义的。</p>
<h4 id="Q-130">Q 130</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adl</span><span class="params">(T)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"T"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_adl</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    adl(S());</span><br><span class="line">    adl(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adl</span><span class="params">(S)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"S"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    call_adl(S());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：TS<br>
当查找模板定义中使用的名称的声明时，对于非依赖模板参数的名称查找使用的是通常的查找规则，而依赖模板参数的名称查找会延迟到实际模板参数已知时。<br>
adl(s()) 属于非依赖调用，因此在定义函数模板的时候就进行了名称查找；<br>
adl(t) 属于依赖调用，该调用的解析推迟到模板实例化之后；<br>
当在定义函数模板时查找 adl 时，存在的 adl 的唯一版本就是 adl(t)，此时 adl(S) 还不存在，因此只会调用 adl(T)。</p>
<h4 id="Q-131">Q 131</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    C(<span class="keyword">double</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">c1</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    C c2 = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：id<br>
由于 explicit 关键字的存在，<code>C c2 = 7</code> 中是不会调用隐式转化构造函数的，在第二种情况下整型字面量会被转化为 <code>double</code> 类型构造函数。</p>
<h4 id="Q-132">Q 132</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> i = foo())</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bar();</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：11<br>
<code>foo()</code> 被调用了两次</p>
<h4 id="Q-133">Q 133</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"a"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span>; &#125;</span><br><span class="line">    B(<span class="keyword">const</span> B &amp;) &#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"b"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() &#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"C"</span>; &#125;</span><br><span class="line">    C(<span class="keyword">const</span> C &amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"c"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span>B,C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D() &#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"D"</span>; &#125;</span><br><span class="line">    D(<span class="keyword">const</span> D &amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    D d1;</span><br><span class="line">    <span class="function">D <span class="title">d2</span><span class="params">(d1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：ABCDABCd<br>
构造 d1 的时候，派生类是按照基类说明列表中的顺序来构造的，因此输出 ABCD；<br>
对于 d2 来说，一个隐式定义的拷贝/移动构造函数是会调用它基类的拷贝/移动构造函数的，但是如果提供了一个用户自定义的拷贝构造函数，就必须要手动设置调用基类的拷贝/移动构造函数。</p>
<h4 id="Q-135">Q 135</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">bool</span>,<span class="keyword">int</span>&gt; mb = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mb.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mi = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mi.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：13<br>
<code>map</code> 中的 <code>key</code> 是唯一的，而 mb 中的三个 <code>key</code> 都是 <code>true</code>，因此 size 为 1。</p>
<h4 id="Q-140">Q 140</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_size_1</span><span class="params">(<span class="keyword">int</span>* arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_size_2</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">get_size_3</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//Assume sizeof(int*) != sizeof(int[10])</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">sizeof</span>(<span class="built_in">array</span>) == get_size_1(<span class="built_in">array</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">sizeof</span>(<span class="built_in">array</span>) == get_size_2(<span class="built_in">array</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">sizeof</span>(<span class="built_in">array</span>) == get_size_3(<span class="built_in">array</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：001<br>
首先，<code>sizeof(array)</code> 返回的是数组 array 的大小。<br>
在 <code>get_size_3</code> 函数中，参数是一个大小为 10 的 <code>int</code> 类型数组的引用，C++ 标准规定，对一个引用类型使用 <code>sizeof</code> 运算符，结果是被引用类型的大小，因此 <code>get_size_3</code> 返回 10。<br>
而 <code>get_size_1</code> <code>get_size_2</code> 的参数均为指针，其中 <code>get_size_2</code> 的参数会从数组退化成指针，<code>sizeof</code> 运算符返回指针变量的大小。</p>
<h4 id="Q-144">Q 144</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt;::digits==<span class="number">63</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int</span>&gt;::digits==<span class="number">31</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;::digits==<span class="number">32</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">int</span> i = <span class="number">-0xffffffff</span>; i ; --i) &#123;</span><br><span class="line">            N[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        N[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; N[<span class="number">0</span>] &lt;&lt; N[<span class="number">1</span>] &lt;&lt; N[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：010<br>
无符号量的负值是从 2 ^ n 减去它的值计算出来的，其中 n 是提升操作数中的位数。<br>
本题中 n 为 32，因此 i = 1。</p>
<h4 id="Q-145">Q 145</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> &#123;</span></span><br><span class="line">    E() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    E(<span class="keyword">const</span> E&amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    ~E() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> E();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：13<br>
这道题的关键在于 E() 到底是什么。<br>
C++ 标准规定，纯右值是一个表达式，该表达式的值用于初始化一个对象、位域或者计算运算符的操作值。<br>
return 语句通过拷贝构造函数将函数调用对象初始化为全局左值或纯右值。<br>
E() 只是一个纯右值。</p>
<h4 id="Q-147">Q 147</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="comment">//What is wrong here??/</span></span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
<code>??/</code> 在 C++17 中已经被 <code>\</code> 取代了，具体可以参考 <a href="https://stackoverflow.com/questions/1234582/purpose-of-trigraph-sequences-in-c" target="_blank" rel="noopener">C++ Trigraph</a></p>
<h4 id="Q-148">Q 148</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (a + a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序行为未定义<br>
这里的问题不是缺少变量 a 的初始化 - 这里会隐式初始化为 0，而是两次访问变量 a 的顺序没有排序。<br>
C++ 标准规定，访问 volatile 类型的 glvalue（左值或将亡值）会产生副作用，针对同一片内存区域的无序访问属于未定义行为。</p>
<h4 id="Q-151">Q 151</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_signed&lt;<span class="keyword">char</span>&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序输出未指定<br>
char 对象能否保存负值完全是由实现决定的。</p>
<h4 id="Q-152">Q 152</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::is_signed&lt;<span class="keyword">char</span>&gt;::value)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">char</span>, <span class="keyword">signed</span> <span class="keyword">char</span>&gt;::value;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">char</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;::value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：0<br>
<code>char</code> <code>unsigned char</code> <code>signed char</code> 是三种完全不同的类型。</p>
<h4 id="Q-153">Q 153</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">"X"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
字符串字面量的类型为 <code>const</code> 字符数组，虽然大多数编译器允许 <code>char const []</code> 类型转换为 <code>char*</code>，但是 C++11 开始这是不合法的操作。</p>
<h4 id="Q-157">Q 157</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; (&amp;<span class="keyword">typeid</span>(A) == &amp;<span class="keyword">typeid</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：输出不确定<br>
<code>typeid</code> 表达式的返回值是一个静态类型 <code>const std::type_info</code> 的左值，因此我们比较的是两个指向 <code>const std::type_info</code> 的指针，C++ 标准中并不保证所有针对相同类型的 <code>typeid</code> 表达式的计算都会引用同一个 <code>std::type_info</code> 类型的实例，因此此处答案是不确定的。</p>
<h4 id="Q-158">Q 158</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"a"</span>; &#125;</span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"b"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Foo&gt; <span class="title">bar</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：aaaaa<br>
从 C++11 开始，<code>std::vector</code> 具有只有一个参数的构造函数：<code>explicit vector(size_type n, const Allocator&amp; = Allocator())</code>，用于创建一个<strong>具有 n 个已经值初始化了的元素</strong>的 vector，每一个值初始化的元素都需要调用默认构造函数。</p>
<h4 id="Q-159">Q 159</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">    f(i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：34<br>
C++ 标准规定，在调用函数时，进入函数之前，对函数所有参数的计算都已经结束，因此进入函数 <code>f(i++)</code> 之前 i 已经自增完成，所以函数中的 i 值为 4。</p>
<h4 id="Q-160">Q 160</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> a = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span> <span class="params">(<span class="keyword">int</span> a = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A *b = <span class="keyword">new</span> B;</span><br><span class="line">    b-&gt;foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：B1<br>
本题创建了一个 B 类对象，然后用 A 指针指向它，由于 foo 是虚函数，因此父类指针指向子类对象，调用的是 B 类中的 foo，但是虚函数调用中使用的缺省参数由表示对象的指针或者引用的静态类型决定，因此这里使用的是 A 类的默认参数，a 等于 1。</p>
<h4 id="Q-161">Q 161</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                ++i;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">while</span> (--n &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：5<br>
C++ 标准规定，<code>switch</code> 语句后可以跟随任何有效语句，包括复合语句，<code>do-while</code> 的执行不会被 <code>case</code> 标签所改变。</p>
<h4 id="Q-162">Q 162</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B&lt;T&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    d.g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
根据 C++ 标准，在类或类模板的定义中，如果基类依赖于模板参数，则在类模板的定义处以及类模板的实例化过程中不会检查基类的范围。因此当编译器看到 <code>g()</code> 调用 <code>f()</code> 的时候，应该从全局作用域中选择一个。</p>
<h4 id="Q-163">Q 163</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> foo = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span>&amp; <span class="title">getFoo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> foo; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printFoo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; foo; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bar = a.getFoo();</span><br><span class="line">    ++bar;</span><br><span class="line"></span><br><span class="line">    a.printFoo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：0<br>
对于函数模板来说，每个已声明变量的类型都是由占位符类型推导决定的。<br>
下面两种写法是一致：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Method 1</span></span><br><span class="line"><span class="keyword">auto</span> bar = a.getFoo();</span><br><span class="line"><span class="comment">// Method 2</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f</span><span class="params">(T t)</span></span>;</span><br><span class="line">f(a.getFoo());</span><br></pre></td></tr></table></figure>
<p>而函数模板参数的推断过程会尝试着去找到一个参数<strong>使得推断出的参数与调用的参数保持一致</strong> - <em>the deduction process attempts to find template argument values that will make the deduced A identical to A where A is the type of the argument of the call</em><br>
<code>getFoo()</code> 返回 <code>int&amp;</code> 类型，C++ 标准规定，如果表达式最初具有 <code>T&amp;</code> 类型，在进行任何 further analysis 之前类型都会被调整为 <code>T</code>。<br>
因此 <code>a.getFoo()</code> 的类型被推断为 <code>int</code>，也就是说 <code>f(T t)</code> 中 <code>T</code> 也为 <code>int</code>，<code>bar</code> 的类型也为 <code>int</code>。</p>
<h4 id="Q-174">Q 174</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    f(x,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：01<br>
变量 a 和 b 都绑定在同一个 x 上，const int&amp; b 表示函数中不能通过引用修改传入参数的值。</p>
<h4 id="Q-177">Q 177</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;::digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：输出不确定（可能为 8）<br>
大概率的搞笑题，<code>unsigned char</code> 和 <code>char</code> 大小相同，<code>char</code> 的大小足以存储实现的基本字符集的任何成员即可。</p>
<h4 id="Q-178">Q 178</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>,b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a+++++b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
<code>a+++++b</code> 会被解析为 <code>a++ ++ + b</code>，但是 a++ 的结果是个纯右值，而后置自增运算符需要参数为可修改的左值，因此编译错误。</p>
<h4 id="Q-184">Q 184</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"d"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    d.f(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：d<br>
重载解析之所以没有选择明显更优的函数 void f(int)，因为 void f(int) 根本不在重载解析的范围内。<br>
派生类中引入函数名称 f 时将会隐藏基类中的同名函数。</p>
<h4 id="Q-185">Q 185</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> stat = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stat++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    f&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    f&lt;<span class="keyword">const</span> <span class="keyword">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：010<br>
<code>f&lt;int&gt;()</code> 和 <code>f&lt;const int&gt;()</code> 是不同的函数，因此它们的 static int stat 不是共享的。</p>
<h4 id="Q-186">Q 186</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">takes_pointer</span><span class="params">(<span class="keyword">int</span>* pointer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeid</span>(pointer) == <span class="keyword">typeid</span>(<span class="keyword">int</span>[])) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeid</span>(pointer) == <span class="keyword">typeid</span>(<span class="keyword">int</span>*)) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'p'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">takes_array</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeid</span>(<span class="built_in">array</span>) == <span class="keyword">typeid</span>(<span class="keyword">int</span>[])) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeid</span>(<span class="built_in">array</span>) == <span class="keyword">typeid</span>(<span class="keyword">int</span>*)) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'p'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* pointer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    takes_pointer(<span class="built_in">array</span>);</span><br><span class="line">    takes_array(pointer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">typeid</span>(<span class="keyword">int</span>*) == <span class="keyword">typeid</span>(<span class="keyword">int</span>[]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：pp0<br>
接收指针作为参数的函数也能够使用数组来调用，反之亦然。<br>
先看 <code>takes_pointer(array)</code>，当函数需要一个指针作为参数时，如果传入的是一个数组，该数组会退化成一个指针。<br>
更准确地说，一个元素类型为 T 的数组类型的左值或者右值可以转化为指向 T 类型的指针的纯右值。<br>
因此数组 array 会转化成指向 <code>int</code> 类型的指针，这个指针是一个纯右值。<br>
再看 <code>takes_array(pointer)</code>，C++ 标准规定，在确定了每个参数的类型后，任何 T 类型的数组都会被转换成 T 类型的指针。<br>
因此 <code>takes_array(int array[])</code> 中的 array[] 其实已经被转换为 <code>int*</code> 了。</p>
<h4 id="Q-187">Q 187</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    C() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    C(<span class="keyword">const</span> C&amp; other) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    C&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> C&amp; other) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c1;</span><br><span class="line">    C c2 = c1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：12<br>
拷贝构造指的是通过 <em>brace-or-equal-initializer</em> 方式初始化的构造，<code>C c2 = c1</code> 就是通过 equal 来<strong>构造一个新的对象</strong>。</p>
<h4 id="Q-188">Q 188</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* a = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">"Hello"</span>);</span><br><span class="line">    a[<span class="number">4</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：未定义行为<br>
修改字符串字面量是未定义行为，实际上，字符串字面量的存储是在只读存储区内。<br>
此外，对于使用 <code>const_cast</code> 去除 <code>const</code> 限定的目的绝对不是为了修改它的内容，只是出于无奈。</p>
<h4 id="Q-190">Q 190</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A(<span class="keyword">int</span> i) : m_i(i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_i &gt; <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1(1), a2(2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a1 + a2 &lt;&lt; (a1 == a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：21<br>
<code>a1 + a2</code> 和 <code>a1 == a2</code> 使用的都是 <code>int</code> 类型的内建运算符。a1 和 a2 先是隐式转换为 <code>bool</code> 然后再隐式转换为 <code>int</code>。<br>
由于结构体 A 并没有重载 <code>operator+</code>，使用的是 <code>int</code> 的内建运算符，那么我们有什么方法可以将 a1 和 a2 转换成语 <code>operator+</code> 兼容呢，首先尝试的是用户自动一的转换函数 <code>bool()</code>，因为一个纯右值的 <code>bool</code> 量能够转换成 <code>int</code> 类型，因此隐式转换继续执行，true 会被转换为 1，false 会被转换为 0，<code>operator==</code> 也是同样的转换方式。</p>
<h4 id="Q-191">Q 191</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; B::x;</span><br><span class="line">    A::x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; B::x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：01<br>
出现在不同命名空间范围内的具有相同名称的变量的两个声明指的是同一个变量。</p>
<h4 id="Q-192">Q 192</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    v.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    v.push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    g(f1(), f2());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    h();</span><br><span class="line">    h();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (v[<span class="number">0</span>] == v[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：程序行为未指定<br>
函数参数表达式的计算顺序是未指定的，我们唯一能确定的就是函数 f1 和 f2 会在函数 g 执行之前执行完毕。</p>
<h4 id="Q-193">Q 193</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &lt;%<span class="number">1</span>%&gt;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a&lt;:<span class="number">0</span>:&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
C++ 标准为一些标点符号提供了可选标记，原代码等价于下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>除了拼写不同，这些符号的行为都是相同的，即：<br>
<code>&lt;%%&gt;</code> 等价于 <code>{}</code><br>
<code>&lt;::&gt;</code> 等价于 <code>[]</code></p>
<h4 id="Q-195">Q 195</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_pointer_v&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：0<br>
<code>std::is_pointer_v</code> 用于判断参数是否为指针类型。<br>
nullptr 是类型为 <code>std::nullptr_t</code> 的纯右值，该类型不是指针类型，事实上 nullptr 是一个空指针常量，它能够被转换为指针。</p>
<h4 id="Q-196">Q 196</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> x &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> y &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> x::C&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(x::C());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：1<br>
函数 f(x::C()) 调用没有指定命名空间，但是 C++ 中使用了依赖于实参名字的查找，函数参数的命名空间被添加到函数命名空间的查找中，因为我们将 x::C() 传递给了函数 f，因此在编译函数 f 时也会查找命名空间 x 并找到 x::f。</p>
<h4 id="Q-197">Q 197</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; i = j, j;</span><br><span class="line">    j = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：12<br>
局部变量 j 的作用域是从它定义开始一直到 main 函数结束，在这段时间内，局部的 j 会将全局的 j 覆盖掉。<br>
因此引用 i 绑定的是全局的 j，j = 2 修改的是局部的 j，因此答案为 12。</p>
<h4 id="Q-198">Q 198</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="keyword">int</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123; <span class="keyword">int</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; B::x;</span><br><span class="line">    A::x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; B::x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A</strong>：编译错误<br>
C++ 标准规定，出现在不同命名空间范围中的具有相同名称的 C 语言链接的变量的两个声明指的是同一个变量。因此 A::x 和 B::x 表示的是同一个变量。<br>
这道题与 #191 的不同之处在于 int x 是一个定义而不是声明，直接包含在链接规范中的声明被看作包含 extern 说明符，而变量 x 并没有直接包含在链接规范中，因此它没有隐式的 extern 说明，这两个 x 被看作重复定义。<br>
具体的区别还可以参考下面的代码来理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declaration</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// definition</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Archie Scott</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/ArchieScott/posts/467b42a7/">https://github.com/ArchieScott/posts/467b42a7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/ArchieScott" target="_blank">夏の終わり</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/C-Quiz/">C++ Quiz</a><a class="post-meta__tags" href="/tags/Programming-Language/">Programming-Language</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/07/19/qJZaAbtcCUi4xgS.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechatpay.png" alt="wechat" onclick="window.open('/img/wechatpay.png')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="alipay" onclick="window.open('/img/alipay.jpg')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/7651320d/"><img class="prev-cover" data-src="https://i.loli.net/2020/07/19/c1EOdjLbzienwqa.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ Quiz 题解 201~300</div></div></a></div><div class="next-post pull-right"><a href="/posts/e24af74a/"><img class="next-cover" data-src="https://i.loli.net/2020/07/19/c1EOdjLbzienwqa.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++ Quiz 题解 001~100</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/e24af74a/" title="C++ Quiz 题解 001~100"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/07/19/c1EOdjLbzienwqa.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-27</div><div class="relatedPosts_title">C++ Quiz 题解 001~100</div></div></a></div><div class="relatedPosts_item"><a href="/posts/7651320d/" title="C++ Quiz 题解 201~300"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/07/19/c1EOdjLbzienwqa.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-27</div><div class="relatedPosts_title">C++ Quiz 题解 201~300</div></div></a></div><div class="relatedPosts_item"><a href="/posts/54e19ff4/" title="C++ 和 Java：区别到底在哪里"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/07/19/c1EOdjLbzienwqa.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="relatedPosts_title">C++ 和 Java：区别到底在哪里</div></div></a></div><div class="relatedPosts_item"><a href="/posts/2f6c672d/" title="C++ 中的 syncPrimitives：mutex"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/07/19/c1EOdjLbzienwqa.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-24</div><div class="relatedPosts_title">C++ 中的 syncPrimitives：mutex</div></div></a></div><div class="relatedPosts_item"><a href="/posts/47473230/" title="C++ 中的 syncPrimitives：lock"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/07/19/c1EOdjLbzienwqa.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-25</div><div class="relatedPosts_title">C++ 中的 syncPrimitives：lock</div></div></a></div><div class="relatedPosts_item"><a href="/posts/1f8822d7/" title="Windows 下配置 CLion + Cygwin 开发环境"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/07/19/c1EOdjLbzienwqa.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-29</div><div class="relatedPosts_title">Windows 下配置 CLion + Cygwin 开发环境</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: '8Q0H1FlCSwH5h7HQWC46LjKJ-MdYXbMMI',
  appKey: 'j08JUoxyhUwEvKHN2JOA6w98',
  placeholder: '404 Not Found',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: true,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Archie Scott</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">好久不见</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>